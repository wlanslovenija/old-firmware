Index: linux-2.6.21.7/arch/arm/boot/compressed/head-at91rm9200.S
===================================================================
--- linux-2.6.21.7.orig/arch/arm/boot/compressed/head-at91rm9200.S
+++ linux-2.6.21.7/arch/arm/boot/compressed/head-at91rm9200.S
@@ -67,6 +67,12 @@
 		cmp	r7, r3
 		beq	99f
 
+		@ Promwad Chub : 1181
+		mov	r3,	#(MACH_TYPE_CHUB & 0xff)
+		orr	r3, r3, #(MACH_TYPE_CHUB & 0xff00)
+		cmp	r7, r3
+		beq	99f
+
 		@ Unknown board, use the AT91RM9200DK board
 		@ mov	r7, #MACH_TYPE_AT91RM9200
 		mov	r7,	#(MACH_TYPE_AT91RM9200DK & 0xff)
Index: linux-2.6.21.7/arch/arm/mach-at91/Kconfig
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/Kconfig
+++ linux-2.6.21.7/arch/arm/mach-at91/Kconfig
@@ -17,6 +17,9 @@ config ARCH_AT91SAM9261
 config ARCH_AT91SAM9263
 	bool "AT91SAM9263"
 
+config ARCH_AT91SAM9RL
+	bool "AT91SAM9RL"
+
 endchoice
 
 # ----------------------------------------------------------
@@ -87,6 +90,12 @@ config MACH_KAFA
 	help
 	  Select this if you are using Sperry-Sun's KAFA board.
 
+config MACH_CHUB
+	bool "Promwad Chub board"
+	depends on ARCH_AT91RM9200
+	help
+	  Select this if you are using Promwad's Chub board.
+
 endif
 
 # ----------------------------------------------------------
@@ -111,6 +120,13 @@ config MACH_AT91SAM9260EK
 	  Select this if you are using Atmel's AT91SAM9260-EK or AT91SAM9XE Evaluation Kit
 	  <http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3933>
 
+config MACH_CAM60
+	bool "KwikByte CAM60 board"
+	depends on ARCH_AT91SAM9260
+	help
+	  Select this if you are using KwikByte's CAM60 board based on the Atmel AT91SAM9260.
+	  <http://www.kwikbyte.com>
+
 endif
 
 # ----------------------------------------------------------
@@ -145,6 +161,20 @@ endif
 
 # ----------------------------------------------------------
 
+if ARCH_AT91SAM9RL
+
+comment "AT91SAM9RL Board Type"
+
+config MACH_AT91SAM9RLEK
+	bool "Atmel AT91SAM9RL-EK Evaluation Kit"
+	depends on ARCH_AT91SAM9RL
+	help
+	  Select this if you are using Atmel's AT91SAM9RL-EK Evaluation Kit.
+
+endif
+
+# ----------------------------------------------------------
+
 comment "AT91 Board Options"
 
 config MTD_AT91_DATAFLASH_CARD
@@ -160,6 +190,20 @@ config MTD_NAND_AT91_BUSWIDTH_16
 	  On AT91SAM926x boards both types of NAND flash can be present
 	  (8 and 16 bit data bus width).
 
+config CSB300_WAKE_SW0
+	bool "CSB300 SW0 irq0 wakeup"
+	depends on MACH_CSB337 && PM
+	help
+	  If you have a CSB300 connected to your CSB337, this lets
+	  SW0 serve as a wakeup button.  It uses IRQ0.
+
+config CSB300_WAKE_SW1
+	bool "CSB300 SW1 gpio wakeup"
+	depends on MACH_CSB337 && PM
+	help
+	  If you have a CSB300 connected to your CSB337, this lets
+	  SW1 serve as a wakeup button.  It uses GPIO.
+
 # ----------------------------------------------------------
 
 comment "AT91 Feature Selections"
@@ -170,6 +214,20 @@ config AT91_PROGRAMMABLE_CLOCKS
 	  Select this if you need to program one or more of the PCK0..PCK3
 	  programmable clock outputs.
 
+config ATMEL_TCLIB
+	bool "Timer/Counter Library"
+	help
+	  Select this if you want a library to allocate the Timer/Counter
+	  blocks found on many Atmel processors.  This facilitates using
+	  these modules despite processor differences.
+
+config AT91_SLOW_CLOCK
+	bool "Suspend-to-RAM uses slow clock mode (EXPERIMENTAL)"
+	depends on PM && EXPERIMENTAL
+	help
+	  Select this if you wish to put the CPU into slow clock mode
+	  while in the "Suspend to RAM" state, to save more power.
+
 endmenu
 
 endif
Index: linux-2.6.21.7/arch/arm/mach-at91/Makefile
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/Makefile
+++ linux-2.6.21.7/arch/arm/mach-at91/Makefile
@@ -8,12 +8,15 @@ obj-n		:=
 obj-		:=
 
 obj-$(CONFIG_PM)		+= pm.o
+obj-$(CONFIG_AT91_SLOW_CLOCK)	+= pm_slowclock.o
+obj-$(CONFIG_ATMEL_TCLIB)	+= tclib.o
 
 # CPU-specific support
 obj-$(CONFIG_ARCH_AT91RM9200)	+= at91rm9200.o at91rm9200_time.o at91rm9200_devices.o
 obj-$(CONFIG_ARCH_AT91SAM9260)	+= at91sam9260.o at91sam926x_time.o at91sam9260_devices.o
 obj-$(CONFIG_ARCH_AT91SAM9261)	+= at91sam9261.o at91sam926x_time.o at91sam9261_devices.o
 obj-$(CONFIG_ARCH_AT91SAM9263)	+= at91sam9263.o at91sam926x_time.o at91sam9263_devices.o
+obj-$(CONFIG_ARCH_AT91SAM9RL)	+= at91sam9rl.o at91sam926x_time.o at91sam9rl_devices.o
 
 # AT91RM9200 board-specific support
 obj-$(CONFIG_MACH_ONEARM)	+= board-1arm.o
@@ -25,9 +28,11 @@ obj-$(CONFIG_MACH_CARMEVA)	+= board-carm
 obj-$(CONFIG_MACH_KB9200)	+= board-kb9202.o
 obj-$(CONFIG_MACH_ATEB9200)	+= board-eb9200.o
 obj-$(CONFIG_MACH_KAFA)		+= board-kafa.o
+obj-$(CONFIG_MACH_CHUB)		+= board-chub.o
 
 # AT91SAM9260 board-specific support
 obj-$(CONFIG_MACH_AT91SAM9260EK) += board-sam9260ek.o
+obj-$(CONFIG_MACH_CAM60)	+= board-cam60.o
 
 # AT91SAM9261 board-specific support
 obj-$(CONFIG_MACH_AT91SAM9261EK) += board-sam9261ek.o
@@ -35,9 +40,13 @@ obj-$(CONFIG_MACH_AT91SAM9261EK) += boar
 # AT91SAM9263 board-specific support
 obj-$(CONFIG_MACH_AT91SAM9263EK) += board-sam9263ek.o
 
+# AT91SAM9RL board-specific support
+obj-$(CONFIG_MACH_AT91SAM9RLEK)	+= board-sam9rlek.o
+
 # LEDs support
 led-$(CONFIG_ARCH_AT91RM9200DK)	+= leds.o
 led-$(CONFIG_MACH_AT91RM9200EK)	+= leds.o
+led-$(CONFIG_MACH_AT91SAM9261EK)+= leds.o
 led-$(CONFIG_MACH_CSB337)	+= leds.o
 led-$(CONFIG_MACH_CSB637)	+= leds.o
 led-$(CONFIG_MACH_KB9200)	+= leds.o
@@ -45,7 +54,7 @@ led-$(CONFIG_MACH_KAFA)		+= leds.o
 obj-$(CONFIG_LEDS) += $(led-y)
 
 # VGA support
-#obj-$(CONFIG_FB_S1D13XXX)	+= ics1523.o
+obj-$(CONFIG_FB_S1D13XXX)	+= ics1523.o
 
 
 ifeq ($(CONFIG_PM_DEBUG),y)
Index: linux-2.6.21.7/arch/arm/mach-at91/at91rm9200.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/at91rm9200.c
+++ linux-2.6.21.7/arch/arm/mach-at91/at91rm9200.c
@@ -117,6 +117,21 @@ static struct clk pioD_clk = {
 	.pmc_mask	= 1 << AT91RM9200_ID_PIOD,
 	.type		= CLK_TYPE_PERIPHERAL,
 };
+static struct clk ssc0_clk = {
+	.name		= "ssc0_clk",
+	.pmc_mask	= 1 << AT91RM9200_ID_SSC0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk ssc1_clk = {
+	.name		= "ssc1_clk",
+	.pmc_mask	= 1 << AT91RM9200_ID_SSC1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk ssc2_clk = {
+	.name		= "ssc2_clk",
+	.pmc_mask	= 1 << AT91RM9200_ID_SSC2,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
 static struct clk tc0_clk = {
 	.name		= "tc0_clk",
 	.pmc_mask	= 1 << AT91RM9200_ID_TC0,
@@ -161,7 +176,9 @@ static struct clk *periph_clocks[] __ini
 	&udc_clk,
 	&twi_clk,
 	&spi_clk,
-	// ssc 0 .. ssc2
+	&ssc0_clk,
+	&ssc1_clk,
+	&ssc2_clk,
 	&tc0_clk,
 	&tc1_clk,
 	&tc2_clk,
@@ -250,6 +267,33 @@ static void at91rm9200_reset(void)
 
 
 /* --------------------------------------------------------------------
+ *  Timer/Counter library initialization
+ * -------------------------------------------------------------------- */
+#ifdef CONFIG_ATMEL_TCLIB
+
+#include "tclib.h"
+
+static struct atmel_tcblock at91rm9200_tcblocks[] = {
+	[0] = {
+		.physaddr	= AT91RM9200_BASE_TCB0,
+		.irq		= { AT91RM9200_ID_TC0, AT91RM9200_ID_TC1, AT91RM9200_ID_TC2 },
+		.clk		= { &tc0_clk, &tc1_clk, &tc2_clk },
+	},
+	[1] = {
+		.physaddr	= AT91RM9200_BASE_TCB1,
+		.irq		= { AT91RM9200_ID_TC3, AT91RM9200_ID_TC4, AT91RM9200_ID_TC5 },
+		.clk		= { &tc3_clk, &tc4_clk, &tc5_clk },
+	},
+};
+
+#define at91rm9200_tc_init()	atmel_tc_init(at91rm9200_tcblocks, ARRAY_SIZE(at91rm9200_tcblocks))
+
+#else
+#define at91rm9200_tc_init()	do {} while(0)
+#endif
+
+
+/* --------------------------------------------------------------------
  *  AT91RM9200 processor initialization
  * -------------------------------------------------------------------- */
 void __init at91rm9200_initialize(unsigned long main_clock, unsigned short banks)
@@ -271,6 +315,9 @@ void __init at91rm9200_initialize(unsign
 
 	/* Initialize GPIO subsystem */
 	at91_gpio_init(at91rm9200_gpio, banks);
+
+	/* Initialize the Timer/Counter blocks */
+	at91rm9200_tc_init();
 }
 
 
@@ -284,28 +331,28 @@ void __init at91rm9200_initialize(unsign
 static unsigned int at91rm9200_default_irq_priority[NR_AIC_IRQS] __initdata = {
 	7,	/* Advanced Interrupt Controller (FIQ) */
 	7,	/* System Peripherals */
-	0,	/* Parallel IO Controller A */
-	0,	/* Parallel IO Controller B */
-	0,	/* Parallel IO Controller C */
-	0,	/* Parallel IO Controller D */
-	6,	/* USART 0 */
-	6,	/* USART 1 */
-	6,	/* USART 2 */
-	6,	/* USART 3 */
+	1,	/* Parallel IO Controller A */
+	1,	/* Parallel IO Controller B */
+	1,	/* Parallel IO Controller C */
+	1,	/* Parallel IO Controller D */
+	5,	/* USART 0 */
+	5,	/* USART 1 */
+	5,	/* USART 2 */
+	5,	/* USART 3 */
 	0,	/* Multimedia Card Interface */
-	4,	/* USB Device Port */
-	0,	/* Two-Wire Interface */
-	6,	/* Serial Peripheral Interface */
-	5,	/* Serial Synchronous Controller 0 */
-	5,	/* Serial Synchronous Controller 1 */
-	5,	/* Serial Synchronous Controller 2 */
+	2,	/* USB Device Port */
+	6,	/* Two-Wire Interface */
+	5,	/* Serial Peripheral Interface */
+	4,	/* Serial Synchronous Controller 0 */
+	4,	/* Serial Synchronous Controller 1 */
+	4,	/* Serial Synchronous Controller 2 */
 	0,	/* Timer Counter 0 */
 	0,	/* Timer Counter 1 */
 	0,	/* Timer Counter 2 */
 	0,	/* Timer Counter 3 */
 	0,	/* Timer Counter 4 */
 	0,	/* Timer Counter 5 */
-	3,	/* USB Host port */
+	2,	/* USB Host port */
 	3,	/* Ethernet MAC */
 	0,	/* Advanced Interrupt Controller (IRQ0) */
 	0,	/* Advanced Interrupt Controller (IRQ1) */
Index: linux-2.6.21.7/arch/arm/mach-at91/at91rm9200_devices.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/at91rm9200_devices.c
+++ linux-2.6.21.7/arch/arm/mach-at91/at91rm9200_devices.c
@@ -480,7 +480,18 @@ void __init at91_add_device_i2c(void) {}
  *  SPI
  * -------------------------------------------------------------------- */
 
-#if defined(CONFIG_SPI_AT91) || defined(CONFIG_SPI_AT91_MODULE) || defined(CONFIG_AT91_SPI) || defined(CONFIG_AT91_SPI_MODULE)
+#if defined(CONFIG_AT91_SPI) || defined(CONFIG_AT91_SPI_MODULE)		/* legacy SPI driver */
+#define SPI_DEVNAME	"at91_spi"
+
+#elif defined(CONFIG_SPI_AT91) || defined(CONFIG_SPI_AT91_MODULE)	/* SPI bitbanging driver */
+#define SPI_DEVNAME	"at91_spi"
+
+#elif defined(CONFIG_SPI_ATMEL) || defined(CONFIG_SPI_ATMEL_MODULE)	/* new SPI driver */
+#define SPI_DEVNAME	"atmel_spi"
+
+#endif
+
+#ifdef SPI_DEVNAME
 static u64 spi_dmamask = 0xffffffffUL;
 
 static struct resource spi_resources[] = {
@@ -497,7 +508,7 @@ static struct resource spi_resources[] =
 };
 
 static struct platform_device at91rm9200_spi_device = {
-	.name		= "at91_spi",
+	.name		= SPI_DEVNAME,
 	.id		= 0,
 	.dev		= {
 				.dma_mask		= &spi_dmamask,
@@ -606,6 +617,32 @@ void __init at91_init_leds(u8 cpu_led, u
 #endif
 
 
+#if defined(CONFIG_NEW_LEDS)
+
+static struct platform_device at91_leds = {
+	.name		= "at91_leds",
+	.id		= -1,
+};
+
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr)
+{
+	if (!nr)
+		return;
+
+	at91_leds.dev.platform_data = leds;
+
+	for ( ; nr; nr--, leds++) {
+		leds->index = nr;	/* first record stores number of leds */
+		at91_set_gpio_output(leds->gpio, (leds->flags & 1) == 0);
+	}
+
+	platform_device_register(&at91_leds);
+}
+#else
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr) {}
+#endif
+
+
 /* --------------------------------------------------------------------
  *  UART
  * -------------------------------------------------------------------- */
Index: linux-2.6.21.7/arch/arm/mach-at91/at91sam9260.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/at91sam9260.c
+++ linux-2.6.21.7/arch/arm/mach-at91/at91sam9260.c
@@ -119,6 +119,11 @@ static struct clk spi1_clk = {
 	.pmc_mask	= 1 << AT91SAM9260_ID_SPI1,
 	.type		= CLK_TYPE_PERIPHERAL,
 };
+static struct clk ssc_clk = {
+	.name		= "ssc_clk",
+	.pmc_mask	= 1 << AT91SAM9260_ID_SSC,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
 static struct clk tc0_clk = {
 	.name		= "tc0_clk",
 	.pmc_mask	= 1 << AT91SAM9260_ID_TC0,
@@ -193,7 +198,7 @@ static struct clk *periph_clocks[] __ini
 	&twi_clk,
 	&spi0_clk,
 	&spi1_clk,
-	// ssc
+	&ssc_clk,
 	&tc0_clk,
 	&tc1_clk,
 	&tc2_clk,
@@ -264,6 +269,33 @@ static void at91sam9260_reset(void)
 
 
 /* --------------------------------------------------------------------
+ *  Timer/Counter library initialization
+ * -------------------------------------------------------------------- */
+#ifdef CONFIG_ATMEL_TCLIB
+
+#include "tclib.h"
+
+static struct atmel_tcblock at91sam9260_tcblocks[] = {
+	[0] = {
+		.physaddr	= AT91SAM9260_BASE_TCB0,
+		.irq		= { AT91SAM9260_ID_TC0, AT91SAM9260_ID_TC1, AT91SAM9260_ID_TC2 },
+		.clk		= { &tc0_clk, &tc1_clk, &tc2_clk },
+	},
+	[1] = {
+		.physaddr	= AT91SAM9260_BASE_TCB1,
+		.irq		= { AT91SAM9260_ID_TC3, AT91SAM9260_ID_TC4, AT91SAM9260_ID_TC5 },
+		.clk		= { &tc3_clk, &tc4_clk, &tc5_clk },
+	},
+};
+
+#define at91sam9260_tc_init()	atmel_tc_init(at91sam9260_tcblocks, ARRAY_SIZE(at91sam9260_tcblocks))
+
+#else
+#define at91sam9260_tc_init()	do {} while(0)
+#endif
+
+
+/* --------------------------------------------------------------------
  *  AT91SAM9260 processor initialization
  * -------------------------------------------------------------------- */
 
@@ -310,6 +342,9 @@ void __init at91sam9260_initialize(unsig
 
 	/* Register GPIO subsystem */
 	at91_gpio_init(at91sam9260_gpio, 3);
+
+	/* Initialize the Timer/Counter blocks */
+	at91sam9260_tc_init();
 }
 
 /* --------------------------------------------------------------------
@@ -322,30 +357,30 @@ void __init at91sam9260_initialize(unsig
 static unsigned int at91sam9260_default_irq_priority[NR_AIC_IRQS] __initdata = {
 	7,	/* Advanced Interrupt Controller */
 	7,	/* System Peripherals */
-	0,	/* Parallel IO Controller A */
-	0,	/* Parallel IO Controller B */
-	0,	/* Parallel IO Controller C */
+	1,	/* Parallel IO Controller A */
+	1,	/* Parallel IO Controller B */
+	1,	/* Parallel IO Controller C */
 	0,	/* Analog-to-Digital Converter */
-	6,	/* USART 0 */
-	6,	/* USART 1 */
-	6,	/* USART 2 */
+	5,	/* USART 0 */
+	5,	/* USART 1 */
+	5,	/* USART 2 */
 	0,	/* Multimedia Card Interface */
-	4,	/* USB Device Port */
-	0,	/* Two-Wire Interface */
-	6,	/* Serial Peripheral Interface 0 */
-	6,	/* Serial Peripheral Interface 1 */
+	2,	/* USB Device Port */
+	6,	/* Two-Wire Interface */
+	5,	/* Serial Peripheral Interface 0 */
+	5,	/* Serial Peripheral Interface 1 */
 	5,	/* Serial Synchronous Controller */
 	0,
 	0,
 	0,	/* Timer Counter 0 */
 	0,	/* Timer Counter 1 */
 	0,	/* Timer Counter 2 */
-	3,	/* USB Host port */
+	2,	/* USB Host port */
 	3,	/* Ethernet */
 	0,	/* Image Sensor Interface */
-	6,	/* USART 3 */
-	6,	/* USART 4 */
-	6,	/* USART 5 */
+	5,	/* USART 3 */
+	5,	/* USART 4 */
+	5,	/* USART 5 */
 	0,	/* Timer Counter 3 */
 	0,	/* Timer Counter 4 */
 	0,	/* Timer Counter 5 */
Index: linux-2.6.21.7/arch/arm/mach-at91/at91sam9260_devices.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/at91sam9260_devices.c
+++ linux-2.6.21.7/arch/arm/mach-at91/at91sam9260_devices.c
@@ -527,6 +527,32 @@ void __init at91_init_leds(u8 cpu_led, u
 #endif
 
 
+#if defined(CONFIG_NEW_LEDS)
+
+static struct platform_device at91_leds = {
+	.name		= "at91_leds",
+	.id		= -1,
+};
+
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr)
+{
+	if (!nr)
+		return;
+
+	at91_leds.dev.platform_data = leds;
+
+	for ( ; nr; nr--, leds++) {
+		leds->index = nr;	/* first record stores number of leds */
+		at91_set_gpio_output(leds->gpio, (leds->flags & 1) == 0);
+	}
+
+	platform_device_register(&at91_leds);
+}
+#else
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr) {}
+#endif
+
+
 /* --------------------------------------------------------------------
  *  UART
  * -------------------------------------------------------------------- */
Index: linux-2.6.21.7/arch/arm/mach-at91/at91sam9261.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/at91sam9261.c
+++ linux-2.6.21.7/arch/arm/mach-at91/at91sam9261.c
@@ -97,6 +97,21 @@ static struct clk spi1_clk = {
 	.pmc_mask	= 1 << AT91SAM9261_ID_SPI1,
 	.type		= CLK_TYPE_PERIPHERAL,
 };
+static struct clk ssc0_clk = {
+	.name		= "ssc0_clk",
+	.pmc_mask	= 1 << AT91SAM9261_ID_SSC0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk ssc1_clk = {
+	.name		= "ssc1_clk",
+	.pmc_mask	= 1 << AT91SAM9261_ID_SSC1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk ssc2_clk = {
+	.name		= "ssc2_clk",
+	.pmc_mask	= 1 << AT91SAM9261_ID_SSC2,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
 static struct clk tc0_clk = {
 	.name		= "tc0_clk",
 	.pmc_mask	= 1 << AT91SAM9261_ID_TC0,
@@ -135,7 +150,9 @@ static struct clk *periph_clocks[] __ini
 	&twi_clk,
 	&spi0_clk,
 	&spi1_clk,
-	// ssc 0 .. ssc2
+	&ssc0_clk,
+	&ssc1_clk,
+	&ssc2_clk,
 	&tc0_clk,
 	&tc1_clk,
 	&tc2_clk,
@@ -230,6 +247,28 @@ static void at91sam9261_reset(void)
 
 
 /* --------------------------------------------------------------------
+ *  Timer/Counter library initialization
+ * -------------------------------------------------------------------- */
+#ifdef CONFIG_ATMEL_TCLIB
+
+#include "tclib.h"
+
+static struct atmel_tcblock at91sam9261_tcblocks[] = {
+	[0] = {
+		.physaddr	= AT91SAM9261_BASE_TCB0,
+		.irq		= { AT91SAM9261_ID_TC0, AT91SAM9261_ID_TC1, AT91SAM9261_ID_TC2 },
+		.clk		= { &tc0_clk, &tc1_clk, &tc2_clk },
+	}
+};
+
+#define at91sam9261_tc_init()	atmel_tc_init(at91sam9261_tcblocks, ARRAY_SIZE(at91sam9261_tcblocks))
+
+#else
+#define at91sam9261_tc_init()	do {} while(0)
+#endif
+
+
+/* --------------------------------------------------------------------
  *  AT91SAM9261 processor initialization
  * -------------------------------------------------------------------- */
 
@@ -250,6 +289,9 @@ void __init at91sam9261_initialize(unsig
 
 	/* Register GPIO subsystem */
 	at91_gpio_init(at91sam9261_gpio, 3);
+
+	/* Initialize the Timer/Counter blocks */
+	at91sam9261_tc_init();
 }
 
 /* --------------------------------------------------------------------
@@ -262,25 +304,25 @@ void __init at91sam9261_initialize(unsig
 static unsigned int at91sam9261_default_irq_priority[NR_AIC_IRQS] __initdata = {
 	7,	/* Advanced Interrupt Controller */
 	7,	/* System Peripherals */
-	0,	/* Parallel IO Controller A */
-	0,	/* Parallel IO Controller B */
-	0,	/* Parallel IO Controller C */
-	0,
-	6,	/* USART 0 */
-	6,	/* USART 1 */
-	6,	/* USART 2 */
+	1,	/* Parallel IO Controller A */
+	1,	/* Parallel IO Controller B */
+	1,	/* Parallel IO Controller C */
+	0,
+	5,	/* USART 0 */
+	5,	/* USART 1 */
+	5,	/* USART 2 */
 	0,	/* Multimedia Card Interface */
-	4,	/* USB Device Port */
-	0,	/* Two-Wire Interface */
-	6,	/* Serial Peripheral Interface 0 */
-	6,	/* Serial Peripheral Interface 1 */
-	5,	/* Serial Synchronous Controller 0 */
-	5,	/* Serial Synchronous Controller 1 */
-	5,	/* Serial Synchronous Controller 2 */
+	2,	/* USB Device Port */
+	6,	/* Two-Wire Interface */
+	5,	/* Serial Peripheral Interface 0 */
+	5,	/* Serial Peripheral Interface 1 */
+	4,	/* Serial Synchronous Controller 0 */
+	4,	/* Serial Synchronous Controller 1 */
+	4,	/* Serial Synchronous Controller 2 */
 	0,	/* Timer Counter 0 */
 	0,	/* Timer Counter 1 */
 	0,	/* Timer Counter 2 */
-	3,	/* USB Host port */
+	2,	/* USB Host port */
 	3,	/* LCD Controller */
 	0,
 	0,
Index: linux-2.6.21.7/arch/arm/mach-at91/at91sam9261_devices.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/at91sam9261_devices.c
+++ linux-2.6.21.7/arch/arm/mach-at91/at91sam9261_devices.c
@@ -14,6 +14,9 @@
 #include <asm/mach/map.h>
 
 #include <linux/platform_device.h>
+#include <linux/fb.h>
+
+#include <video/atmel_lcdc.h>
 
 #include <asm/arch/board.h>
 #include <asm/arch/gpio.h>
@@ -430,9 +433,9 @@ void __init at91_add_device_spi(struct s
  *  LCD Controller
  * -------------------------------------------------------------------- */
 
-#if defined(CONFIG_FB_AT91) || defined(CONFIG_FB_AT91_MODULE)
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
 static u64 lcdc_dmamask = 0xffffffffUL;
-static struct at91fb_info lcdc_data;
+static struct atmel_lcdfb_info lcdc_data;
 
 static struct resource lcdc_resources[] = {
 	[0] = {
@@ -455,7 +458,7 @@ static struct resource lcdc_resources[] 
 };
 
 static struct platform_device at91_lcdc_device = {
-	.name		= "at91-fb",
+	.name		= "atmel_lcdfb",
 	.id		= 0,
 	.dev		= {
 				.dma_mask		= &lcdc_dmamask,
@@ -466,7 +469,7 @@ static struct platform_device at91_lcdc_
 	.num_resources	= ARRAY_SIZE(lcdc_resources),
 };
 
-void __init at91_add_device_lcdc(struct at91fb_info *data)
+void __init at91_add_device_lcdc(struct atmel_lcdfb_info *data)
 {
 	if (!data) {
 		return;
@@ -499,7 +502,7 @@ void __init at91_add_device_lcdc(struct 
 	platform_device_register(&at91_lcdc_device);
 }
 #else
-void __init at91_add_device_lcdc(struct at91fb_info *data) {}
+void __init at91_add_device_lcdc(struct atmel_lcdfb_info *data) {}
 #endif
 
 
@@ -525,6 +528,32 @@ void __init at91_init_leds(u8 cpu_led, u
 #endif
 
 
+#if defined(CONFIG_NEW_LEDS)
+
+static struct platform_device at91_leds = {
+	.name		= "at91_leds",
+	.id		= -1,
+};
+
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr)
+{
+	if (!nr)
+		return;
+
+	at91_leds.dev.platform_data = leds;
+
+	for ( ; nr; nr--, leds++) {
+		leds->index = nr;	/* first record stores number of leds */
+		at91_set_gpio_output(leds->gpio, (leds->flags & 1) == 0);
+	}
+
+	platform_device_register(&at91_leds);
+}
+#else
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr) {}
+#endif
+
+
 /* --------------------------------------------------------------------
  *  UART
  * -------------------------------------------------------------------- */
Index: linux-2.6.21.7/arch/arm/mach-at91/at91sam9263.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/at91sam9263.c
+++ linux-2.6.21.7/arch/arm/mach-at91/at91sam9263.c
@@ -87,6 +87,11 @@ static struct clk mmc1_clk = {
 	.pmc_mask	= 1 << AT91SAM9263_ID_MCI1,
 	.type		= CLK_TYPE_PERIPHERAL,
 };
+static struct clk can_clk = {
+	.name		= "can_clk",
+	.pmc_mask	= 1 << AT91SAM9263_ID_CAN,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
 static struct clk twi_clk = {
 	.name		= "twi_clk",
 	.pmc_mask	= 1 << AT91SAM9263_ID_TWI,
@@ -102,16 +107,46 @@ static struct clk spi1_clk = {
 	.pmc_mask	= 1 << AT91SAM9263_ID_SPI1,
 	.type		= CLK_TYPE_PERIPHERAL,
 };
+static struct clk ssc0_clk = {
+	.name		= "ssc0_clk",
+	.pmc_mask	= 1 << AT91SAM9263_ID_SSC0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk ssc1_clk = {
+	.name		= "ssc1_clk",
+	.pmc_mask	= 1 << AT91SAM9263_ID_SSC1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk ac97_clk = {
+	.name		= "ac97_clk",
+	.pmc_mask	= 1 << AT91SAM9263_ID_AC97C,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
 static struct clk tcb_clk = {
 	.name		= "tcb_clk",
 	.pmc_mask	= 1 << AT91SAM9263_ID_TCB,
 	.type		= CLK_TYPE_PERIPHERAL,
 };
+static struct clk pwmc_clk = {
+	.name		= "pwmc_clk",
+	.pmc_mask	= 1 << AT91SAM9263_ID_PWMC,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
 static struct clk macb_clk = {
 	.name		= "macb_clk",
 	.pmc_mask	= 1 << AT91SAM9263_ID_EMAC,
 	.type		= CLK_TYPE_PERIPHERAL,
 };
+static struct clk dma_clk = {
+	.name		= "dma_clk",
+	.pmc_mask	= 1 << AT91SAM9263_ID_DMA,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk twodge_clk = {
+	.name		= "2dge_clk",
+	.pmc_mask	= 1 << AT91SAM9263_ID_2DGE,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
 static struct clk udc_clk = {
 	.name		= "udc_clk",
 	.pmc_mask	= 1 << AT91SAM9263_ID_UDP,
@@ -142,20 +177,21 @@ static struct clk *periph_clocks[] __ini
 	&usart2_clk,
 	&mmc0_clk,
 	&mmc1_clk,
-	// can
+	&can_clk,
 	&twi_clk,
 	&spi0_clk,
 	&spi1_clk,
-	// ssc0 .. ssc1
-	// ac97
+	&ssc0_clk,
+	&ssc1_clk,
+	&ac97_clk,
 	&tcb_clk,
-	// pwmc
+	&pwmc_clk,
 	&macb_clk,
-	// 2dge
+	&twodge_clk,
 	&udc_clk,
 	&isi_clk,
 	&lcdc_clk,
-	// dma
+	&dma_clk,
 	&ohci_clk,
 	// irq0 .. irq1
 };
@@ -237,6 +273,28 @@ static void at91sam9263_reset(void)
 
 
 /* --------------------------------------------------------------------
+ *  Timer/Counter library initialization
+ * -------------------------------------------------------------------- */
+#ifdef CONFIG_ATMEL_TCLIB
+
+#include "tclib.h"
+
+static struct atmel_tcblock at91sam9263_tcblocks[] = {
+	[0] = {
+		.physaddr	= AT91SAM9263_BASE_TCB0,
+		.irq		= { AT91SAM9263_ID_TCB, AT91SAM9263_ID_TCB, AT91SAM9263_ID_TCB },
+		.clk		= { &tcb_clk, &tcb_clk, &tcb_clk },
+	}
+};
+
+#define at91sam9263_tc_init()	atmel_tc_init(at91sam9263_tcblocks, ARRAY_SIZE(at91sam9263_tcblocks))
+
+#else
+#define at91sam9263_tc_init()	do {} while(0)
+#endif
+
+
+/* --------------------------------------------------------------------
  *  AT91SAM9263 processor initialization
  * -------------------------------------------------------------------- */
 
@@ -256,6 +314,9 @@ void __init at91sam9263_initialize(unsig
 
 	/* Register GPIO subsystem */
 	at91_gpio_init(at91sam9263_gpio, 5);
+
+	/* Initialize the Timer/Counter blocks */
+	at91sam9263_tc_init();
 }
 
 /* --------------------------------------------------------------------
@@ -268,34 +329,34 @@ void __init at91sam9263_initialize(unsig
 static unsigned int at91sam9263_default_irq_priority[NR_AIC_IRQS] __initdata = {
 	7,	/* Advanced Interrupt Controller (FIQ) */
 	7,	/* System Peripherals */
-	0,	/* Parallel IO Controller A */
-	0,	/* Parallel IO Controller B */
-	0,	/* Parallel IO Controller C, D and E */
+	1,	/* Parallel IO Controller A */
+	1,	/* Parallel IO Controller B */
+	1,	/* Parallel IO Controller C, D and E */
 	0,
 	0,
-	6,	/* USART 0 */
-	6,	/* USART 1 */
-	6,	/* USART 2 */
+	5,	/* USART 0 */
+	5,	/* USART 1 */
+	5,	/* USART 2 */
 	0,	/* Multimedia Card Interface 0 */
 	0,	/* Multimedia Card Interface 1 */
-	4,	/* CAN */
-	0,	/* Two-Wire Interface */
-	6,	/* Serial Peripheral Interface 0 */
-	6,	/* Serial Peripheral Interface 1 */
-	5,	/* Serial Synchronous Controller 0 */
-	5,	/* Serial Synchronous Controller 1 */
-	6,	/* AC97 Controller */
+	3,	/* CAN */
+	6,	/* Two-Wire Interface */
+	5,	/* Serial Peripheral Interface 0 */
+	5,	/* Serial Peripheral Interface 1 */
+	4,	/* Serial Synchronous Controller 0 */
+	4,	/* Serial Synchronous Controller 1 */
+	5,	/* AC97 Controller */
 	0,	/* Timer Counter 0, 1 and 2 */
 	0,	/* Pulse Width Modulation Controller */
 	3,	/* Ethernet */
 	0,
 	0,	/* 2D Graphic Engine */
-	3,	/* USB Device Port */
+	2,	/* USB Device Port */
 	0,	/* Image Sensor Interface */
 	3,	/* LDC Controller */
 	0,	/* DMA Controller */
 	0,
-	3,	/* USB Host port */
+	2,	/* USB Host port */
 	0,	/* Advanced Interrupt Controller (IRQ0) */
 	0,	/* Advanced Interrupt Controller (IRQ1) */
 };
Index: linux-2.6.21.7/arch/arm/mach-at91/at91sam9263_devices.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/at91sam9263_devices.c
+++ linux-2.6.21.7/arch/arm/mach-at91/at91sam9263_devices.c
@@ -13,6 +13,9 @@
 #include <asm/mach/map.h>
 
 #include <linux/platform_device.h>
+#include <linux/fb.h>
+
+#include <video/atmel_lcdc.h>
 
 #include <asm/arch/board.h>
 #include <asm/arch/gpio.h>
@@ -573,6 +576,180 @@ void __init at91_add_device_spi(struct s
 
 
 /* --------------------------------------------------------------------
+ *  AC97
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_SND_AT91_AC97) || defined(CONFIG_SND_AT91_AC97_MODULE)
+static u64 ac97_dmamask = 0xffffffffUL;
+static struct atmel_ac97_data ac97_data;
+
+static struct resource ac97_resources[] = {
+	[0] = {
+		.start	= AT91SAM9263_BASE_AC97C,
+		.end	= AT91SAM9263_BASE_AC97C + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9263_ID_AC97C,
+		.end	= AT91SAM9263_ID_AC97C,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9263_ac97_device = {
+	.name		= "ac97c",
+	.id		= 1,
+	.dev		= {
+				.dma_mask		= &ac97_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+				.platform_data		= &ac97_data,
+	},
+	.resource	= ac97_resources,
+	.num_resources	= ARRAY_SIZE(ac97_resources),
+};
+
+void __init at91_add_device_ac97(struct atmel_ac97_data *data)
+{
+	if (!data)
+		return;
+
+	at91_set_A_periph(AT91_PIN_PB0, 0);	/* AC97FS */
+	at91_set_A_periph(AT91_PIN_PB1, 0);	/* AC97CK */
+	at91_set_A_periph(AT91_PIN_PB2, 0);	/* AC97TX */
+	at91_set_A_periph(AT91_PIN_PB3, 0);	/* AC97RX */
+
+	/* reset */
+	if (data->reset_pin)
+		at91_set_gpio_output(data->reset_pin, 0);
+
+	ac97_data = *ek_data;
+	platform_device_register(&at91sam9263_ac97_device);
+}
+#else
+void __init at91_add_device_ac97(struct atmel_ac97_data *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  Image Sensor Interface
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_VIDEO_AT91_ISI) || defined(CONFIG_VIDEO_AT91_ISI_MODULE)
+
+struct resource isi_resources[] = {
+	[0] = {
+		.start	= AT91SAM9263_BASE_ISI,
+		.end	= AT91SAM9263_BASE_ISI + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9263_ID_ISI,
+		.end	= AT91SAM9263_ID_ISI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9263_isi_device = {
+	.name		= "at91_isi",
+	.id		= -1,
+	.resource	= isi_resources,
+	.num_resources	= ARRAY_SIZE(isi_resources),
+};
+
+void __init at91_add_device_isi(void)
+{
+	at91_set_A_periph(AT91_PIN_PE0, 0);	/* ISI_D0 */
+	at91_set_A_periph(AT91_PIN_PE1, 0);	/* ISI_D1 */
+	at91_set_A_periph(AT91_PIN_PE2, 0);	/* ISI_D2 */
+	at91_set_A_periph(AT91_PIN_PE3, 0);	/* ISI_D3 */
+	at91_set_A_periph(AT91_PIN_PE4, 0);	/* ISI_D4 */
+	at91_set_A_periph(AT91_PIN_PE5, 0);	/* ISI_D5 */
+	at91_set_A_periph(AT91_PIN_PE6, 0);	/* ISI_D6 */
+	at91_set_A_periph(AT91_PIN_PE7, 0);	/* ISI_D7 */
+	at91_set_A_periph(AT91_PIN_PE8, 0);	/* ISI_PCK */
+	at91_set_A_periph(AT91_PIN_PE9, 0);	/* ISI_HSYNC */
+	at91_set_A_periph(AT91_PIN_PE10, 0);	/* ISI_VSYNC */
+	at91_set_B_periph(AT91_PIN_PE11, 0);	/* ISI_MCK (PCK3) */
+	at91_set_B_periph(AT91_PIN_PE12, 0);	/* ISI_PD8 */
+	at91_set_B_periph(AT91_PIN_PE13, 0);	/* ISI_PD9 */
+	at91_set_B_periph(AT91_PIN_PE14, 0);	/* ISI_PD10 */
+	at91_set_B_periph(AT91_PIN_PE15, 0);	/* ISI_PD11 */
+}
+#else
+void __init at91_add_device_isi(void) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  LCD Controller
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
+static u64 lcdc_dmamask = 0xffffffffUL;
+static struct atmel_lcdfb_info lcdc_data;
+
+static struct resource lcdc_resources[] = {
+	[0] = {
+		.start	= AT91SAM9263_LCDC_BASE,
+		.end	= AT91SAM9263_LCDC_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9263_ID_LCDC,
+		.end	= AT91SAM9263_ID_LCDC,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91_lcdc_device = {
+	.name		= "atmel_lcdfb",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &lcdc_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+				.platform_data		= &lcdc_data,
+	},
+	.resource	= lcdc_resources,
+	.num_resources	= ARRAY_SIZE(lcdc_resources),
+};
+
+void __init at91_add_device_lcdc(struct atmel_lcdfb_info *data)
+{
+	if (!data)
+		return;
+
+	at91_set_A_periph(AT91_PIN_PC1, 0);	/* LCDHSYNC */
+	at91_set_A_periph(AT91_PIN_PC2, 0);	/* LCDDOTCK */
+	at91_set_A_periph(AT91_PIN_PC3, 0);	/* LCDDEN */
+	at91_set_B_periph(AT91_PIN_PB9, 0);	/* LCDCC */
+	at91_set_A_periph(AT91_PIN_PC6, 0);	/* LCDD2 */
+	at91_set_A_periph(AT91_PIN_PC7, 0);	/* LCDD3 */
+	at91_set_A_periph(AT91_PIN_PC8, 0);	/* LCDD4 */
+	at91_set_A_periph(AT91_PIN_PC9, 0);	/* LCDD5 */
+	at91_set_A_periph(AT91_PIN_PC10, 0);	/* LCDD6 */
+	at91_set_A_periph(AT91_PIN_PC11, 0);	/* LCDD7 */
+	at91_set_A_periph(AT91_PIN_PC14, 0);	/* LCDD10 */
+	at91_set_A_periph(AT91_PIN_PC15, 0);	/* LCDD11 */
+	at91_set_A_periph(AT91_PIN_PC16, 0);	/* LCDD12 */
+	at91_set_B_periph(AT91_PIN_PC12, 0);	/* LCDD13 */
+	at91_set_A_periph(AT91_PIN_PC18, 0);	/* LCDD14 */
+	at91_set_A_periph(AT91_PIN_PC19, 0);	/* LCDD15 */
+	at91_set_A_periph(AT91_PIN_PC22, 0);	/* LCDD18 */
+	at91_set_A_periph(AT91_PIN_PC23, 0);	/* LCDD19 */
+	at91_set_A_periph(AT91_PIN_PC24, 0);	/* LCDD20 */
+	at91_set_B_periph(AT91_PIN_PC17, 0);	/* LCDD21 */
+	at91_set_A_periph(AT91_PIN_PC26, 0);	/* LCDD22 */
+	at91_set_A_periph(AT91_PIN_PC27, 0);	/* LCDD23 */
+
+	lcdc_data = *data;
+	platform_device_register(&at91_lcdc_device);
+}
+#else
+void __init at91_add_device_lcdc(struct atmel_lcdfb_info *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
  *  LEDs
  * -------------------------------------------------------------------- */
 
@@ -594,6 +771,32 @@ void __init at91_init_leds(u8 cpu_led, u
 #endif
 
 
+#if defined(CONFIG_NEW_LEDS)
+
+static struct platform_device at91_leds = {
+	.name		= "at91_leds",
+	.id		= -1,
+};
+
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr)
+{
+	if (!nr)
+		return;
+
+	at91_leds.dev.platform_data = leds;
+
+	for ( ; nr; nr--, leds++) {
+		leds->index = nr;	/* first record stores number of leds */
+		at91_set_gpio_output(leds->gpio, (leds->flags & 1) == 0);
+	}
+
+	platform_device_register(&at91_leds);
+}
+#else
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr) {}
+#endif
+
+
 /* --------------------------------------------------------------------
  *  UART
  * -------------------------------------------------------------------- */
Index: linux-2.6.21.7/arch/arm/mach-at91/at91sam9rl.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/arch/arm/mach-at91/at91sam9rl.c
@@ -0,0 +1,366 @@
+/*
+ * arch/arm/mach-at91/at91sam9rl.c
+ *
+ *  Copyright (C) 2005 SAN People
+ *  Copyright (C) 2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/module.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/at91sam9rl.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/at91_rstc.h>
+
+#include "generic.h"
+#include "clock.h"
+
+static struct map_desc at91sam9rl_io_desc[] __initdata = {
+	{
+		.virtual	= AT91_VA_BASE_SYS,
+		.pfn		= __phys_to_pfn(AT91_BASE_SYS),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	},
+};
+
+static struct map_desc at91sam9rl_sram_desc[] __initdata = {
+	{
+		.pfn		= __phys_to_pfn(AT91SAM9RL_SRAM_BASE),
+		.type		= MT_DEVICE,
+	}
+};
+
+/* --------------------------------------------------------------------
+ *  Clocks
+ * -------------------------------------------------------------------- */
+
+/*
+ * The peripheral clocks.
+ */
+static struct clk pioA_clk = {
+	.name		= "pioA_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_PIOA,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk pioB_clk = {
+	.name		= "pioB_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_PIOB,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk pioC_clk = {
+	.name		= "pioC_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_PIOC,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk pioD_clk = {
+	.name		= "pioD_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_PIOD,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk usart0_clk = {
+	.name		= "usart0_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_US0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk usart1_clk = {
+	.name		= "usart1_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_US1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk usart2_clk = {
+	.name		= "usart2_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_US2,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk usart3_clk = {
+	.name		= "usart3_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_US3,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk mmc_clk = {
+	.name		= "mci_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_MCI,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk twi0_clk = {
+	.name		= "twi0_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_TWI0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk twi1_clk = {
+	.name		= "twi1_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_TWI1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk spi_clk = {
+	.name		= "spi_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_SPI,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk ssc0_clk = {
+	.name		= "ssc0_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_SSC0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk ssc1_clk = {
+	.name		= "ssc1_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_SSC1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk tc0_clk = {
+	.name		= "tc0_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_TC0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk tc1_clk = {
+	.name		= "tc1_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_TC1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk tc2_clk = {
+	.name		= "tc2_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_TC2,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk pwmc_clk = {
+	.name		= "pwmc_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_PWMC,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk tsc_clk = {
+	.name		= "tsc_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_TSC,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk dma_clk = {
+	.name		= "dma_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_DMA,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk udphs_clk = {
+	.name		= "udphs_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_UDPHS,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk lcdc_clk = {
+	.name		= "lcdc_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_LCDC,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk ac97_clk = {
+	.name		= "ac97_clk",
+	.pmc_mask	= 1 << AT91SAM9RL_ID_AC97C,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+
+static struct clk *periph_clocks[] __initdata = {
+	&pioA_clk,
+	&pioB_clk,
+	&pioC_clk,
+	&pioD_clk,
+	&usart0_clk,
+	&usart1_clk,
+	&usart2_clk,
+	&usart3_clk,
+	&mmc_clk,
+	&twi0_clk,
+	&twi1_clk,
+	&spi_clk,
+	&ssc0_clk,
+	&ssc1_clk,
+	&tc0_clk,
+	&tc1_clk,
+	&tc2_clk,
+	&pwmc_clk,
+	&tsc_clk,
+	&dma_clk,
+	&udphs_clk,
+	&lcdc_clk,
+	&ac97_clk,
+	// irq0
+};
+
+/*
+ * The two programmable clocks.
+ * You must configure pin multiplexing to bring these signals out.
+ */
+static struct clk pck0 = {
+	.name		= "pck0",
+	.pmc_mask	= AT91_PMC_PCK0,
+	.type		= CLK_TYPE_PROGRAMMABLE,
+	.id		= 0,
+};
+static struct clk pck1 = {
+	.name		= "pck1",
+	.pmc_mask	= AT91_PMC_PCK1,
+	.type		= CLK_TYPE_PROGRAMMABLE,
+	.id		= 1,
+};
+
+static void __init at91sam9rl_register_clocks(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(periph_clocks); i++)
+		clk_register(periph_clocks[i]);
+
+	clk_register(&pck0);
+	clk_register(&pck1);
+}
+
+/* --------------------------------------------------------------------
+ *  GPIO
+ * -------------------------------------------------------------------- */
+
+static struct at91_gpio_bank at91sam9rl_gpio[] = {
+	{
+		.id		= AT91SAM9RL_ID_PIOA,
+		.offset		= AT91_PIOA,
+		.clock		= &pioA_clk,
+	}, {
+		.id		= AT91SAM9RL_ID_PIOB,
+		.offset		= AT91_PIOB,
+		.clock		= &pioB_clk,
+	}, {
+		.id		= AT91SAM9RL_ID_PIOC,
+		.offset		= AT91_PIOC,
+		.clock		= &pioC_clk,
+	}, {
+		.id		= AT91SAM9RL_ID_PIOD,
+		.offset		= AT91_PIOD,
+		.clock		= &pioD_clk,
+	}
+};
+
+static void at91sam9rl_reset(void)
+{
+	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY | AT91_RSTC_PROCRST | AT91_RSTC_PERRST);
+}
+
+
+/* --------------------------------------------------------------------
+ *  Timer/Counter library initialization
+ * -------------------------------------------------------------------- */
+#ifdef CONFIG_ATMEL_TCLIB
+
+#include "tclib.h"
+
+static struct atmel_tcblock at91sam9rl_tcblocks[] = {
+	[0] = {
+		.physaddr	= AT91SAM9RL_BASE_TCB0,
+		.irq		= { AT91SAM9RL_ID_TC0, AT91SAM9RL_ID_TC1, AT91SAM9RL_ID_TC2 },
+		.clk		= { &tc0_clk, &tc1_clk, &tc2_clk },
+	}
+};
+
+#define at91sam9rl_tc_init()	atmel_tc_init(at91sam9rl_tcblocks, ARRAY_SIZE(at91sam9rl_tcblocks))
+
+#else
+#define at91sam9rl_tc_init()	do {} while(0)
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  AT91SAM9RL processor initialization
+ * -------------------------------------------------------------------- */
+
+void __init at91sam9rl_initialize(unsigned long main_clock)
+{
+	unsigned long cidr, sram_size;
+
+	/* Map peripherals */
+	iotable_init(at91sam9rl_io_desc, ARRAY_SIZE(at91sam9rl_io_desc));
+
+	cidr = at91_sys_read(AT91_DBGU_CIDR);
+
+	switch (cidr & AT91_CIDR_SRAMSIZ) {
+		case AT91_CIDR_SRAMSIZ_32K:
+			sram_size = 2 * SZ_16K;
+			break;
+		case AT91_CIDR_SRAMSIZ_16K:
+		default:
+			sram_size = SZ_16K;
+	}
+
+	at91sam9rl_sram_desc->virtual = AT91_IO_VIRT_BASE - sram_size;
+	at91sam9rl_sram_desc->length = sram_size;
+
+	/* Map SRAM */
+	iotable_init(at91sam9rl_sram_desc, ARRAY_SIZE(at91sam9rl_sram_desc));
+
+	at91_arch_reset = at91sam9rl_reset;
+	at91_extern_irq = (1 << AT91SAM9RL_ID_IRQ0);
+
+	/* Init clock subsystem */
+	at91_clock_init(main_clock);
+
+	/* Register the processor-specific clocks */
+	at91sam9rl_register_clocks();
+
+	/* Register GPIO subsystem */
+	at91_gpio_init(at91sam9rl_gpio, 4);
+	
+	/* Initialize the Timer/Counter blocks */
+	at91sam9rl_tc_init();
+}
+
+/* --------------------------------------------------------------------
+ *  Interrupt initialization
+ * -------------------------------------------------------------------- */
+
+/*
+ * The default interrupt priority levels (0 = lowest, 7 = highest).
+ */
+static unsigned int at91sam9rl_default_irq_priority[NR_AIC_IRQS] __initdata = {
+	7,	/* Advanced Interrupt Controller */
+	7,	/* System Peripherals */
+	1,	/* Parallel IO Controller A */
+	1,	/* Parallel IO Controller B */
+	1,	/* Parallel IO Controller C */
+	1,	/* Parallel IO Controller D */
+	5,	/* USART 0 */
+	5,	/* USART 1 */
+	5,	/* USART 2 */
+	5,	/* USART 3 */
+	0,	/* Multimedia Card Interface */
+	6,	/* Two-Wire Interface 0 */
+	6,	/* Two-Wire Interface 1 */
+	5,	/* Serial Peripheral Interface */
+	4,	/* Serial Synchronous Controller 0 */
+	4,	/* Serial Synchronous Controller 1 */
+	0,	/* Timer Counter 0 */
+	0,	/* Timer Counter 1 */
+	0,	/* Timer Counter 2 */
+	0,
+	0,	/* Touch Screen Controller */
+	0,	/* DMA Controller */
+	2,	/* USB Device High speed port */
+	2,	/* LCD Controller */
+	6,	/* AC97 Controller */
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,	/* Advanced Interrupt Controller */
+};
+
+void __init at91sam9rl_init_interrupts(unsigned int priority[NR_AIC_IRQS])
+{
+	if (!priority)
+		priority = at91sam9rl_default_irq_priority;
+
+	/* Initialize the AIC interrupt controller */
+	at91_aic_init(priority);
+
+	/* Enable GPIO interrupts */
+	at91_gpio_irq_setup();
+}
Index: linux-2.6.21.7/arch/arm/mach-at91/at91sam9rl_devices.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/arch/arm/mach-at91/at91sam9rl_devices.c
@@ -0,0 +1,660 @@
+/*
+ *  Copyright (C) 2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <linux/platform_device.h>
+#include <linux/fb.h>
+
+#include <video/atmel_lcdc.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/at91sam9rl.h>
+#include <asm/arch/at91sam9rl_matrix.h>
+#include <asm/arch/at91sam926x_mc.h>
+
+#include "generic.h"
+
+#define SZ_512	0x00000200
+#define SZ_256	0x00000100
+#define SZ_16	0x00000010
+
+
+/* --------------------------------------------------------------------
+ *  MMC / SD
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_MMC_AT91) || defined(CONFIG_MMC_AT91_MODULE)
+static u64 mmc_dmamask = 0xffffffffUL;
+static struct at91_mmc_data mmc_data;
+
+static struct resource mmc_resources[] = {
+	[0] = {
+		.start	= AT91SAM9RL_BASE_MCI,
+		.end	= AT91SAM9RL_BASE_MCI + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9RL_ID_MCI,
+		.end	= AT91SAM9RL_ID_MCI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9rl_mmc_device = {
+	.name		= "at91_mci",
+	.id		= -1,
+	.dev		= {
+				.dma_mask		= &mmc_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+				.platform_data		= &mmc_data,
+	},
+	.resource	= mmc_resources,
+	.num_resources	= ARRAY_SIZE(mmc_resources),
+};
+
+void __init at91_add_device_mmc(short mmc_id, struct at91_mmc_data *data)
+{
+	if (!data)
+		return;
+
+	/* input/irq */
+	if (data->det_pin) {
+		at91_set_gpio_input(data->det_pin, 1);
+		at91_set_deglitch(data->det_pin, 1);
+	}
+	if (data->wp_pin)
+		at91_set_gpio_input(data->wp_pin, 1);
+	if (data->vcc_pin)
+		at91_set_gpio_output(data->vcc_pin, 0);
+
+	/* CLK */
+	at91_set_A_periph(AT91_PIN_PA2, 0);
+
+	/* CMD */
+	at91_set_A_periph(AT91_PIN_PA1, 1);
+
+	/* DAT0, maybe DAT1..DAT3 */
+	at91_set_A_periph(AT91_PIN_PA0, 1);
+	if (data->wire4) {
+		at91_set_A_periph(AT91_PIN_PA3, 1);
+		at91_set_A_periph(AT91_PIN_PA4, 1);
+		at91_set_A_periph(AT91_PIN_PA5, 1);
+	}
+
+	mmc_data = *data;
+	platform_device_register(&at91sam9rl_mmc_device);
+}
+#else
+void __init at91_add_device_mmc(short mmc_id, struct at91_mmc_data *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  NAND / SmartMedia
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_MTD_NAND_AT91) || defined(CONFIG_MTD_NAND_AT91_MODULE)
+static struct at91_nand_data nand_data;
+
+#define NAND_BASE	AT91_CHIPSELECT_3
+
+static struct resource nand_resources[] = {
+	{
+		.start	= NAND_BASE,
+		.end	= NAND_BASE + SZ_256M - 1,
+		.flags	= IORESOURCE_MEM,
+	}
+};
+
+static struct platform_device at91_nand_device = {
+	.name		= "at91_nand",
+	.id		= -1,
+	.dev		= {
+				.platform_data	= &nand_data,
+	},
+	.resource	= nand_resources,
+	.num_resources	= ARRAY_SIZE(nand_resources),
+};
+
+void __init at91_add_device_nand(struct at91_nand_data *data)
+{
+	unsigned long csa;
+
+	if (!data)
+		return;
+
+	csa = at91_sys_read(AT91_MATRIX_EBICSA);
+	at91_sys_write(AT91_MATRIX_EBICSA, csa | AT91_MATRIX_CS3A_SMC_SMARTMEDIA);
+
+	/* set the bus interface characteristics */
+	at91_sys_write(AT91_SMC_SETUP(3), AT91_SMC_NWESETUP_(0) | AT91_SMC_NCS_WRSETUP_(0)
+			| AT91_SMC_NRDSETUP_(0) | AT91_SMC_NCS_RDSETUP_(0));
+
+	at91_sys_write(AT91_SMC_PULSE(3), AT91_SMC_NWEPULSE_(2) | AT91_SMC_NCS_WRPULSE_(5)
+			| AT91_SMC_NRDPULSE_(2) | AT91_SMC_NCS_RDPULSE_(5));
+
+	at91_sys_write(AT91_SMC_CYCLE(3), AT91_SMC_NWECYCLE_(7) | AT91_SMC_NRDCYCLE_(7));
+
+	at91_sys_write(AT91_SMC_MODE(3), AT91_SMC_DBW_8 | AT91_SMC_READMODE | AT91_SMC_WRITEMODE | AT91_SMC_EXNWMODE_DISABLE | AT91_SMC_TDF_(1));
+
+	/* enable pin */
+	if (data->enable_pin)
+		at91_set_gpio_output(data->enable_pin, 1);
+
+	/* ready/busy pin */
+	if (data->rdy_pin)
+		at91_set_gpio_input(data->rdy_pin, 1);
+
+	/* card detect pin */
+	if (data->det_pin)
+		at91_set_gpio_input(data->det_pin, 1);
+
+	at91_set_A_periph(AT91_PIN_PB4, 0);		/* NANDOE */
+	at91_set_A_periph(AT91_PIN_PB5, 0);		/* NANDWE */
+
+	nand_data = *data;
+	platform_device_register(&at91_nand_device);
+}
+
+#else
+void __init at91_add_device_nand(struct at91_nand_data *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  TWI (i2c)
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_I2C_AT91) || defined(CONFIG_I2C_AT91_MODULE)
+
+static struct resource twi_resources[] = {
+	[0] = {
+		.start	= AT91SAM9RL_BASE_TWI0,
+		.end	= AT91SAM9RL_BASE_TWI0 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9RL_ID_TWI0,
+		.end	= AT91SAM9RL_ID_TWI0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9rl_twi_device = {
+	.name		= "at91_i2c",
+	.id		= -1,
+	.resource	= twi_resources,
+	.num_resources	= ARRAY_SIZE(twi_resources),
+};
+
+void __init at91_add_device_i2c(void)
+{
+	/* pins used for TWI interface */
+	at91_set_A_periph(AT91_PIN_PA23, 0);		/* TWD */
+	at91_set_multi_drive(AT91_PIN_PA23, 1);
+
+	at91_set_A_periph(AT91_PIN_PA24, 0);		/* TWCK */
+	at91_set_multi_drive(AT91_PIN_PA24, 1);
+
+	platform_device_register(&at91sam9rl_twi_device);
+}
+#else
+void __init at91_add_device_i2c(void) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  SPI
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_SPI_ATMEL) || defined(CONFIG_SPI_ATMEL_MODULE)
+static u64 spi_dmamask = 0xffffffffUL;
+
+static struct resource spi_resources[] = {
+	[0] = {
+		.start	= AT91SAM9RL_BASE_SPI,
+		.end	= AT91SAM9RL_BASE_SPI + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9RL_ID_SPI,
+		.end	= AT91SAM9RL_ID_SPI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9rl_spi_device = {
+	.name		= "atmel_spi",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &spi_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+	},
+	.resource	= spi_resources,
+	.num_resources	= ARRAY_SIZE(spi_resources),
+};
+
+static const unsigned spi_standard_cs[4] = { AT91_PIN_PA28, AT91_PIN_PB7, AT91_PIN_PD8, AT91_PIN_PD9 };
+
+
+void __init at91_add_device_spi(struct spi_board_info *devices, int nr_devices)
+{
+	int i;
+	unsigned long cs_pin;
+
+	at91_set_A_periph(AT91_PIN_PA25, 0);	/* MISO */
+	at91_set_A_periph(AT91_PIN_PA26, 0);	/* MOSI */
+	at91_set_A_periph(AT91_PIN_PA27, 0);	/* SPCK */
+
+	/* Enable SPI chip-selects */
+	for (i = 0; i < nr_devices; i++) {
+		if (devices[i].controller_data)
+			cs_pin = (unsigned long) devices[i].controller_data;
+		else
+			cs_pin = spi_standard_cs[devices[i].chip_select];
+
+		/* enable chip-select pin */
+		at91_set_gpio_output(cs_pin, 1);
+
+		/* pass chip-select pin to driver */
+		devices[i].controller_data = (void *) cs_pin;
+	}
+
+	spi_register_board_info(devices, nr_devices);
+	platform_device_register(&at91sam9rl_spi_device);
+}
+#else
+void __init at91_add_device_spi(struct spi_board_info *devices, int nr_devices) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  LCD Controller
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
+static u64 lcdc_dmamask = 0xffffffffUL;
+static struct atmel_lcdfb_info lcdc_data;
+
+static struct resource lcdc_resources[] = {
+	[0] = {
+		.start	= AT91SAM9RL_LCDC_BASE,
+		.end	= AT91SAM9RL_LCDC_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9RL_ID_LCDC,
+		.end	= AT91SAM9RL_ID_LCDC,
+		.flags	= IORESOURCE_IRQ,
+	},
+#if defined(CONFIG_FB_INTSRAM)
+	[2] = {
+		.start	= AT91SAM9RL_SRAM_BASE,
+		.end	= AT91SAM9RL_SRAM_BASE + AT91SAM9RL_SRAM_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+#endif
+};
+
+static struct platform_device at91_lcdc_device = {
+	.name		= "atmel_lcdfb",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &lcdc_dmamask,
+				.coherent_dma_mask	= 0xffffffff,
+				.platform_data		= &lcdc_data,
+	},
+	.resource	= lcdc_resources,
+	.num_resources	= ARRAY_SIZE(lcdc_resources),
+};
+
+void __init at91_add_device_lcdc(struct atmel_lcdfb_info *data)
+{
+	if (!data) {
+		return;
+	}
+
+#warning "Check this"
+	at91_set_B_periph(AT91_PIN_PC5, 0);	/* LCDHSYNC */
+	at91_set_B_periph(AT91_PIN_PC6, 0);	/* LCDDOTCK */
+	at91_set_B_periph(AT91_PIN_PC7, 0);	/* LCDDEN */
+	at91_set_B_periph(AT91_PIN_PC3, 0);	/* LCDCC */
+	at91_set_B_periph(AT91_PIN_PC9, 0);	/* LCDD3 */
+	at91_set_B_periph(AT91_PIN_PC10, 0);	/* LCDD4 */
+	at91_set_B_periph(AT91_PIN_PC11, 0);	/* LCDD5 */
+	at91_set_B_periph(AT91_PIN_PC12, 0);	/* LCDD6 */
+	at91_set_B_periph(AT91_PIN_PC13, 0);	/* LCDD7 */
+	at91_set_B_periph(AT91_PIN_PC15, 0);	/* LCDD11 */
+	at91_set_B_periph(AT91_PIN_PC16, 0);	/* LCDD12 */
+	at91_set_B_periph(AT91_PIN_PC17, 0);	/* LCDD13 */
+	at91_set_B_periph(AT91_PIN_PC18, 0);	/* LCDD14 */
+	at91_set_B_periph(AT91_PIN_PC19, 0);	/* LCDD15 */
+	at91_set_B_periph(AT91_PIN_PC20, 0);	/* LCDD18 */
+	at91_set_B_periph(AT91_PIN_PC21, 0);	/* LCDD19 */
+	at91_set_B_periph(AT91_PIN_PC22, 0);	/* LCDD20 */
+	at91_set_B_periph(AT91_PIN_PC23, 0);	/* LCDD21 */
+	at91_set_B_periph(AT91_PIN_PC24, 0);	/* LCDD22 */
+	at91_set_B_periph(AT91_PIN_PC25, 0);	/* LCDD23 */
+
+	lcdc_data = *data;
+	platform_device_register(&at91_lcdc_device);
+}
+#else
+void __init at91_add_device_lcdc(struct atmel_lcdfb_info *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  LEDs
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_LEDS)
+u8 at91_leds_cpu;
+u8 at91_leds_timer;
+
+void __init at91_init_leds(u8 cpu_led, u8 timer_led)
+{
+	/* Enable GPIO to access the LEDs */
+	at91_set_gpio_output(cpu_led, 1);
+	at91_set_gpio_output(timer_led, 1);
+
+	at91_leds_cpu	= cpu_led;
+	at91_leds_timer	= timer_led;
+}
+#else
+void __init at91_init_leds(u8 cpu_led, u8 timer_led) {}
+#endif
+
+
+#if defined(CONFIG_NEW_LEDS)
+
+static struct platform_device at91_leds = {
+	.name		= "at91_leds",
+	.id		= -1,
+};
+
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr)
+{
+	if (!nr)
+		return;
+
+	at91_leds.dev.platform_data = leds;
+
+	for ( ; nr; nr--, leds++) {
+		leds->index = nr;	/* first record stores number of leds */
+		at91_set_gpio_output(leds->gpio, (leds->flags & 1) == 0);
+	}
+
+	platform_device_register(&at91_leds);
+}
+#else
+void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  UART
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_SERIAL_ATMEL)
+static struct resource dbgu_resources[] = {
+	[0] = {
+		.start	= AT91_VA_BASE_SYS + AT91_DBGU,
+		.end	= AT91_VA_BASE_SYS + AT91_DBGU + SZ_512 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91_ID_SYS,
+		.end	= AT91_ID_SYS,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct atmel_uart_data dbgu_data = {
+	.use_dma_tx	= 0,
+	.use_dma_rx	= 0,		/* DBGU not capable of receive DMA */
+	.regs		= (void __iomem *)(AT91_VA_BASE_SYS + AT91_DBGU),
+};
+
+static struct platform_device at91sam9rl_dbgu_device = {
+	.name		= "atmel_usart",
+	.id		= 0,
+	.dev		= {
+				.platform_data	= &dbgu_data,
+				.coherent_dma_mask = 0xffffffff,
+	},
+	.resource	= dbgu_resources,
+	.num_resources	= ARRAY_SIZE(dbgu_resources),
+};
+
+static inline void configure_dbgu_pins(void)
+{
+	at91_set_A_periph(AT91_PIN_PA21, 0);		/* DRXD */
+	at91_set_A_periph(AT91_PIN_PA22, 1);		/* DTXD */
+}
+
+static struct resource uart0_resources[] = {
+	[0] = {
+		.start	= AT91SAM9RL_BASE_US0,
+		.end	= AT91SAM9RL_BASE_US0 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9RL_ID_US0,
+		.end	= AT91SAM9RL_ID_US0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct atmel_uart_data uart0_data = {
+	.use_dma_tx	= 1,
+	.use_dma_rx	= 1,
+};
+
+static struct platform_device at91sam9rl_uart0_device = {
+	.name		= "atmel_usart",
+	.id		= 1,
+	.dev		= {
+				.platform_data	= &uart0_data,
+				.coherent_dma_mask = 0xffffffff,
+	},
+	.resource	= uart0_resources,
+	.num_resources	= ARRAY_SIZE(uart0_resources),
+};
+
+static inline void configure_usart0_pins(void)
+{
+	at91_set_A_periph(AT91_PIN_PA6, 1);		/* TXD0 */
+	at91_set_A_periph(AT91_PIN_PA7, 0);		/* RXD0 */
+	at91_set_A_periph(AT91_PIN_PA9, 0);		/* RTS0 */
+	at91_set_A_periph(AT91_PIN_PA10, 0);		/* CTS0 */
+}
+
+static struct resource uart1_resources[] = {
+	[0] = {
+		.start	= AT91SAM9RL_BASE_US1,
+		.end	= AT91SAM9RL_BASE_US1 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9RL_ID_US1,
+		.end	= AT91SAM9RL_ID_US1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct atmel_uart_data uart1_data = {
+	.use_dma_tx	= 1,
+	.use_dma_rx	= 1,
+};
+
+static struct platform_device at91sam9rl_uart1_device = {
+	.name		= "atmel_usart",
+	.id		= 2,
+	.dev		= {
+				.platform_data	= &uart1_data,
+				.coherent_dma_mask = 0xffffffff,
+	},
+	.resource	= uart1_resources,
+	.num_resources	= ARRAY_SIZE(uart1_resources),
+};
+
+static inline void configure_usart1_pins(void)
+{
+	at91_set_A_periph(AT91_PIN_PA11, 1);		/* TXD1 */
+	at91_set_A_periph(AT91_PIN_PA12, 0);		/* RXD1 */
+}
+
+static struct resource uart2_resources[] = {
+	[0] = {
+		.start	= AT91SAM9RL_BASE_US2,
+		.end	= AT91SAM9RL_BASE_US2 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9RL_ID_US2,
+		.end	= AT91SAM9RL_ID_US2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct atmel_uart_data uart2_data = {
+	.use_dma_tx	= 1,
+	.use_dma_rx	= 1,
+};
+
+static struct platform_device at91sam9rl_uart2_device = {
+	.name		= "atmel_usart",
+	.id		= 3,
+	.dev		= {
+				.platform_data	= &uart2_data,
+				.coherent_dma_mask = 0xffffffff,
+	},
+	.resource	= uart2_resources,
+	.num_resources	= ARRAY_SIZE(uart2_resources),
+};
+
+static inline void configure_usart2_pins(void)
+{
+	at91_set_A_periph(AT91_PIN_PA13, 1);		/* TXD2 */
+	at91_set_A_periph(AT91_PIN_PA14, 0);		/* RXD2 */
+}
+
+static struct resource uart3_resources[] = {
+	[0] = {
+		.start	= AT91SAM9RL_BASE_US3,
+		.end	= AT91SAM9RL_BASE_US3 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9RL_ID_US3,
+		.end	= AT91SAM9RL_ID_US3,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct atmel_uart_data uart3_data = {
+	.use_dma_tx	= 1,
+	.use_dma_rx	= 1,
+};
+
+static struct platform_device at91sam9rl_uart3_device = {
+	.name		= "atmel_usart",
+	.id		= 4,
+	.dev		= {
+				.platform_data	= &uart3_data,
+				.coherent_dma_mask = 0xffffffff,
+	},
+	.resource	= uart3_resources,
+	.num_resources	= ARRAY_SIZE(uart3_resources),
+};
+
+static inline void configure_usart3_pins(void)
+{
+	at91_set_A_periph(AT91_PIN_PB0, 1);		/* TXD3 */
+	at91_set_A_periph(AT91_PIN_PB1, 0);		/* RXD3 */
+}
+
+struct platform_device *at91_uarts[ATMEL_MAX_UART];	/* the UARTs to use */
+struct platform_device *atmel_default_console_device;	/* the serial console device */
+
+void __init at91_init_serial(struct at91_uart_config *config)
+{
+	int i;
+
+	/* Fill in list of supported UARTs */
+	for (i = 0; i < config->nr_tty; i++) {
+		switch (config->tty_map[i]) {
+			case 0:
+				configure_usart0_pins();
+				at91_uarts[i] = &at91sam9rl_uart0_device;
+				at91_clock_associate("usart0_clk", &at91sam9rl_uart0_device.dev, "usart");
+				break;
+			case 1:
+				configure_usart1_pins();
+				at91_uarts[i] = &at91sam9rl_uart1_device;
+				at91_clock_associate("usart1_clk", &at91sam9rl_uart1_device.dev, "usart");
+				break;
+			case 2:
+				configure_usart2_pins();
+				at91_uarts[i] = &at91sam9rl_uart2_device;
+				at91_clock_associate("usart2_clk", &at91sam9rl_uart2_device.dev, "usart");
+				break;
+			case 3:
+				configure_usart3_pins();
+				at91_uarts[i] = &at91sam9rl_uart3_device;
+				at91_clock_associate("usart3_clk", &at91sam9rl_uart3_device.dev, "usart");
+				break;
+			case 4:
+				configure_dbgu_pins();
+				at91_uarts[i] = &at91sam9rl_dbgu_device;
+				at91_clock_associate("mck", &at91sam9rl_dbgu_device.dev, "usart");
+				break;
+			default:
+				continue;
+		}
+		at91_uarts[i]->id = i;		/* update ID number to mapped ID */
+	}
+
+	/* Set serial console device */
+	if (config->console_tty < ATMEL_MAX_UART)
+		atmel_default_console_device = at91_uarts[config->console_tty];
+	if (!atmel_default_console_device)
+		printk(KERN_INFO "AT91: No default serial console defined.\n");
+}
+
+void __init at91_add_device_serial(void)
+{
+	int i;
+
+	for (i = 0; i < ATMEL_MAX_UART; i++) {
+		if (at91_uarts[i])
+			platform_device_register(at91_uarts[i]);
+	}
+}
+#else
+void __init at91_init_serial(struct at91_uart_config *config) {}
+void __init at91_add_device_serial(void) {}
+#endif
+
+
+/* -------------------------------------------------------------------- */
+
+/*
+ * These devices are always present and don't need any board-specific
+ * setup.
+ */
+static int __init at91_add_standard_devices(void)
+{
+	return 0;
+}
+
+arch_initcall(at91_add_standard_devices);
Index: linux-2.6.21.7/arch/arm/mach-at91/board-cam60.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/arch/arm/mach-at91/board-cam60.c
@@ -0,0 +1,148 @@
+/*
+ * KwikByte CAM60
+ *
+ * based on board-sam9260ek.c
+ *   Copyright (C) 2005 SAN People
+ *   Copyright (C) 2006 Atmel
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/at91sam926x_mc.h>
+
+#include "generic.h"
+
+
+/*
+ * Serial port configuration.
+ *    0 .. 5 = USART0 .. USART5
+ *    6      = DBGU
+ */
+static struct at91_uart_config __initdata cam60_uart_config = {
+	.console_tty	= 0,				/* ttyS0 */
+	.nr_tty		= 1,
+	.tty_map	= { 6, -1, -1, -1, -1, -1, -1 }	/* ttyS0, ..., ttyS6 */
+};
+
+static void __init cam60_map_io(void)
+{
+	/* Initialize processor: 10 MHz crystal */
+	at91sam9260_initialize(10000000);
+
+	/* Setup the serial ports and console */
+	at91_init_serial(&cam60_uart_config);
+}
+
+static void __init cam60_init_irq(void)
+{
+	at91sam9260_init_interrupts(NULL);
+}
+
+
+/*
+ * SPI devices.
+ */
+#if defined(CONFIG_MTD_DATAFLASH)
+static struct mtd_partition __initdata cam60_spi_partitions[] = {
+	{
+		.name	= "BOOT1",
+		.offset	= 0,
+		.size	= 4 * 1056,
+	},
+	{
+		.name	= "BOOT2",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 256 * 1056,
+	},
+	{
+		.name	= "kernel",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 2222 * 1056,
+	},
+	{
+		.name	= "file system",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct flash_platform_data __initdata cam60_spi_flash_platform_data = {
+	.name		= "spi_flash",
+	.parts		= cam60_spi_partitions,
+	.nr_parts	= ARRAY_SIZE(cam60_spi_partitions)
+};
+#endif
+
+static struct spi_board_info cam60_spi_devices[] = {
+#if defined(CONFIG_MTD_DATAFLASH)
+	{	/* DataFlash chip */
+		.modalias	= "mtd_dataflash",
+		.chip_select	= 0,
+		.max_speed_hz	= 15 * 1000 * 1000,
+		.bus_num	= 0,
+		.platform_data	= &cam60_spi_flash_platform_data
+	},
+#endif
+};
+
+
+/*
+ * MACB Ethernet device
+ */
+static struct __initdata at91_eth_data cam60_macb_data = {
+	.phy_irq_pin	= AT91_PIN_PB5,
+	.is_rmii	= 0,
+};
+
+
+static void __init cam60_board_init(void)
+{
+	/* Serial */
+	at91_add_device_serial();
+	/* SPI */
+	at91_add_device_spi(cam60_spi_devices, ARRAY_SIZE(cam60_spi_devices));
+	/* Ethernet */
+	at91_add_device_eth(&cam60_macb_data);
+}
+
+MACHINE_START(CAM60, "KwikByte CAM60")
+	/* Maintainer: KwikByte */
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91sam926x_timer,
+	.map_io		= cam60_map_io,
+	.init_irq	= cam60_init_irq,
+	.init_machine	= cam60_board_init,
+MACHINE_END
Index: linux-2.6.21.7/arch/arm/mach-at91/board-chub.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/arch/arm/mach-at91/board-chub.c
@@ -0,0 +1,132 @@
+/*
+ * linux/arch/arm/mach-at91/board-chub.c
+ *
+ *  Copyright (C) 2005 SAN People, adapted for Promwad Chub board
+ *  by Kuten Ivan
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+
+#include "generic.h"
+
+/*
+ * Serial port configuration.
+ *    0 .. 3 = USART0 .. USART3
+ *    4      = DBGU
+ */
+static struct at91_uart_config __initdata chub_uart_config = {
+	.console_tty	= 0,				/* ttyS0 */
+	.nr_tty		= 5,
+	.tty_map	= { 4, 0, 1, 2, 3 }		/* ttyS0, ..., ttyS4 */
+};
+
+static void __init chub_init_irq(void)
+{
+	at91rm9200_init_interrupts(NULL);
+}
+
+static void __init chub_map_io(void)
+{
+	/* Initialize clocks: 18.432 MHz crystal */
+	at91rm9200_initialize(18432000, AT91RM9200_PQFP);
+
+	/* Setup the serial ports and console */
+	at91_init_serial(&chub_uart_config);
+}
+
+static struct at91_eth_data __initdata chub_eth_data = {
+	.phy_irq_pin	= AT91_PIN_PB29,
+	.is_rmii	= 0,
+};
+
+static struct mtd_partition __initdata chub_nand_partition[] = {
+	{
+		.name	= "NAND Partition 1",
+		.offset = 0,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct mtd_partition *nand_partitions(int size, int *num_partitions)
+{
+	*num_partitions = ARRAY_SIZE(chub_nand_partition);
+	return chub_nand_partition;
+}
+
+static struct at91_nand_data __initdata chub_nand_data = {
+	.ale		= 22,
+	.cle		= 21,
+	.enable_pin	= AT91_PIN_PA27,
+	.partition_info	= nand_partitions,
+};
+
+static struct spi_board_info chub_spi_devices[] = {
+	{	/* DataFlash chip */
+		.modalias	= "mtd_dataflash",
+		.chip_select	= 0,
+		.max_speed_hz	= 15 * 1000 * 1000,
+	},
+};
+
+static void __init chub_board_init(void)
+{
+	/* Serial */
+	at91_add_device_serial();
+	/* I2C */
+	at91_add_device_i2c();
+	/* Ethernet */
+	at91_add_device_eth(&chub_eth_data);
+	/* SPI */
+	at91_add_device_spi(chub_spi_devices, ARRAY_SIZE(chub_spi_devices));
+	/* NAND Flash */
+	at91_add_device_nand(&chub_nand_data);
+	/* Disable write protect for NAND */
+	at91_set_gpio_output(AT91_PIN_PB7, 1);
+	/* Power enable for 3x RS-232 and 1x RS-485 */
+	at91_set_gpio_output(AT91_PIN_PB9, 1);
+	/* Disable write protect for FRAM */
+	at91_set_gpio_output(AT91_PIN_PA21, 1);
+	/* Disable write protect for Dataflash */
+	at91_set_gpio_output(AT91_PIN_PA19, 1);
+}
+
+MACHINE_START(CHUB, "Promwad Chub")
+	/* Maintainer: Ivan Kuten AT Promwad DOT com */
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91rm9200_timer,
+	.map_io		= chub_map_io,
+	.init_irq	= chub_init_irq,
+	.init_machine	= chub_board_init,
+MACHINE_END
Index: linux-2.6.21.7/arch/arm/mach-at91/board-csb337.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/board-csb337.c
+++ linux-2.6.21.7/arch/arm/mach-at91/board-csb337.c
@@ -24,6 +24,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
+#include <linux/interrupt.h>
 #include <linux/mtd/physmap.h>
 
 #include <asm/hardware.h>
@@ -59,6 +60,7 @@ static void __init csb337_map_io(void)
 
 	/* Setup the LEDs */
 	at91_init_leds(AT91_PIN_PB0, AT91_PIN_PB1);
+	at91_set_gpio_output(AT91_PIN_PB2, 1);		/* third (unused) LED */
 
 	/* Setup the serial ports and console */
 	at91_init_serial(&csb337_uart_config);
@@ -149,6 +151,55 @@ static struct platform_device csb_flash 
 	.num_resources	= ARRAY_SIZE(csb_flash_resources),
 };
 
+static struct at91_gpio_led csb337_leds[] = {
+	{
+		.name		= "led0",
+		.gpio		= AT91_PIN_PB0,
+		.trigger	= "heartbeat",
+	},
+	{
+		.name		= "led1",
+		.gpio		= AT91_PIN_PB1,
+		.trigger	= "timer",
+	},
+	{
+		.name		= "led2",
+		.gpio		= AT91_PIN_PB2,
+	}
+};
+
+#if defined(CONFIG_CSB300_WAKE_SW0) || defined(CONFIG_CSB300_WAKE_SW1)
+static irqreturn_t switch_irq_handler(int irq, void *context)
+{
+	return IRQ_HANDLED;
+}
+
+static inline void __init switch_irq_setup(int irq, char *name, unsigned long mode)
+{
+	int res;
+
+	res = request_irq(irq, switch_irq_handler, IRQF_SAMPLE_RANDOM | mode, name, NULL);
+	if (res == 0)
+		enable_irq_wake(irq);
+}
+
+static void __init csb300_switches(void)
+{
+#ifdef CONFIG_CSB300_WAKE_SW0
+	at91_set_A_periph(AT91_PIN_PB29, 1);		/* IRQ0 */
+	switch_irq_setup(AT91RM9200_ID_IRQ0, "csb300_sw0", IRQF_TRIGGER_FALLING);
+#endif
+#ifdef CONFIG_CSB300_WAKE_SW1
+	at91_set_gpio_input(AT91_PIN_PB28, 1);
+	at91_set_deglitch(AT91_PIN_PB28, 1);
+	switch_irq_setup(AT91_PIN_PB28, "csb300_sw1", IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING);
+#endif
+	/* there's also SW2 at PA21, GPIO or TIOA2 */
+}
+#else
+static void __init csb300_switches(void) {}
+#endif
+
 static void __init csb337_board_init(void)
 {
 	/* Serial */
@@ -168,8 +219,12 @@ static void __init csb337_board_init(voi
 	at91_add_device_spi(csb337_spi_devices, ARRAY_SIZE(csb337_spi_devices));
 	/* MMC */
 	at91_add_device_mmc(0, &csb337_mmc_data);
+	/* LEDS */
+	at91_gpio_leds(csb337_leds, ARRAY_SIZE(csb337_leds));
 	/* NOR flash */
 	platform_device_register(&csb_flash);
+	/* Switches on CSB300 */
+	csb300_switches();
 }
 
 MACHINE_START(CSB337, "Cogent CSB337")
Index: linux-2.6.21.7/arch/arm/mach-at91/board-dk.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/board-dk.c
+++ linux-2.6.21.7/arch/arm/mach-at91/board-dk.c
@@ -73,6 +73,185 @@ static void __init dk_init_irq(void)
 	at91rm9200_init_interrupts(NULL);
 }
 
+#if defined(CONFIG_FB_S1D13XXX) || defined(CONFIG_FB_S1D13XXX_MODULE)
+#include <video/s1d13xxxfb.h>
+#include <asm/arch/ics1523.h>
+
+/* EPSON S1D13806 FB */
+#define AT91_FB_REG_BASE	0x30000000L
+#define AT91_FB_REG_SIZE	0x200
+#define AT91_FB_VMEM_BASE	0x30200000L
+#define AT91_FB_VMEM_SIZE	0x140000L
+
+static void __init dk_init_video(void)
+{
+	/* NWAIT Signal */
+	at91_set_A_periph(AT91_PIN_PC6, 0);
+
+	/* Initialization of the Static Memory Controller for Chip Select 2 */
+	at91_sys_write(AT91_SMC_CSR(2), AT91_SMC_DBW_16			/* 16 bit */
+				| AT91_SMC_WSEN | AT91_SMC_NWS_(4)	/* wait states */
+				| AT91_SMC_TDF_(1)			/* float time */
+	);
+
+	at91_ics1523_init();
+}
+
+/* CRT:    (active)   640x480 60Hz (PCLK=CLKI=25.175MHz)
+   Memory: Embedded SDRAM (MCLK=CLKI3=50.000MHz) (BUSCLK=60.000MHz) */
+static const struct s1d13xxxfb_regval dk_s1dfb_initregs[] = {
+	{S1DREG_MISC,			0x00},	/* Enable Memory/Register select bit */
+	{S1DREG_COM_DISP_MODE,		0x00},	/* disable display output */
+	{S1DREG_GPIO_CNF0,		0x00},
+	{S1DREG_GPIO_CNF1,		0x00},
+	{S1DREG_GPIO_CTL0,		0x08},
+	{S1DREG_GPIO_CTL1,		0x00},
+	{S1DREG_CLK_CNF,		0x01},	/* no divide, MCLK source is CLKI3 0x02*/
+	{S1DREG_LCD_CLK_CNF,		0x00},
+	{S1DREG_CRT_CLK_CNF,		0x00},
+	{S1DREG_MPLUG_CLK_CNF,		0x00},
+	{S1DREG_CPU2MEM_WST_SEL,	0x01},	/* 2*period(MCLK) - 4ns > period(BCLK) */
+	{S1DREG_SDRAM_REF_RATE,		0x03},	/* 32768 <= MCLK <= 50000 (MHz) */
+	{S1DREG_SDRAM_TC0,		0x00},	/* MCLK source freq (MHz): */
+	{S1DREG_SDRAM_TC1,		0x01},	/* 42 <= MCLK <= 50 */
+	{S1DREG_MEM_CNF,		0x80},	/* SDRAM Initialization - needed before mem access */
+	{S1DREG_PANEL_TYPE,		0x25},	/* std TFT 16bit, 8bit SCP format 2, single passive LCD */
+	{S1DREG_MOD_RATE,		0x00},	/* toggle every FPFRAME */
+	{S1DREG_LCD_DISP_HWIDTH,	0x4F},	/* 680 pix */
+	{S1DREG_LCD_NDISP_HPER,		0x12},	/* 152 pix */
+	{S1DREG_TFT_FPLINE_START,	0x01},	/* 13 pix */
+	{S1DREG_TFT_FPLINE_PWIDTH,	0x0B},	/* 96 pix */
+	{S1DREG_LCD_DISP_VHEIGHT0,	0xDF},
+	{S1DREG_LCD_DISP_VHEIGHT1,	0x01},	/* 480 lines */
+	{S1DREG_LCD_NDISP_VPER,		0x2C},	/* 44 lines */
+	{S1DREG_TFT_FPFRAME_START,	0x0A},	/* 10 lines */
+	{S1DREG_TFT_FPFRAME_PWIDTH,	0x01},	/* 2 lines */
+	{S1DREG_LCD_DISP_MODE,		0x05},  /* 16 bpp */
+	{S1DREG_LCD_MISC,		0x00},	/* dithering enabled, dual panel buffer enabled */
+	{S1DREG_LCD_DISP_START0,	0x00},
+	{S1DREG_LCD_DISP_START1,	0xC8},
+	{S1DREG_LCD_DISP_START2,	0x00},
+	{S1DREG_LCD_MEM_OFF0,		0x80},
+	{S1DREG_LCD_MEM_OFF1,		0x02},
+	{S1DREG_LCD_PIX_PAN,		0x00},
+	{S1DREG_LCD_DISP_FIFO_HTC,	0x3B},
+	{S1DREG_LCD_DISP_FIFO_LTC,	0x3C},
+	{S1DREG_CRT_DISP_HWIDTH,	0x4F},	/* 680 pix */
+	{S1DREG_CRT_NDISP_HPER,		0x13},	/* 160 pix */
+	{S1DREG_CRT_HRTC_START,		0x01},	/* 13 pix */
+	{S1DREG_CRT_HRTC_PWIDTH,	0x0B},	/* 96 pix */
+	{S1DREG_CRT_DISP_VHEIGHT0,	0xDF},
+	{S1DREG_CRT_DISP_VHEIGHT1,	0x01},	/* 480 lines */
+	{S1DREG_CRT_NDISP_VPER,		0x2B},	/* 44 lines */
+	{S1DREG_CRT_VRTC_START,		0x09},	/* 10 lines */
+	{S1DREG_CRT_VRTC_PWIDTH,	0x01},	/* 2 lines */
+	{S1DREG_TV_OUT_CTL,		0x10},
+	{S1DREG_CRT_DISP_MODE,		0x05},	/* 16 bpp */
+	{S1DREG_CRT_DISP_START0,	0x00},
+	{S1DREG_CRT_DISP_START1,	0x00},
+	{S1DREG_CRT_DISP_START2,	0x00},
+	{S1DREG_CRT_MEM_OFF0,		0x80},
+	{S1DREG_CRT_MEM_OFF1,		0x02},
+	{S1DREG_CRT_PIX_PAN,		0x00},
+	{S1DREG_CRT_DISP_FIFO_HTC,	0x3B},
+	{S1DREG_CRT_DISP_FIFO_LTC,	0x3C},
+	{S1DREG_LCD_CUR_CTL,		0x00},	/* inactive */
+	{S1DREG_LCD_CUR_START,		0x01},
+	{S1DREG_LCD_CUR_XPOS0,		0x00},
+	{S1DREG_LCD_CUR_XPOS1,		0x00},
+	{S1DREG_LCD_CUR_YPOS0,		0x00},
+	{S1DREG_LCD_CUR_YPOS1,		0x00},
+	{S1DREG_LCD_CUR_BCTL0,		0x00},
+	{S1DREG_LCD_CUR_GCTL0,		0x00},
+	{S1DREG_LCD_CUR_RCTL0,		0x00},
+	{S1DREG_LCD_CUR_BCTL1,		0x1F},
+	{S1DREG_LCD_CUR_GCTL1,		0x3F},
+	{S1DREG_LCD_CUR_RCTL1,		0x1F},
+	{S1DREG_LCD_CUR_FIFO_HTC,	0x00},
+	{S1DREG_CRT_CUR_CTL,		0x00},	/* inactive */
+	{S1DREG_CRT_CUR_START,		0x01},
+	{S1DREG_CRT_CUR_XPOS0,		0x00},
+	{S1DREG_CRT_CUR_XPOS1,		0x00},
+	{S1DREG_CRT_CUR_YPOS0,		0x00},
+	{S1DREG_CRT_CUR_YPOS1,		0x00},
+	{S1DREG_CRT_CUR_BCTL0,		0x00},
+	{S1DREG_CRT_CUR_GCTL0,		0x00},
+	{S1DREG_CRT_CUR_RCTL0,		0x00},
+	{S1DREG_CRT_CUR_BCTL1,		0x1F},
+	{S1DREG_CRT_CUR_GCTL1,		0x3F},
+	{S1DREG_CRT_CUR_RCTL1,		0x1F},
+	{S1DREG_CRT_CUR_FIFO_HTC,	0x00},
+	{S1DREG_BBLT_CTL0,		0x00},
+	{S1DREG_BBLT_CTL0,		0x00},
+	{S1DREG_BBLT_CC_EXP,		0x00},
+	{S1DREG_BBLT_OP,		0x00},
+	{S1DREG_BBLT_SRC_START0,	0x00},
+	{S1DREG_BBLT_SRC_START1,	0x00},
+	{S1DREG_BBLT_SRC_START2,	0x00},
+	{S1DREG_BBLT_DST_START0,	0x00},
+	{S1DREG_BBLT_DST_START1,	0x00},
+	{S1DREG_BBLT_DST_START2,	0x00},
+	{S1DREG_BBLT_MEM_OFF0,		0x00},
+	{S1DREG_BBLT_MEM_OFF1,		0x00},
+	{S1DREG_BBLT_WIDTH0,		0x00},
+	{S1DREG_BBLT_WIDTH1,		0x00},
+	{S1DREG_BBLT_HEIGHT0,		0x00},
+	{S1DREG_BBLT_HEIGHT1,		0x00},
+	{S1DREG_BBLT_BGC0,		0x00},
+	{S1DREG_BBLT_BGC1,		0x00},
+	{S1DREG_BBLT_FGC0,		0x00},
+	{S1DREG_BBLT_FGC1,		0x00},
+	{S1DREG_LKUP_MODE,		0x00},	/* LCD LUT r | LCD and CRT/TV LUT w */
+	{S1DREG_LKUP_ADDR,		0x00},
+	{S1DREG_PS_CNF,			0x00},	/* Power Save disable */
+	{S1DREG_PS_STATUS,		0x02},	/* LCD Panel down, mem up */
+	{S1DREG_CPU2MEM_WDOGT,		0x00},
+	{S1DREG_COM_DISP_MODE,		0x02},	/* enable CRT display output */
+};
+
+static struct s1d13xxxfb_pdata dk_s1dfb_pdata = {
+	.initregs		= dk_s1dfb_initregs,
+	.initregssize		= ARRAY_SIZE(dk_s1dfb_initregs),
+	.platform_init_video	= dk_init_video,
+};
+
+static u64 s1dfb_dmamask = 0xffffffffUL;
+
+static struct resource dk_s1dfb_resource[] = {
+	[0] = {	/* video mem */
+		.name   = "s1d13806 memory",
+		.start  = AT91_FB_VMEM_BASE,
+		.end    = AT91_FB_VMEM_BASE + AT91_FB_VMEM_SIZE -1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {	/* video registers */
+		.name   = "s1d13806 registers",
+		.start  = AT91_FB_REG_BASE,
+		.end    = AT91_FB_REG_BASE + AT91_FB_REG_SIZE -1,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device dk_s1dfb_device = {
+	.name		= "s1d13806fb",
+	.id		= -1,
+	.dev		= {
+			.dma_mask		= &s1dfb_dmamask,
+			.coherent_dma_mask	= 0xffffffff,
+			.platform_data		= &dk_s1dfb_pdata,
+	},
+	.resource	= dk_s1dfb_resource,
+	.num_resources	= ARRAY_SIZE(dk_s1dfb_resource),
+};
+
+static void __init dk_add_device_video(void)
+{
+	platform_device_register(&dk_s1dfb_device);
+}
+#else
+static void __init dk_add_device_video(void) {}
+#endif
+
 static struct at91_eth_data __initdata dk_eth_data = {
 	.phy_irq_pin	= AT91_PIN_PC4,
 	.is_rmii	= 1,
@@ -151,7 +330,7 @@ static struct at91_nand_data __initdata 
 #define DK_FLASH_SIZE	0x200000
 
 static struct physmap_flash_data dk_flash_data = {
-	.width	= 2,
+	.width		= 2,
 };
 
 static struct resource dk_flash_resource = {
@@ -170,6 +349,13 @@ static struct platform_device dk_flash =
 	.num_resources	= 1,
 };
 
+static struct at91_gpio_led dk_leds[] = {
+	{
+		.name		= "led0",
+		.gpio		= AT91_PIN_PB2,
+		.trigger	= "timer",
+	}
+};
 
 static void __init dk_board_init(void)
 {
@@ -200,8 +386,10 @@ static void __init dk_board_init(void)
 	at91_add_device_nand(&dk_nand_data);
 	/* NOR Flash */
 	platform_device_register(&dk_flash);
+	/* LEDs */
+	at91_gpio_leds(dk_leds, ARRAY_SIZE(dk_leds));
 	/* VGA */
-//	dk_add_device_video();
+	dk_add_device_video();
 }
 
 MACHINE_START(AT91RM9200DK, "Atmel AT91RM9200-DK")
Index: linux-2.6.21.7/arch/arm/mach-at91/board-ek.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/board-ek.c
+++ linux-2.6.21.7/arch/arm/mach-at91/board-ek.c
@@ -73,6 +73,187 @@ static void __init ek_init_irq(void)
 	at91rm9200_init_interrupts(NULL);
 }
 
+#if defined(CONFIG_FB_S1D13XXX) || defined(CONFIG_FB_S1D13XXX_MODULE)
+#include <video/s1d13xxxfb.h>
+#include <asm/arch/ics1523.h>
+
+/* EPSON S1D13806 FB */
+#define AT91_FB_REG_BASE	0x40000000L
+#define	AT91_FB_REG_SIZE	0x200
+#define AT91_FB_VMEM_BASE	0x40200000L
+#define AT91_FB_VMEM_SIZE	0x140000L
+
+static void __init ek_init_video(void)
+{
+	/* NWAIT Signal */
+	at91_set_A_periph(AT91_PIN_PC6, 0);
+
+	/* Initialization of the Static Memory Controller for Chip Select 3 */
+	at91_sys_write(AT91_SMC_CSR(3), AT91_SMC_DBW_16			/* 16 bit */
+				| AT91_SMC_WSEN | AT91_SMC_NWS_(5)	/* wait states */
+				| AT91_SMC_TDF_(1)			/* float time */
+	);
+
+	at91_ics1523_init();
+}
+
+/* CRT:    (active)   640x480 60Hz (PCLK=CLKI=25.175MHz)
+   Memory: Embedded SDRAM (MCLK=CLKI3=50.000MHz) (BUSCLK=60.000MHz) */
+static const struct s1d13xxxfb_regval ek_s1dfb_initregs[] = {
+	{S1DREG_MISC,			0x00},	/* Enable Memory/Register select bit */
+	{S1DREG_COM_DISP_MODE,		0x00},	/* disable display output */
+	{S1DREG_GPIO_CNF0,		0xFF},	// 0x00
+	{S1DREG_GPIO_CNF1,		0x1F},	// 0x08
+	{S1DREG_GPIO_CTL0,		0x00},
+	{S1DREG_GPIO_CTL1,		0x00},
+	{S1DREG_CLK_CNF,		0x01},	/* no divide, MCLK source is CLKI3 0x02*/
+	{S1DREG_LCD_CLK_CNF,		0x00},
+	{S1DREG_CRT_CLK_CNF,		0x00},
+	{S1DREG_MPLUG_CLK_CNF,		0x00},
+	{S1DREG_CPU2MEM_WST_SEL,	0x01},	/* 2*period(MCLK) - 4ns > period(BCLK) */
+	{S1DREG_SDRAM_REF_RATE,		0x03},	/* 32768 <= MCLK <= 50000 (MHz) */
+	{S1DREG_SDRAM_TC0,		0x00},	/* MCLK source freq (MHz): */
+	{S1DREG_SDRAM_TC1,		0x01},	/* 42 <= MCLK <= 50 */
+	{S1DREG_MEM_CNF,		0x80},	/* SDRAM Initialization - needed before mem access */
+	{S1DREG_PANEL_TYPE,		0x25},	/* std TFT 16bit, 8bit SCP format 2, single passive LCD */
+	{S1DREG_MOD_RATE,		0x00},	/* toggle every FPFRAME */
+	{S1DREG_LCD_DISP_HWIDTH,	0x4F},	/* 680 pix */
+	{S1DREG_LCD_NDISP_HPER,		0x12},	/* 152 pix */
+	{S1DREG_TFT_FPLINE_START,	0x01},	/* 13 pix */
+	{S1DREG_TFT_FPLINE_PWIDTH,	0x0B},	/* 96 pix */
+	{S1DREG_LCD_DISP_VHEIGHT0,	0xDF},
+	{S1DREG_LCD_DISP_VHEIGHT1,	0x01},	/* 480 lines */
+	{S1DREG_LCD_NDISP_VPER,		0x2C},	/* 44 lines */
+	{S1DREG_TFT_FPFRAME_START,	0x0A},	/* 10 lines */
+	{S1DREG_TFT_FPFRAME_PWIDTH,	0x01},	/* 2 lines */
+	{S1DREG_LCD_DISP_MODE,		0x05},  /* 16 bpp */
+	{S1DREG_LCD_MISC,		0x00},	/* dithering enabled, dual panel buffer enabled */
+	{S1DREG_LCD_DISP_START0,	0x00},
+	{S1DREG_LCD_DISP_START1,	0xC8},
+	{S1DREG_LCD_DISP_START2,	0x00},
+	{S1DREG_LCD_MEM_OFF0,		0x80},
+	{S1DREG_LCD_MEM_OFF1,		0x02},
+	{S1DREG_LCD_PIX_PAN,		0x00},
+	{S1DREG_LCD_DISP_FIFO_HTC,	0x3B},
+	{S1DREG_LCD_DISP_FIFO_LTC,	0x3C},
+	{S1DREG_CRT_DISP_HWIDTH,	0x4F},	/* 680 pix */
+	{S1DREG_CRT_NDISP_HPER,		0x13},	/* 160 pix */
+	{S1DREG_CRT_HRTC_START,		0x01},	/* 13 pix */
+	{S1DREG_CRT_HRTC_PWIDTH,	0x0B},	/* 96 pix */
+	{S1DREG_CRT_DISP_VHEIGHT0,	0xDF},
+	{S1DREG_CRT_DISP_VHEIGHT1,	0x01},	/* 480 lines */
+	{S1DREG_CRT_NDISP_VPER,		0x2B},	/* 44 lines */
+	{S1DREG_CRT_VRTC_START,		0x09},	/* 10 lines */
+	{S1DREG_CRT_VRTC_PWIDTH,	0x01},	/* 2 lines */
+	{S1DREG_TV_OUT_CTL,		0x10},
+	{0x005E,			0x9F},
+	{0x005F,			0x00},
+	{S1DREG_CRT_DISP_MODE,		0x05},	/* 16 bpp */
+	{S1DREG_CRT_DISP_START0,	0x00},
+	{S1DREG_CRT_DISP_START1,	0x00},
+	{S1DREG_CRT_DISP_START2,	0x00},
+	{S1DREG_CRT_MEM_OFF0,		0x80},
+	{S1DREG_CRT_MEM_OFF1,		0x02},
+	{S1DREG_CRT_PIX_PAN,		0x00},
+	{S1DREG_CRT_DISP_FIFO_HTC,	0x3B},
+	{S1DREG_CRT_DISP_FIFO_LTC,	0x3C},
+	{S1DREG_LCD_CUR_CTL,		0x00},	/* inactive */
+	{S1DREG_LCD_CUR_START,		0x01},
+	{S1DREG_LCD_CUR_XPOS0,		0x00},
+	{S1DREG_LCD_CUR_XPOS1,		0x00},
+	{S1DREG_LCD_CUR_YPOS0,		0x00},
+	{S1DREG_LCD_CUR_YPOS1,		0x00},
+	{S1DREG_LCD_CUR_BCTL0,		0x00},
+	{S1DREG_LCD_CUR_GCTL0,		0x00},
+	{S1DREG_LCD_CUR_RCTL0,		0x00},
+	{S1DREG_LCD_CUR_BCTL1,		0x1F},
+	{S1DREG_LCD_CUR_GCTL1,		0x3F},
+	{S1DREG_LCD_CUR_RCTL1,		0x1F},
+	{S1DREG_LCD_CUR_FIFO_HTC,	0x00},
+	{S1DREG_CRT_CUR_CTL,		0x00},	/* inactive */
+	{S1DREG_CRT_CUR_START,		0x01},
+	{S1DREG_CRT_CUR_XPOS0,		0x00},
+	{S1DREG_CRT_CUR_XPOS1,		0x00},
+	{S1DREG_CRT_CUR_YPOS0,		0x00},
+	{S1DREG_CRT_CUR_YPOS1,		0x00},
+	{S1DREG_CRT_CUR_BCTL0,		0x00},
+	{S1DREG_CRT_CUR_GCTL0,		0x00},
+	{S1DREG_CRT_CUR_RCTL0,		0x00},
+	{S1DREG_CRT_CUR_BCTL1,		0x1F},
+	{S1DREG_CRT_CUR_GCTL1,		0x3F},
+	{S1DREG_CRT_CUR_RCTL1,		0x1F},
+	{S1DREG_CRT_CUR_FIFO_HTC,	0x00},
+	{S1DREG_BBLT_CTL0,		0x00},
+	{S1DREG_BBLT_CTL0,		0x00},
+	{S1DREG_BBLT_CC_EXP,		0x00},
+	{S1DREG_BBLT_OP,		0x00},
+	{S1DREG_BBLT_SRC_START0,	0x00},
+	{S1DREG_BBLT_SRC_START1,	0x00},
+	{S1DREG_BBLT_SRC_START2,	0x00},
+	{S1DREG_BBLT_DST_START0,	0x00},
+	{S1DREG_BBLT_DST_START1,	0x00},
+	{S1DREG_BBLT_DST_START2,	0x00},
+	{S1DREG_BBLT_MEM_OFF0,		0x00},
+	{S1DREG_BBLT_MEM_OFF1,		0x00},
+	{S1DREG_BBLT_WIDTH0,		0x00},
+	{S1DREG_BBLT_WIDTH1,		0x00},
+	{S1DREG_BBLT_HEIGHT0,		0x00},
+	{S1DREG_BBLT_HEIGHT1,		0x00},
+	{S1DREG_BBLT_BGC0,		0x00},
+	{S1DREG_BBLT_BGC1,		0x00},
+	{S1DREG_BBLT_FGC0,		0x00},
+	{S1DREG_BBLT_FGC1,		0x00},
+	{S1DREG_LKUP_MODE,		0x00},	/* LCD LUT r | LCD and CRT/TV LUT w */
+	{S1DREG_LKUP_ADDR,		0x00},
+	{S1DREG_PS_CNF,			0x10},	/* Power Save disable */
+	{S1DREG_PS_STATUS,		0x02},	/* LCD Panel down, mem up */
+	{S1DREG_CPU2MEM_WDOGT,		0x00},
+	{S1DREG_COM_DISP_MODE,		0x02},	/* enable CRT display output */
+};
+
+static struct s1d13xxxfb_pdata ek_s1dfb_pdata = {
+	.initregs		= ek_s1dfb_initregs,
+	.initregssize		= ARRAY_SIZE(ek_s1dfb_initregs),
+	.platform_init_video	= ek_init_video,
+};
+
+static u64 s1dfb_dmamask = 0xffffffffUL;
+
+static struct resource ek_s1dfb_resource[] = {
+	[0] = {	/* video mem */
+		.name   = "s1d13806 memory",
+		.start  = AT91_FB_VMEM_BASE,
+		.end    = AT91_FB_VMEM_BASE + AT91_FB_VMEM_SIZE -1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {	/* video registers */
+		.name   = "s1d13806 registers",
+		.start  = AT91_FB_REG_BASE,
+		.end    = AT91_FB_REG_BASE + AT91_FB_REG_SIZE -1,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ek_s1dfb_device = {
+	.name		= "s1d13806fb",
+	.id		= -1,
+	.dev		= {
+			.dma_mask		= &s1dfb_dmamask,
+			.coherent_dma_mask	= 0xffffffff,
+			.platform_data		= &ek_s1dfb_pdata,
+	},
+	.resource	= ek_s1dfb_resource,
+	.num_resources	= ARRAY_SIZE(ek_s1dfb_resource),
+};
+
+static void __init ek_add_device_video(void)
+{
+	platform_device_register(&ek_s1dfb_device);
+}
+#else
+static void __init ek_add_device_video(void) {}
+#endif
+
 static struct at91_eth_data __initdata ek_eth_data = {
 	.phy_irq_pin	= AT91_PIN_PC4,
 	.is_rmii	= 1,
@@ -113,7 +294,7 @@ static struct spi_board_info ek_spi_devi
 #define EK_FLASH_SIZE	0x200000
 
 static struct physmap_flash_data ek_flash_data = {
-	.width	= 2,
+	.width		= 2,
 };
 
 static struct resource ek_flash_resource = {
@@ -132,6 +313,18 @@ static struct platform_device ek_flash =
 	.num_resources	= 1,
 };
 
+static struct at91_gpio_led ek_leds[] = {
+	{
+		.name		= "led0",
+		.gpio		= AT91_PIN_PB1,
+		.trigger	= "heartbeat",
+	},
+	{
+		.name		= "led1",
+		.gpio		= AT91_PIN_PB2,
+		.trigger	= "timer",
+	}
+};
 
 static void __init ek_board_init(void)
 {
@@ -158,8 +351,10 @@ static void __init ek_board_init(void)
 #endif
 	/* NOR Flash */
 	platform_device_register(&ek_flash);
+	/* LEDs */
+	at91_gpio_leds(ek_leds, ARRAY_SIZE(ek_leds));
 	/* VGA */
-//	ek_add_device_video();
+	ek_add_device_video();
 }
 
 MACHINE_START(AT91RM9200EK, "Atmel AT91RM9200-EK")
Index: linux-2.6.21.7/arch/arm/mach-at91/board-kb9202.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/board-kb9202.c
+++ linux-2.6.21.7/arch/arm/mach-at91/board-kb9202.c
@@ -37,6 +37,8 @@
 #include <asm/arch/board.h>
 #include <asm/arch/gpio.h>
 
+#include <asm/arch/at91rm9200_mc.h>
+
 #include "generic.h"
 
 
@@ -111,6 +113,48 @@ static struct at91_nand_data __initdata 
 	.partition_info	= nand_partitions,
 };
 
+
+#if defined(CONFIG_FB_S1D15605)
+#warning "Rather pass reset pin via platform_data"
+static struct resource kb9202_lcd_resources[] = {
+	[0] = {
+		.start	= AT91_CHIPSELECT_2,
+		.end	= AT91_CHIPSELECT_2 + 0x200FF,
+		.flags	= IORESOURCE_MEM
+	},
+	[1] = {	/* reset pin */
+		.start	= AT91_PIN_PC22,
+		.end	= AT91_PIN_PC22,
+		.flags	= IORESOURCE_MEM
+	},
+};
+
+static struct platform_device kb9202_lcd_device = {
+	.name		= "s1d15605fb",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(kb9202_lcd_resources),
+	.resource	= kb9202_lcd_resources,
+};
+
+static void __init kb9202_add_device_lcd(void)
+{
+ 	/* In case the boot loader did not set the chip select mode and timing */
+	at91_sys_write(AT91_SMC_CSR(2),
+		AT91_SMC_WSEN | AT91_SMC_NWS_(18) | AT91_SMC_TDF_(1) | AT91_SMC_DBW_8 |
+		AT91_SMC_RWSETUP_(1) | AT91_SMC_RWHOLD_(1));
+
+	/* Backlight pin = output, off */
+	at91_set_gpio_output(AT91_PIN_PC23, 0);
+
+	/* Reset pin = output, in reset */
+	at91_set_gpio_output(AT91_PIN_PC22, 0);
+
+	platform_device_register(&kb9202_lcd_device);
+}
+#else
+static void __init kb9202_add_device_lcd(void) {}
+#endif
+
 static void __init kb9202_board_init(void)
 {
 	/* Serial */
@@ -129,6 +173,8 @@ static void __init kb9202_board_init(voi
 	at91_add_device_spi(NULL, 0);
 	/* NAND */
 	at91_add_device_nand(&kb9202_nand_data);
+	/* LCD	*/
+	kb9202_add_device_lcd();
 }
 
 MACHINE_START(KB9200, "KB920x")
Index: linux-2.6.21.7/arch/arm/mach-at91/board-sam9260ek.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/board-sam9260ek.c
+++ linux-2.6.21.7/arch/arm/mach-at91/board-sam9260ek.c
@@ -104,9 +104,9 @@ static struct spi_board_info ek_spi_devi
 	},
 #endif
 #endif
-#if defined(CONFIG_SND_AT73C213)
+#if defined(CONFIG_SND_AT73C213) || defined(CONFIG_SND_AT73C213_MODULE)
 	{	/* AT73C213 DAC */
-		.modalias	= "snd_at73c213",
+		.modalias	= "at73c213",
 		.chip_select	= 0,
 		.max_speed_hz	= 10 * 1000 * 1000,
 		.bus_num	= 1,
@@ -118,7 +118,7 @@ static struct spi_board_info ek_spi_devi
 /*
  * MACB Ethernet device
  */
-static struct __initdata at91_eth_data ek_macb_data = {
+static struct at91_eth_data __initdata ek_macb_data = {
 	.phy_irq_pin	= AT91_PIN_PA7,
 	.is_rmii	= 1,
 };
@@ -188,6 +188,8 @@ static void __init ek_board_init(void)
 	at91_add_device_eth(&ek_macb_data);
 	/* MMC */
 	at91_add_device_mmc(0, &ek_mmc_data);
+	/* I2C */
+	at91_add_device_i2c();
 }
 
 MACHINE_START(AT91SAM9260EK, "Atmel AT91SAM9260-EK")
Index: linux-2.6.21.7/arch/arm/mach-at91/board-sam9261ek.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/board-sam9261ek.c
+++ linux-2.6.21.7/arch/arm/mach-at91/board-sam9261ek.c
@@ -25,7 +25,11 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
+#include <linux/spi/ads7846.h>
 #include <linux/dm9000.h>
+#include <linux/fb.h>
+
+#include <video/atmel_lcdc.h>
 
 #include <asm/hardware.h>
 #include <asm/setup.h>
@@ -59,6 +63,9 @@ static void __init ek_map_io(void)
 	/* Initialize processor: 18.432 MHz crystal */
 	at91sam9261_initialize(18432000);
 
+	/* Setup the LEDs */
+	at91_init_leds(AT91_PIN_PA13, AT91_PIN_PA14);
+
 	/* Setup the serial ports and console */
 	at91_init_serial(&ek_uart_config);
 }
@@ -195,6 +202,41 @@ static struct at91_nand_data __initdata 
 };
 
 /*
+ * ADS7846 Touchscreen
+ */
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+
+static int ads7843_pendown_state(void)
+{
+	return !at91_get_gpio_value(AT91_PIN_PC2);	/* Touchscreen PENIRQ */
+}
+
+static struct ads7846_platform_data ads_info = {
+	.model			= 7843,
+	.x_min			= 150,
+	.x_max			= 3830,
+	.y_min			= 190,
+	.y_max			= 3830,
+	.vref_delay_usecs	= 100,
+	.x_plate_ohms		= 450,
+	.y_plate_ohms		= 250,
+	.pressure_max		= 15000,
+	.debounce_max		= 1,
+	.debounce_rep		= 0,
+	.debounce_tol		= (~0),
+	.get_pendown_state	= ads7843_pendown_state,
+};
+
+static void __init ek_add_device_ts(void)
+{
+	at91_set_B_periph(AT91_PIN_PC2, 1);	/* External IRQ0, with pullup */
+	at91_set_gpio_input(AT91_PIN_PA11, 1);	/* Touchscreen BUSY signal */
+}
+#else
+static void __init ek_add_device_ts(void) {}
+#endif
+
+/*
  * SPI devices
  */
 static struct spi_board_info ek_spi_devices[] = {
@@ -204,6 +246,17 @@ static struct spi_board_info ek_spi_devi
 		.max_speed_hz	= 15 * 1000 * 1000,
 		.bus_num	= 0,
 	},
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+	{
+		.modalias	= "ads7846",
+		.chip_select	= 2,
+		.max_speed_hz	= 125000 * 26,	/* (max sample rate @ 3V) * (cmd + data + overhead) */
+		.bus_num	= 0,
+		.platform_data	= &ads_info,
+		.irq		= AT91SAM9261_ID_IRQ0,
+		.controller_data = AT91_PIN_PA28,	/* CS pin */
+	},
+#endif
 #if defined(CONFIG_MTD_AT91_DATAFLASH_CARD)
 	{	/* DataFlash card - jumper (J12) configurable to CS3 or CS0 */
 		.modalias	= "mtd_dataflash",
@@ -211,9 +264,9 @@ static struct spi_board_info ek_spi_devi
 		.max_speed_hz	= 15 * 1000 * 1000,
 		.bus_num	= 0,
 	},
-#elif defined(CONFIG_SND_AT73C213)
+#elif defined(CONFIG_SND_AT73C213) || defined(CONFIG_SND_AT73C213_MODULE)
 	{	/* AT73C213 DAC */
-		.modalias	= "snd_at73c213",
+		.modalias	= "at73c213",
 		.chip_select	= 3,
 		.max_speed_hz	= 10 * 1000 * 1000,
 		.bus_num	= 0,
@@ -222,6 +275,65 @@ static struct spi_board_info ek_spi_devi
 };
 
 
+/*
+ * LCD Controller
+ */
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
+static struct fb_videomode at91_tft_vga_modes[] = {
+	{
+	        .name           = "TX09D50VM1CCA @ 60",
+		.refresh	= 60,
+		.xres		= 240,		.yres		= 320,
+		.pixclock	= KHZ2PICOS(4965),
+
+		.left_margin	= 1,		.right_margin	= 33,
+		.upper_margin	= 1,		.lower_margin	= 0,
+		.hsync_len	= 5,		.vsync_len	= 1,
+
+		.sync		= FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+};
+
+static struct fb_monspecs at91fb_default_monspecs = {
+	.manufacturer	= "HIT",
+	.monitor        = "TX09D50VM1CCA",
+
+	.modedb		= at91_tft_vga_modes,
+	.modedb_len	= ARRAY_SIZE(at91_tft_vga_modes),
+	.hfmin		= 15000,
+	.hfmax		= 64000,
+	.vfmin		= 50,
+	.vfmax		= 150,
+};
+
+#define AT91SAM9261_DEFAULT_LCDCON2 	(ATMEL_LCDC_MEMOR_LITTLE \
+					| ATMEL_LCDC_DISTYPE_TFT    \
+					| ATMEL_LCDC_CLKMOD_ALWAYSACTIVE)
+
+static void at91_lcdc_power_control(int on)
+{
+	if (on)
+		at91_set_gpio_value(AT91_PIN_PA12, 0);	/* power up */
+	else
+		at91_set_gpio_value(AT91_PIN_PA12, 1);	/* power down */
+}
+
+/* Driver datas */
+static struct atmel_lcdfb_info __initdata ek_lcdc_data = {
+	.default_bpp			= 16,
+	.default_dmacon			= ATMEL_LCDC_DMAEN,
+	.default_lcdcon2		= AT91SAM9261_DEFAULT_LCDCON2,
+	.default_monspecs		= &at91fb_default_monspecs,
+	.atmel_lcdfb_power_control	= at91_lcdc_power_control,
+	.guard_time			= 1,
+};
+
+#else
+static struct atmel_lcdfb_info __initdata ek_lcdc_data;
+#endif
+
+
 static void __init ek_board_init(void)
 {
 	/* Serial */
@@ -241,10 +353,14 @@ static void __init ek_board_init(void)
 #if defined(CONFIG_SPI_ATMEL) || defined(CONFIG_SPI_ATMEL_MODULE)
 	/* SPI */
 	at91_add_device_spi(ek_spi_devices, ARRAY_SIZE(ek_spi_devices));
+	/* Touchscreen */
+	ek_add_device_ts();
 #else
 	/* MMC */
 	at91_add_device_mmc(0, &ek_mmc_data);
 #endif
+	/* LCD Controller */
+	at91_add_device_lcdc(&ek_lcdc_data);
 }
 
 MACHINE_START(AT91SAM9261EK, "Atmel AT91SAM9261-EK")
Index: linux-2.6.21.7/arch/arm/mach-at91/board-sam9263ek.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/board-sam9263ek.c
+++ linux-2.6.21.7/arch/arm/mach-at91/board-sam9263ek.c
@@ -25,6 +25,10 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
+#include <linux/spi/ads7846.h>
+#include <linux/fb.h>
+
+#include <video/atmel_lcdc.h>
 
 #include <asm/hardware.h>
 #include <asm/setup.h>
@@ -86,6 +90,40 @@ static struct at91_udc_data __initdata e
 
 
 /*
+ * ADS7846 Touchscreen
+ */
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+static int ads7843_pendown_state(void)
+{
+	return !at91_get_gpio_value(AT91_PIN_PA15);	/* Touchscreen PENIRQ */
+}
+
+static struct ads7846_platform_data ads_info = {
+	.model			= 7843,
+	.x_min			= 150,
+	.x_max			= 3830,
+	.y_min			= 190,
+	.y_max			= 3830,
+	.vref_delay_usecs	= 100,
+	.x_plate_ohms		= 450,
+	.y_plate_ohms		= 250,
+	.pressure_max		= 15000,
+	.debounce_max		= 1,
+	.debounce_rep		= 0,
+	.debounce_tol		= (~0),
+	.get_pendown_state	= ads7843_pendown_state,
+};
+
+static void __init ek_add_device_ts(void)
+{
+	at91_set_B_periph(AT91_PIN_PA15, 1);	/* External IRQ1, with pullup */
+	at91_set_gpio_input(AT91_PIN_PA31, 1);	/* Touchscreen BUSY signal */
+}
+#else
+static void __init ek_add_device_ts(void) {}
+#endif
+
+/*
  * SPI devices.
  */
 static struct spi_board_info ek_spi_devices[] = {
@@ -97,6 +135,16 @@ static struct spi_board_info ek_spi_devi
 		.bus_num	= 0,
 	},
 #endif
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+	{
+		.modalias	= "ads7846",
+		.chip_select	= 3,
+		.max_speed_hz	= 125000 * 26,	/* (max sample rate @ 3V) * (cmd + data + overhead) */
+		.bus_num	= 0,
+		.platform_data	= &ads_info,
+		.irq		= AT91SAM9263_ID_IRQ1,
+	},
+#endif
 };
 
 
@@ -112,6 +160,14 @@ static struct at91_mmc_data __initdata e
 
 
 /*
+ * MACB Ethernet device
+ */
+static struct at91_eth_data __initdata ek_macb_data = {
+	.is_rmii	= 1,
+};
+
+
+/*
  * NAND flash
  */
 static struct mtd_partition __initdata ek_nand_partition[] = {
@@ -148,6 +204,73 @@ static struct at91_nand_data __initdata 
 };
 
 
+/*
+ * LCD Controller
+ */
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
+static struct fb_videomode at91_tft_vga_modes[] = {
+	{
+	        .name           = "TX09D50VM1CCA @ 60",
+		.refresh	= 60,
+		.xres		= 240,		.yres		= 320,
+		.pixclock	= KHZ2PICOS(4965),
+
+		.left_margin	= 1,		.right_margin	= 33,
+		.upper_margin	= 1,		.lower_margin	= 0,
+		.hsync_len	= 5,		.vsync_len	= 1,
+
+		.sync		= FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+};
+
+static struct fb_monspecs at91fb_default_monspecs = {
+	.manufacturer	= "HIT",
+	.monitor        = "TX09D70VM1CCA",
+
+	.modedb		= at91_tft_vga_modes,
+	.modedb_len	= ARRAY_SIZE(at91_tft_vga_modes),
+	.hfmin		= 15000,
+	.hfmax		= 64000,
+	.vfmin		= 50,
+	.vfmax		= 150,
+};
+
+#define AT91SAM9263_DEFAULT_LCDCON2 	(ATMEL_LCDC_MEMOR_LITTLE \
+					| ATMEL_LCDC_DISTYPE_TFT    \
+					| ATMEL_LCDC_CLKMOD_ALWAYSACTIVE)
+
+static void at91_lcdc_power_control(int on)
+{
+	if (on)
+		at91_set_gpio_value(AT91_PIN_PD12, 0);	/* power up */
+	else
+		at91_set_gpio_value(AT91_PIN_PD12, 1);	/* power down */
+}
+
+/* Driver datas */
+static struct atmel_lcdfb_info __initdata ek_lcdc_data = {
+	.default_bpp			= 16,
+	.default_dmacon			= ATMEL_LCDC_DMAEN,
+	.default_lcdcon2		= AT91SAM9263_DEFAULT_LCDCON2,
+	.default_monspecs		= &at91fb_default_monspecs,
+	.atmel_lcdfb_power_control	= at91_lcdc_power_control,
+	.guard_time			= 1,
+};
+
+#else
+static struct atmel_lcdfb_info __initdata ek_lcdc_data;
+#endif
+
+
+/*
+ * AC97
+ */
+static struct atmel_ac97_data ek_ac97_data = {
+	.reset_pin	= AT91_PIN_PA13,
+};
+
+
 static void __init ek_board_init(void)
 {
 	/* Serial */
@@ -157,11 +280,22 @@ static void __init ek_board_init(void)
 	/* USB Device */
 	at91_add_device_udc(&ek_udc_data);
 	/* SPI */
+	at91_set_gpio_output(AT91_PIN_PE20, 1);		/* select spi0 clock */
 	at91_add_device_spi(ek_spi_devices, ARRAY_SIZE(ek_spi_devices));
+	/* Touchscreen */
+	ek_add_device_ts();
 	/* MMC */
 	at91_add_device_mmc(1, &ek_mmc_data);
+	/* Ethernet */
+	at91_add_device_eth(&ek_macb_data);
 	/* NAND */
 	at91_add_device_nand(&ek_nand_data);
+	/* I2C */
+	at91_add_device_i2c();
+	/* LCD Controller */
+	at91_add_device_lcdc(&ek_lcdc_data);
+	/* AC97 */
+	at91_add_device_ac97(&ek_ac97_data);
 }
 
 MACHINE_START(AT91SAM9263EK, "Atmel AT91SAM9263-EK")
Index: linux-2.6.21.7/arch/arm/mach-at91/board-sam9rlek.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/arch/arm/mach-at91/board-sam9rlek.c
@@ -0,0 +1,204 @@
+/*
+ *  Copyright (C) 2005 SAN People
+ *  Copyright (C) 2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/fb.h>
+#include <linux/clk.h>
+
+#include <video/atmel_lcdc.h>
+
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/at91sam926x_mc.h>
+
+#include "generic.h"
+
+
+/*
+ * Serial port configuration.
+ *    0 .. 3 = USART0 .. USART3
+ *    4      = DBGU
+ */
+static struct at91_uart_config __initdata ek_uart_config = {
+	.console_tty	= 0,				/* ttyS0 */
+	.nr_tty		= 2,
+	.tty_map	= { 4, 0, -1, -1, -1 }		/* ttyS0, ..., ttyS4 */
+};
+
+static void __init ek_map_io(void)
+{
+	/* Initialize processor: 12.000 MHz crystal */
+	at91sam9rl_initialize(12000000);
+
+	/* Setup the serial ports and console */
+	at91_init_serial(&ek_uart_config);
+}
+
+static void __init ek_init_irq(void)
+{
+	at91sam9rl_init_interrupts(NULL);
+}
+
+
+/*
+ * MCI (SD/MMC)
+ */
+static struct at91_mmc_data __initdata ek_mmc_data = {
+	.wire4		= 1,
+	.det_pin	= AT91_PIN_PA15,
+//	.wp_pin		= ... not connected
+//	.vcc_pin	= ... not connected
+};
+
+
+/*
+ * NAND flash
+ */
+static struct mtd_partition __initdata ek_nand_partition[] = {
+	{
+		.name	= "Partition 1",
+		.offset	= 0,
+		.size	= 256 * 1024,
+	},
+	{
+		.name	= "Partition 2",
+		.offset	= 256 * 1024 ,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct mtd_partition *nand_partitions(int size, int *num_partitions)
+{
+	*num_partitions = ARRAY_SIZE(ek_nand_partition);
+	return ek_nand_partition;
+}
+
+static struct at91_nand_data __initdata ek_nand_data = {
+	.ale		= 21,
+	.cle		= 22,
+//	.det_pin	= ... not connected
+	.rdy_pin	= AT91_PIN_PD17,
+	.enable_pin	= AT91_PIN_PB6,
+	.partition_info	= nand_partitions,
+	.bus_width_16	= 0,
+};
+
+
+/*
+ * SPI devices
+ */
+static struct spi_board_info ek_spi_devices[] = {
+	{	/* DataFlash chip */
+		.modalias	= "mtd_dataflash",
+		.chip_select	= 0,
+		.max_speed_hz	= 15 * 1000 * 1000,
+		.bus_num	= 0,
+	},
+};
+
+
+/*
+ * LCD Controller
+ */
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
+static struct fb_videomode at91_tft_vga_modes[] = {
+	{
+		.name		= "TX09D50VM1CCA @ 60",
+		.refresh	= 60,
+		.xres		= 240,		.yres		= 320,
+		.pixclock	= KHZ2PICOS(4965),
+
+		.left_margin	= 1,		.right_margin	= 33,
+		.upper_margin	= 1,		.lower_margin	= 0,
+		.hsync_len	= 5,		.vsync_len	= 1,
+
+		.sync		= FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+};
+
+static struct fb_monspecs at91fb_default_monspecs = {
+	.manufacturer	= "HIT",
+	.monitor	= "TX09D50VM1CCA",
+
+	.modedb		= at91_tft_vga_modes,
+	.modedb_len	= ARRAY_SIZE(at91_tft_vga_modes),
+	.hfmin		= 15000,
+	.hfmax		= 64000,
+	.vfmin		= 50,
+	.vfmax		= 150,
+};
+
+#define AT91SAM9RL_DEFAULT_LCDCON2	(ATMEL_LCDC_MEMOR_LITTLE \
+					| ATMEL_LCDC_DISTYPE_TFT \
+					| ATMEL_LCDC_CLKMOD_ALWAYSACTIVE)
+
+static void at91_lcdc_power_control(int on)
+{
+	if (on)
+		at91_set_gpio_value(AT91_PIN_PA30, 0);	/* power up */
+	else
+		at91_set_gpio_value(AT91_PIN_PA30, 1);	/* power down */
+}
+
+/* Driver datas */
+static struct atmel_lcdfb_info __initdata ek_lcdc_data = {
+	.default_bpp			= 16,
+	.default_dmacon			= ATMEL_LCDC_DMAEN,
+	.default_lcdcon2		= AT91SAM9RL_DEFAULT_LCDCON2,
+	.default_monspecs		= &at91fb_default_monspecs,
+	.atmel_lcdfb_power_control	= at91_lcdc_power_control,
+	.guard_time			= 1,
+};
+
+#else
+static struct atmel_lcdfb_info __initdata ek_lcdc_data;
+#endif
+
+
+static void __init ek_board_init(void)
+{
+	/* Serial */
+	at91_add_device_serial();
+	/* I2C */
+	at91_add_device_i2c();
+	/* NAND */
+	at91_add_device_nand(&ek_nand_data);
+	/* SPI */
+	at91_add_device_spi(ek_spi_devices, ARRAY_SIZE(ek_spi_devices));
+	/* MMC */
+	at91_add_device_mmc(0, &ek_mmc_data);
+	/* LCD Controller */
+	at91_add_device_lcdc(&ek_lcdc_data);
+}
+
+MACHINE_START(AT91SAM9RLEK, "Atmel AT91SAM9RL-EK")
+	/* Maintainer: Atmel */
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91sam926x_timer,
+	.map_io		= ek_map_io,
+	.init_irq	= ek_init_irq,
+	.init_machine	= ek_board_init,
+MACHINE_END
Index: linux-2.6.21.7/arch/arm/mach-at91/clock.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/clock.c
+++ linux-2.6.21.7/arch/arm/mach-at91/clock.c
@@ -32,6 +32,7 @@
 #include <asm/arch/cpu.h>
 
 #include "clock.h"
+#include "generic.h"
 
 
 /*
@@ -254,6 +255,23 @@ EXPORT_SYMBOL(clk_get_rate);
 
 /*------------------------------------------------------------------------*/
 
+#ifdef CONFIG_PM
+
+int clk_must_disable(struct clk *clk)
+{
+	if (!at91_suspend_entering_slow_clock())
+		return 0;
+
+	while (clk->parent)
+		clk = clk->parent;
+	return clk != &clk32k;
+}
+EXPORT_SYMBOL(clk_must_disable);
+
+#endif
+
+/*------------------------------------------------------------------------*/
+
 #ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS
 
 /*
@@ -375,6 +393,7 @@ static int at91_clk_show(struct seq_file
 	seq_printf(s, "PLLB = %8x\n", at91_sys_read(AT91_CKGR_PLLBR));
 
 	seq_printf(s, "MCKR = %8x\n", at91_sys_read(AT91_PMC_MCKR));
+#warning "Hard-coded PCK"
 	for (i = 0; i < 4; i++)
 		seq_printf(s, "PCK%d = %8x\n", i, at91_sys_read(AT91_PMC_PCKR(i)));
 	seq_printf(s, "SR   = %8x\n", sr = at91_sys_read(AT91_PMC_SR));
Index: linux-2.6.21.7/arch/arm/mach-at91/generic.h
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/generic.h
+++ linux-2.6.21.7/arch/arm/mach-at91/generic.h
@@ -13,12 +13,14 @@ extern void __init at91rm9200_initialize
 extern void __init at91sam9260_initialize(unsigned long main_clock);
 extern void __init at91sam9261_initialize(unsigned long main_clock);
 extern void __init at91sam9263_initialize(unsigned long main_clock);
+extern void __init at91sam9rl_initialize(unsigned long main_clock);
 
  /* Interrupts */
 extern void __init at91rm9200_init_interrupts(unsigned int priority[]);
 extern void __init at91sam9260_init_interrupts(unsigned int priority[]);
 extern void __init at91sam9261_init_interrupts(unsigned int priority[]);
 extern void __init at91sam9263_init_interrupts(unsigned int priority[]);
+extern void __init at91sam9rl_init_interrupts(unsigned int priority[]);
 extern void __init at91_aic_init(unsigned int priority[]);
 
  /* Timer */
@@ -34,6 +36,7 @@ extern void __init at91_clock_associate(
  /* Power Management */
 extern void at91_irq_suspend(void);
 extern void at91_irq_resume(void);
+extern int at91_suspend_entering_slow_clock(void);
 
  /* GPIO */
 #define AT91RM9200_PQFP		3	/* AT91RM9200 PQFP package has 3 banks */
Index: linux-2.6.21.7/arch/arm/mach-at91/ics1523.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/arch/arm/mach-at91/ics1523.c
@@ -0,0 +1,207 @@
+/*
+ * arch/arm/mach-at91rm9200/ics1523.c
+ *
+ *  Copyright (C) 2003 ATMEL Rousset
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+
+#include <asm/arch/ics1523.h>
+#include <asm/arch/at91_twi.h>
+#include <asm/arch/gpio.h>
+
+/* TWI Errors */
+#define	AT91_TWI_ERROR	(AT91_TWI_NACK | AT91_TWI_UNRE | AT91_TWI_OVRE)
+
+
+static void __iomem *twi_base;
+
+#define at91_twi_read(reg)		__raw_readl(twi_base + (reg))
+#define at91_twi_write(reg, val)	__raw_writel((val), twi_base + (reg))
+
+
+/* -----------------------------------------------------------------------------
+ * Initialization of TWI CLOCK
+ * ----------------------------------------------------------------------------- */
+
+static void at91_ics1523_SetTwiClock(unsigned int mck_khz)
+{
+	int sclock;
+
+	/* Here, CKDIV = 1 and CHDIV = CLDIV  ==> CLDIV = CHDIV = 1/4*((Fmclk/FTWI) -6) */
+	sclock = (10*mck_khz / ICS_TRANSFER_RATE);
+	if (sclock % 10 >= 5)
+		sclock = (sclock /10) - 5;
+	else
+		sclock = (sclock /10)- 6;
+	sclock = (sclock + (4 - sclock %4)) >> 2;	/* div 4 */
+
+	at91_twi_write(AT91_TWI_CWGR, 0x00010000 | sclock | (sclock << 8));
+}
+
+/* -----------------------------------------------------------------------------
+ * Read a byte with TWI Interface from the Clock Generator ICS1523
+ * ----------------------------------------------------------------------------- */
+
+static int at91_ics1523_ReadByte(unsigned char reg_address, unsigned char *data_in)
+{
+	int Status, nb_trial;
+
+	at91_twi_write(AT91_TWI_MMR, AT91_TWI_MREAD | AT91_TWI_IADRSZ_1 | ((ICS_ADDR << 16) & AT91_TWI_DADR));
+	at91_twi_write(AT91_TWI_IADR, reg_address);
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_START | AT91_TWI_STOP);
+
+	/* Program temporizing period (300us) */
+	udelay(300);
+
+	/* Wait TXcomplete ... */
+	nb_trial = 0;
+	Status = at91_twi_read(AT91_TWI_SR);
+	while (!(Status & AT91_TWI_TXCOMP) && (nb_trial < 10)) {
+		nb_trial++;
+		Status = at91_twi_read(AT91_TWI_SR);
+	}
+
+	if (Status & AT91_TWI_TXCOMP) {
+		*data_in = (unsigned char) at91_twi_read(AT91_TWI_RHR);
+		return ICS1523_ACCESS_OK;
+	}
+	else
+		return ICS1523_ACCESS_ERROR;
+}
+
+/* -----------------------------------------------------------------------------
+ * Write a byte with TWI Interface to the Clock Generator ICS1523
+ * ----------------------------------------------------------------------------- */
+
+static int at91_ics1523_WriteByte(unsigned char reg_address, unsigned char data_out)
+{
+	int Status, nb_trial;
+
+	at91_twi_write(AT91_TWI_MMR, AT91_TWI_IADRSZ_1 | ((ICS_ADDR << 16) & AT91_TWI_DADR));
+	at91_twi_write(AT91_TWI_IADR, reg_address);
+	at91_twi_write(AT91_TWI_THR, data_out);
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_START | AT91_TWI_STOP);
+
+	/* Program temporizing period (300us) */
+	udelay(300);
+
+	nb_trial = 0;
+	Status = at91_twi_read(AT91_TWI_SR);
+	while (!(Status & AT91_TWI_TXCOMP) && (nb_trial < 10)) {
+		nb_trial++;
+		if (Status & AT91_TWI_ERROR) {
+			/* If Underrun OR NACK - Start again */
+			at91_twi_write(AT91_TWI_CR, AT91_TWI_START | AT91_TWI_STOP);
+
+			/*  Program temporizing period (300us) */
+			udelay(300);
+		}
+		Status = at91_twi_read(AT91_TWI_SR);
+	};
+
+	if (Status & AT91_TWI_TXCOMP)
+		return ICS1523_ACCESS_OK;
+	else
+		return ICS1523_ACCESS_ERROR;
+}
+
+/* -----------------------------------------------------------------------------
+ * Initialization of the Clock Generator ICS1523
+ * ----------------------------------------------------------------------------- */
+
+int at91_ics1523_init(void)
+{
+	int		nb_trial;
+	int		ack = ICS1523_ACCESS_OK;
+	unsigned int	status = 0xffffffff;
+	struct clk	*twi_clk;
+
+	/* Map in TWI peripheral */
+	twi_base = ioremap(AT91RM9200_BASE_TWI, SZ_16K);
+	if (!twi_base)
+		return -ENOMEM;
+
+	/* pins used for TWI interface */
+	at91_set_A_periph(AT91_PIN_PA25, 0);            /* TWD */
+	at91_set_multi_drive(AT91_PIN_PA25, 1);
+	at91_set_A_periph(AT91_PIN_PA26, 0);            /* TWCK */
+	at91_set_multi_drive(AT91_PIN_PA26, 1);
+
+	/* Enable the TWI clock */
+	twi_clk = clk_get(NULL, "twi_clk");
+	if (IS_ERR(twi_clk))
+		return ICS1523_ACCESS_ERROR;
+	clk_enable(twi_clk);
+
+	/* Disable interrupts */
+	at91_twi_write(AT91_TWI_IDR, -1);
+
+	/* Reset peripheral */
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_SWRST);
+
+	/* Set Master mode */
+	at91_twi_write(AT91_TWI_CR, AT91_TWI_MSEN);
+
+	/* Set TWI Clock Waveform Generator Register */
+	at91_ics1523_SetTwiClock(60000);     /* MCK in KHz = 60000 KHz */
+
+	/* ICS1523 Initialisation */
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_ICR, (unsigned char) 0);
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_OE, (unsigned char) (ICS_OEF | ICS_OET2 | ICS_OETCK));
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_OD, (unsigned char) (ICS_INSEL | 0x7F));
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_DPAO, (unsigned char) 0);
+
+	nb_trial = 0;
+	do {
+		nb_trial++;
+		ack |= at91_ics1523_WriteByte ((unsigned char) ICS_ICR, (unsigned char) (ICS_ENDLS | ICS_ENPLS | ICS_PDEN /*| ICS_FUNCSEL*/));
+		ack |= at91_ics1523_WriteByte ((unsigned char) ICS_LCR, (unsigned char) (ICS_PSD | ICS_PFD));
+		ack |= at91_ics1523_WriteByte ((unsigned char) ICS_FD0, (unsigned char) 0x39) ; /* 0x7A */
+		ack |= at91_ics1523_WriteByte ((unsigned char) ICS_FD1, (unsigned char) 0x00);
+		ack |= at91_ics1523_WriteByte ((unsigned char) ICS_SWRST, (unsigned char) (ICS_PLLR));
+
+		/* Program 1ms temporizing period */
+		mdelay(1);
+
+		at91_ics1523_ReadByte ((unsigned char) ICS_SR, (char *)&status);
+	} while (!((unsigned int) status & (unsigned int) ICS_PLLLOCK) && (nb_trial < 10));
+
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_DPAC, (unsigned char) 0x03) ; /* 0x01 */
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_SWRST, (unsigned char) (ICS_DPAR));
+
+	/* Program 1ms temporizing period */
+	mdelay(1);
+
+	ack |= at91_ics1523_WriteByte ((unsigned char) ICS_DPAO, (unsigned char) 0x00);
+
+	/* Program 1ms temporizing period */
+	mdelay(1);
+	
+	/* All done - cleanup */
+	iounmap(twi_base);
+	clk_disable(twi_clk);
+	clk_put(twi_clk);
+
+	return ack;
+}
Index: linux-2.6.21.7/arch/arm/mach-at91/pm.c
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mach-at91/pm.c
+++ linux-2.6.21.7/arch/arm/mach-at91/pm.c
@@ -63,6 +63,7 @@ static int at91_pm_prepare(suspend_state
  * Verify that all the clocks are correct before entering
  * slow-clock mode.
  */
+#warning "SAM9260 only has 3 programmable clocks."
 static int at91_pm_verify_clocks(void)
 {
 	unsigned long scsr;
@@ -104,20 +105,15 @@ static int at91_pm_verify_clocks(void)
 }
 
 /*
- * Call this from platform driver suspend() to see how deeply to suspend.
+ * This is called from clk_must_disable(), to see how deeply to suspend.
  * For example, some controllers (like OHCI) need one of the PLL clocks
  * in order to act as a wakeup source, and those are not available when
  * going into slow clock mode.
- *
- * REVISIT: generalize as clk_will_be_available(clk)?  Other platforms have
- * the very same problem (but not using at91 main_clk), and it'd be better
- * to add one generic API rather than lots of platform-specific ones.
  */
 int at91_suspend_entering_slow_clock(void)
 {
 	return (target_state == PM_SUSPEND_MEM);
 }
-EXPORT_SYMBOL(at91_suspend_entering_slow_clock);
 
 
 static void (*slow_clock)(void);
@@ -207,16 +203,23 @@ static struct pm_ops at91_pm_ops ={
 	.enter		= at91_pm_enter,
 };
 
+#ifdef CONFIG_AT91_SLOW_CLOCK
+extern void at91rm9200_slow_clock(void);
+extern u32 at91rm9200_slow_clock_sz;
+#endif
+
 static int __init at91_pm_init(void)
 {
-	printk("AT91: Power Management\n");
-
-#ifdef CONFIG_AT91_PM_SLOW_CLOCK
-	/* REVISIT allocations of SRAM should be dynamically managed.
+#ifdef CONFIG_AT91_SLOW_CLOCK
+	/*
+	 * REVISIT allocations of SRAM should be dynamically managed.
 	 * FIQ handlers and other components will want SRAM/TCM too...
 	 */
-	slow_clock = (void *) (AT91_VA_BASE_SRAM + (3 * SZ_4K));
+	slow_clock = (void *) (AT91_IO_VIRT_BASE - AT91RM9200_SRAM_SIZE + (3 * SZ_4K));
 	memcpy(slow_clock, at91rm9200_slow_clock, at91rm9200_slow_clock_sz);
+	printk("AT91: Power Management (with slow clock mode)\n");
+#else
+	printk("AT91: Power Management\n");
 #endif
 
 	/* Disable SDRAM low-power mode.  Cannot be used with self-refresh. */
Index: linux-2.6.21.7/arch/arm/mach-at91/pm_slowclock.S
===================================================================
--- /dev/null
+++ linux-2.6.21.7/arch/arm/mach-at91/pm_slowclock.S
@@ -0,0 +1,172 @@
+/*
+ * arch/arm/mach-at91/pm_slow_clock.S
+ *
+ *  Copyright (C) 2006 Savin Zlobec
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/linkage.h>
+#include <asm/hardware.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/at91rm9200_mc.h>
+
+#define MCKRDY_TIMEOUT		1000
+#define MOSCRDY_TIMEOUT 	1000
+#define PLLALOCK_TIMEOUT	1000
+
+	.macro wait_mckrdy
+	mov	r2, #MCKRDY_TIMEOUT
+1:	sub	r2, r2, #1
+	cmp	r2, #0
+	beq	2f
+	ldr	r3, [r1, #AT91_PMC_SR]
+	tst	r3, #AT91_PMC_MCKRDY
+	beq	1b
+2:
+	.endm
+
+	.macro wait_moscrdy
+	mov	r2, #MOSCRDY_TIMEOUT
+1:	sub	r2, r2, #1
+	cmp	r2, #0
+	beq	2f
+	ldr	r3, [r1, #AT91_PMC_SR]
+	tst	r3, #AT91_PMC_MOSCS
+	beq	1b
+2:
+	.endm
+
+	.macro wait_pllalock
+	mov	r2, #PLLALOCK_TIMEOUT
+1:	sub	r2, r2, #1
+	cmp	r2, #0
+	beq	2f
+	ldr	r3, [r1, #AT91_PMC_SR]
+	tst	r3, #AT91_PMC_LOCKA
+	beq	1b
+2:
+	.endm
+
+	.macro wait_plladis
+	mov	r2, #PLLALOCK_TIMEOUT
+1:	sub	r2, r2, #1
+	cmp	r2, #0
+	beq	2f
+	ldr	r3, [r1, #AT91_PMC_SR]
+	tst	r3, #AT91_PMC_LOCKA
+	bne	1b
+2:
+	.endm
+
+	.text
+
+ENTRY(at91rm9200_slow_clock)
+
+	ldr	r1, .at91_va_base_sys
+
+	/* Put SDRAM in self refresh mode */
+
+	b	1f
+	.align	5
+1:	mcr	p15, 0, r0, c7, c10, 4
+	mov	r2, #1
+	str	r2, [r1, #AT91_SDRAMC_SRR]
+
+	/* Save Master clock setting */
+
+	ldr	r2, [r1, #AT91_PMC_MCKR]
+	str	r2, .saved_mckr
+
+	/*
+	 * Set the Master clock source to slow clock
+	 *
+	 * First set the CSS field, wait for MCKRDY
+	 * and than set the PRES and MDIV fields.
+	 *
+	 * See eratta #2[78] for details.
+	 */
+
+	bic	r2, r2, #3
+	str	r2, [r1, #AT91_PMC_MCKR]
+
+	wait_mckrdy
+
+	mov	r2, #0
+	str	r2, [r1, #AT91_PMC_MCKR]
+
+	/* Save PLLA setting and disable it */
+
+	ldr	r2, [r1, #AT91_CKGR_PLLAR]
+	str	r2, .saved_pllar
+
+	mov	r2, #0
+	str	r2, [r1, #AT91_CKGR_PLLAR]
+
+	wait_plladis
+
+	/* Turn off the main oscillator */
+
+	ldr	r2, [r1, #AT91_CKGR_MOR]
+	bic	r2, r2, #AT91_PMC_MOSCEN
+	str	r2, [r1, #AT91_CKGR_MOR]
+
+	/* Wait for interrupt */
+
+	mcr	p15, 0, r0, c7, c0, 4
+
+	/* Turn on the main oscillator */
+
+	ldr	r2, [r1, #AT91_CKGR_MOR]
+	orr	r2, r2, #AT91_PMC_MOSCEN
+	str	r2, [r1, #AT91_CKGR_MOR]
+
+	wait_moscrdy
+
+	/* Restore PLLA setting */
+
+	ldr	r2, .saved_pllar
+	str	r2, [r1, #AT91_CKGR_PLLAR]
+
+	wait_pllalock
+
+	/*
+	 * Restore master clock setting
+	 *
+	 * First set PRES if it was not 0,
+	 * than set CSS and MDIV fields.
+	 * After every change wait for
+	 * MCKRDY.
+	 *
+	 * See eratta #2[78] for details.
+	 */
+
+	ldr	r2, .saved_mckr
+	tst	r2, #0x1C
+	beq	2f
+	and	r2, r2, #0x1C
+	str	r2, [r1, #AT91_PMC_MCKR]
+
+	wait_mckrdy
+
+2:	ldr	r2, .saved_mckr
+	str	r2, [r1, #AT91_PMC_MCKR]
+
+	wait_mckrdy
+
+	mov	pc, lr
+
+.saved_mckr:
+	.word 0
+
+.saved_pllar:
+	.word 0
+
+.at91_va_base_sys:
+	.word AT91_VA_BASE_SYS
+
+ENTRY(at91rm9200_slow_clock_sz)
+	.word .-at91rm9200_slow_clock
Index: linux-2.6.21.7/arch/arm/mach-at91/tclib.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/arch/arm/mach-at91/tclib.c
@@ -0,0 +1,17 @@
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include "tclib.h"
+
+static struct atmel_tcblock *blocks;
+static int nblocks;
+
+/*
+ * Called from the processor-specific init to register the TC Blocks.
+ */
+void __init atmel_tc_init(struct atmel_tcblock *tcblocks, int n)
+{
+	blocks = tcblocks;
+	nblocks = n;
+}
Index: linux-2.6.21.7/arch/arm/mach-at91/tclib.h
===================================================================
--- /dev/null
+++ linux-2.6.21.7/arch/arm/mach-at91/tclib.h
@@ -0,0 +1,11 @@
+
+#define TC_PER_TCB	3
+
+struct atmel_tcblock {
+	u32 		physaddr;
+	void __iomem	*ioaddr;
+	struct clk	*clk[TC_PER_TCB];
+	int		irq[TC_PER_TCB];
+};
+
+extern void __init atmel_tc_init(struct atmel_tcblock *tcblocks, int n);
Index: linux-2.6.21.7/arch/arm/mm/Kconfig
===================================================================
--- linux-2.6.21.7.orig/arch/arm/mm/Kconfig
+++ linux-2.6.21.7/arch/arm/mm/Kconfig
@@ -171,8 +171,8 @@ config CPU_ARM925T
 # ARM926T
 config CPU_ARM926T
 	bool "Support ARM926T processor"
-	depends on ARCH_INTEGRATOR || ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || MACH_REALVIEW_EB || ARCH_PNX4008 || ARCH_NETX || CPU_S3C2412 || ARCH_AT91SAM9260 || ARCH_AT91SAM9261 || ARCH_AT91SAM9263 || ARCH_NS9XXX
-	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || ARCH_PNX4008 || ARCH_NETX || CPU_S3C2412 || ARCH_AT91SAM9260 || ARCH_AT91SAM9261 || ARCH_AT91SAM9263 || ARCH_NS9XXX
+	depends on ARCH_INTEGRATOR || ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || MACH_REALVIEW_EB || ARCH_PNX4008 || ARCH_NETX || CPU_S3C2412 || ARCH_AT91SAM9260 || ARCH_AT91SAM9261 || ARCH_AT91SAM9263 || ARCH_AT91SAM9RL || ARCH_NS9XXX
+	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || ARCH_PNX4008 || ARCH_NETX || CPU_S3C2412 || ARCH_AT91SAM9260 || ARCH_AT91SAM9261 || ARCH_AT91SAM9263 || ARCH_AT91SAM9RL || ARCH_NS9XXX
 	select CPU_32v5
 	select CPU_ABRT_EV5TJ
 	select CPU_CACHE_VIVT
Index: linux-2.6.21.7/arch/arm/tools/mach-types
===================================================================
--- linux-2.6.21.7.orig/arch/arm/tools/mach-types
+++ linux-2.6.21.7/arch/arm/tools/mach-types
@@ -1335,3 +1335,32 @@ at91sam9rlek		MACH_AT91SAM9RLEK	AT91SAM9
 comtech_router		MACH_COMTECH_ROUTER	COMTECH_ROUTER		1327
 sbc2410x		MACH_SBC2410X		SBC2410X		1328
 at4x0bd			MACH_AT4X0BD		AT4X0BD			1329
+cbifr			MACH_CBIFR		CBIFR			1330
+arcom_quantum		MACH_ARCOM_QUANTUM	ARCOM_QUANTUM		1331
+matrix520		MACH_MATRIX520		MATRIX520		1332
+matrix510		MACH_MATRIX510		MATRIX510		1333
+matrix500		MACH_MATRIX500		MATRIX500		1334
+m501			MACH_M501		M501			1335
+aaeon1270		MACH_AAEON1270		AAEON1270		1336
+matrix500ev		MACH_MATRIX500EV	MATRIX500EV		1337
+pac500			MACH_PAC500		PAC500			1338
+pnx8181			MACH_PNX8181		PNX8181			1339
+colibri320		MACH_COLIBRI320		COLIBRI320		1340
+aztoolbb		MACH_AZTOOLBB		AZTOOLBB		1341
+aztoolg2		MACH_AZTOOLG2		AZTOOLG2		1342
+dvlhost			MACH_DVLHOST		DVLHOST			1343
+zir9200			MACH_ZIR9200		ZIR9200			1344
+zir9260			MACH_ZIR9260		ZIR9260			1345
+cocopah			MACH_COCOPAH		COCOPAH			1346
+nds			MACH_NDS		NDS			1347
+rosencrantz		MACH_ROSENCRANTZ	ROSENCRANTZ		1348
+fttx_odsc		MACH_FTTX_ODSC		FTTX_ODSC		1349
+classe_r6904		MACH_CLASSE_R6904	CLASSE_R6904		1350
+cam60			MACH_CAM60		CAM60			1351
+mxc30031ads		MACH_MXC30031ADS	MXC30031ADS		1352
+datacall		MACH_DATACALL		DATACALL		1353
+at91eb01		MACH_AT91EB01		AT91EB01		1354
+rty			MACH_RTY		RTY			1355
+dwl2100			MACH_DWL2100		DWL2100			1356
+vinsi			MACH_VINSI		VINSI			1357
+db88f5281		MACH_DB88F5281		DB88F5281		1358
Index: linux-2.6.21.7/drivers/char/Kconfig
===================================================================
--- linux-2.6.21.7.orig/drivers/char/Kconfig
+++ linux-2.6.21.7/drivers/char/Kconfig
@@ -1071,5 +1071,21 @@ config TELCLOCK
 	  /sys/devices/platform/telco_clock, with a number of files for
 	  controlling the behavior of this hardware.
 
+config AT91_SPI
+	bool "SPI driver (legacy) for AT91RM9200 processors"
+	depends on ARCH_AT91RM9200
+	default y
+	help
+	  The SPI driver gives access to this serial bus on the AT91RM9200
+	  processor.
+
+config AT91_SPIDEV
+	bool "SPI device interface (legacy) for AT91RM9200 processors"
+	depends on ARCH_AT91RM9200 && AT91_SPI
+	default n
+	help
+	  The SPI driver gives user mode access to this serial
+	  bus on the AT91RM9200 processor.
+
 endmenu
 
Index: linux-2.6.21.7/drivers/char/Makefile
===================================================================
--- linux-2.6.21.7.orig/drivers/char/Makefile
+++ linux-2.6.21.7/drivers/char/Makefile
@@ -93,6 +93,8 @@ obj-$(CONFIG_CS5535_GPIO)	+= cs5535_gpio
 obj-$(CONFIG_GPIO_VR41XX)	+= vr41xx_giu.o
 obj-$(CONFIG_TANBAC_TB0219)	+= tb0219.o
 obj-$(CONFIG_TELCLOCK)		+= tlclk.o
+obj-$(CONFIG_AT91_SPI)		+= at91_spi.o
+obj-$(CONFIG_AT91_SPIDEV)	+= at91_spidev.o
 
 obj-$(CONFIG_WATCHDOG)		+= watchdog/
 obj-$(CONFIG_MWAVE)		+= mwave/
Index: linux-2.6.21.7/drivers/char/at91_spi.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/drivers/char/at91_spi.c
@@ -0,0 +1,336 @@
+/*
+ * Serial Peripheral Interface (SPI) driver for the Atmel AT91RM9200 (Thunder)
+ *
+ *  Copyright (C) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/completion.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/atmel_pdc.h>
+#include <asm/io.h>
+#include <asm/semaphore.h>
+
+#include <asm/arch/at91_spi.h>
+#include <asm/arch/board.h>
+#include <asm/arch/spi.h>
+
+#undef DEBUG_SPI
+
+static struct spi_local spi_dev[NR_SPI_DEVICES];	/* state of the SPI devices */
+static int spi_enabled = 0;
+static struct semaphore spi_lock;			/* protect access to SPI bus */
+static int current_device = -1;				/* currently selected SPI device */
+static struct clk *spi_clk;				/* SPI clock */
+static void __iomem *spi_base;				/* SPI peripheral base-address */
+
+DECLARE_COMPLETION(transfer_complete);
+
+
+#define at91_spi_read(reg)		__raw_readl(spi_base + (reg))
+#define at91_spi_write(reg, val)	__raw_writel((val), spi_base + (reg))
+
+
+/* ......................................................................... */
+
+/*
+ * Access and enable the SPI bus.
+ * This MUST be called before any transfers are performed.
+ */
+void spi_access_bus(short device)
+{
+	/* Ensure that requested device is valid */
+	if ((device < 0) || (device >= NR_SPI_DEVICES))
+		panic("at91_spi: spi_access_bus called with invalid device");
+
+	if (spi_enabled == 0) {
+		clk_enable(spi_clk);				/* Enable Peripheral clock */
+		at91_spi_write(AT91_SPI_CR, AT91_SPI_SPIEN);	/* Enable SPI */
+#ifdef DEBUG_SPI
+		printk("SPI on\n");
+#endif
+	}
+	spi_enabled++;
+
+	/* Lock the SPI bus */
+	down(&spi_lock);
+	current_device = device;
+
+	/* Configure SPI bus for device */
+	at91_spi_write(AT91_SPI_MR, AT91_SPI_MSTR | AT91_SPI_MODFDIS | (spi_dev[device].pcs << 16));
+}
+
+/*
+ * Relinquish control of the SPI bus.
+ */
+void spi_release_bus(short device)
+{
+	if (device != current_device)
+		panic("at91_spi: spi_release called with invalid device");
+
+	/* Release the SPI bus */
+	current_device = -1;
+	up(&spi_lock);
+
+	spi_enabled--;
+	if (spi_enabled == 0) {
+		at91_spi_write(AT91_SPI_CR, AT91_SPI_SPIDIS);	/* Disable SPI */
+		clk_disable(spi_clk);				/* Disable Peripheral clock */
+#ifdef DEBUG_SPI
+		printk("SPI off\n");
+#endif
+	}
+}
+
+/*
+ * Perform a data transfer over the SPI bus
+ */
+int spi_transfer(struct spi_transfer_list* list)
+{
+	struct spi_local *device = (struct spi_local *) &spi_dev[current_device];
+	int tx_size;
+
+	if (!list)
+		panic("at91_spi: spi_transfer called with NULL transfer list");
+	if (current_device == -1)
+		panic("at91_spi: spi_transfer called without acquiring bus");
+
+#ifdef DEBUG_SPI
+	printk("SPI transfer start [%i]\n", list->nr_transfers);
+#endif
+
+	/* If we are in 16-bit mode, we need to modify what we pass to the PDC */
+	tx_size = (at91_spi_read(AT91_SPI_CSR(current_device)) & AT91_SPI_BITS_16) ? 2 : 1;
+
+	/* Store transfer list */
+	device->xfers = list;
+	list->curr = 0;
+
+	/* Assume there must be at least one transfer */
+	device->tx = dma_map_single(NULL, list->tx[0], list->txlen[0], DMA_TO_DEVICE);
+	device->rx = dma_map_single(NULL, list->rx[0], list->rxlen[0], DMA_FROM_DEVICE);
+
+	/* Program PDC registers */
+	at91_spi_write(ATMEL_PDC_TPR, device->tx);
+	at91_spi_write(ATMEL_PDC_RPR, device->rx);
+	at91_spi_write(ATMEL_PDC_TCR, list->txlen[0] / tx_size);
+	at91_spi_write(ATMEL_PDC_RCR, list->rxlen[0] / tx_size);
+
+	/* Is there a second transfer? */
+	if (list->nr_transfers > 1) {
+		device->txnext = dma_map_single(NULL, list->tx[1], list->txlen[1], DMA_TO_DEVICE);
+		device->rxnext = dma_map_single(NULL, list->rx[1], list->rxlen[1], DMA_FROM_DEVICE);
+
+		/* Program Next PDC registers */
+		at91_spi_write(ATMEL_PDC_TNPR, device->txnext);
+		at91_spi_write(ATMEL_PDC_RNPR, device->rxnext);
+		at91_spi_write(ATMEL_PDC_TNCR, list->txlen[1] / tx_size);
+		at91_spi_write(ATMEL_PDC_RNCR, list->rxlen[1] / tx_size);
+	}
+	else {
+		device->txnext = 0;
+		device->rxnext = 0;
+		at91_spi_write(ATMEL_PDC_TNCR, 0);
+		at91_spi_write(ATMEL_PDC_RNCR, 0);
+	}
+
+	// TODO: If we are doing consecutive transfers (at high speed, or
+	//   small buffers), then it might be worth modifying the 'Delay between
+	//   Consecutive Transfers' in the CSR registers.
+	//   This is an issue if we cannot chain the next buffer fast enough
+	//   in the interrupt handler.
+
+	/* Enable transmitter and receiver */
+	at91_spi_write(ATMEL_PDC_PTCR, ATMEL_PDC_RXTEN | ATMEL_PDC_TXTEN);
+
+	at91_spi_write(AT91_SPI_IER, AT91_SPI_ENDRX);		/* enable buffer complete interrupt */
+	wait_for_completion(&transfer_complete);
+
+#ifdef DEBUG_SPI
+	printk("SPI transfer end\n");
+#endif
+
+	return 0;
+}
+
+/* ......................................................................... */
+
+/*
+ * Handle interrupts from the SPI controller.
+ */
+static irqreturn_t at91spi_interrupt(int irq, void *dev_id)
+{
+	unsigned int status;
+	struct spi_local *device = (struct spi_local *) &spi_dev[current_device];
+	struct spi_transfer_list *list = device->xfers;
+
+#ifdef DEBUG_SPI
+	printk("SPI interrupt %i\n", current_device);
+#endif
+
+	if (!list)
+		panic("at91_spi: spi_interrupt with a NULL transfer list");
+
+		status = at91_spi_read(AT91_SPI_SR) & at91_spi_read(AT91_SPI_IMR);	/* read status */
+
+	dma_unmap_single(NULL, device->tx, list->txlen[list->curr], DMA_TO_DEVICE);
+	dma_unmap_single(NULL, device->rx, list->rxlen[list->curr], DMA_FROM_DEVICE);
+
+	device->tx = device->txnext;	/* move next transfer to current transfer */
+	device->rx = device->rxnext;
+
+	list->curr = list->curr + 1;
+	if (list->curr == list->nr_transfers) {		/* all transfers complete */
+		at91_spi_write(AT91_SPI_IDR, AT91_SPI_ENDRX);		/* disable interrupt */
+
+		/* Disable transmitter and receiver */
+		at91_spi_write(ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS);
+
+		device->xfers = NULL;
+		complete(&transfer_complete);
+	}
+	else if (list->curr+1 == list->nr_transfers) {	/* no more next transfers */
+		device->txnext = 0;
+		device->rxnext = 0;
+		at91_spi_write(ATMEL_PDC_TNCR, 0);
+		at91_spi_write(ATMEL_PDC_RNCR, 0);
+	}
+	else {
+		int i = (list->curr)+1;
+
+		/* If we are in 16-bit mode, we need to modify what we pass to the PDC */
+		int tx_size = (at91_spi_read(AT91_SPI_CSR(current_device)) & AT91_SPI_BITS_16) ? 2 : 1;
+
+		device->txnext = dma_map_single(NULL, list->tx[i], list->txlen[i], DMA_TO_DEVICE);
+		device->rxnext = dma_map_single(NULL, list->rx[i], list->rxlen[i], DMA_FROM_DEVICE);
+		at91_spi_write(ATMEL_PDC_TNPR, device->txnext);
+		at91_spi_write(ATMEL_PDC_RNPR, device->rxnext);
+		at91_spi_write(ATMEL_PDC_TNCR, list->txlen[i] / tx_size);
+		at91_spi_write(ATMEL_PDC_RNCR, list->rxlen[i] / tx_size);
+	}
+	return IRQ_HANDLED;
+}
+
+/* ......................................................................... */
+
+/*
+ * Initialize the SPI controller
+ */
+static int __init at91spi_probe(struct platform_device *pdev)
+{
+	int i;
+	unsigned long scbr;
+	struct resource *res;
+
+	init_MUTEX(&spi_lock);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENXIO;
+
+	if (!request_mem_region(res->start, res->end - res->start + 1, "at91_spi"))
+		return -EBUSY;
+
+	spi_base = ioremap(res->start, res->end - res->start + 1);
+	if (!spi_base) {
+		release_mem_region(res->start, res->end - res->start + 1);
+		return -ENOMEM;
+	}
+
+	spi_clk = clk_get(NULL, "spi_clk");
+	if (IS_ERR(spi_clk)) {
+		printk(KERN_ERR "at91_spi: no clock defined\n");
+		iounmap(spi_base);
+		release_mem_region(res->start, res->end - res->start + 1);
+		return -ENODEV;
+	}
+
+	at91_spi_write(AT91_SPI_CR, AT91_SPI_SWRST);	/* software reset of SPI controller */
+
+	/*
+	 * Calculate the correct SPI baud-rate divisor.
+	 */
+	scbr = clk_get_rate(spi_clk) / (2 * DEFAULT_SPI_CLK);
+	scbr = scbr + 1;		/* round up */
+
+	printk(KERN_INFO "at91_spi: Baud rate set to %ld\n", clk_get_rate(spi_clk) / (2 * scbr));
+
+	/* Set Chip Select registers to good defaults */
+	for (i = 0; i < 4; i++) {
+		at91_spi_write(AT91_SPI_CSR(i), AT91_SPI_CPOL | AT91_SPI_BITS_8 | (16 << 16) | (scbr << 8));
+	}
+
+	at91_spi_write(ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS);
+
+	memset(&spi_dev, 0, sizeof(spi_dev));
+	spi_dev[0].pcs = 0xE;
+	spi_dev[1].pcs = 0xD;
+	spi_dev[2].pcs = 0xB;
+	spi_dev[3].pcs = 0x7;
+
+	if (request_irq(AT91RM9200_ID_SPI, at91spi_interrupt, 0, "spi", NULL)) {
+		clk_put(spi_clk);
+		iounmap(spi_base);
+		release_mem_region(res->start, res->end - res->start + 1);
+		return -EBUSY;
+	}
+
+	at91_spi_write(AT91_SPI_CR, AT91_SPI_SPIEN);		/* Enable SPI */
+
+	return 0;
+}
+
+static int __devexit at91spi_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	at91_spi_write(AT91_SPI_CR, AT91_SPI_SPIDIS);		/* Disable SPI */
+	clk_put(spi_clk);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	iounmap(spi_base);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	free_irq(AT91RM9200_ID_SPI, 0);
+	return 0;
+}
+
+static struct platform_driver at91spi_driver = {
+	.probe		= at91spi_probe,
+	.remove		= __devexit_p(at91spi_remove),
+	.driver		= {
+		.name	= "at91_spi",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init at91spi_init(void)
+{
+	return platform_driver_register(&at91spi_driver);
+}
+
+static void __exit at91spi_exit(void)
+{
+	platform_driver_unregister(&at91spi_driver);
+}
+
+EXPORT_SYMBOL(spi_access_bus);
+EXPORT_SYMBOL(spi_release_bus);
+EXPORT_SYMBOL(spi_transfer);
+
+module_init(at91spi_init);
+module_exit(at91spi_exit);
+
+MODULE_LICENSE("GPL")
+MODULE_AUTHOR("Andrew Victor")
+MODULE_DESCRIPTION("SPI driver for Atmel AT91RM9200")
Index: linux-2.6.21.7/drivers/char/at91_spidev.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/drivers/char/at91_spidev.c
@@ -0,0 +1,236 @@
+/*
+ * User-space interface to the SPI bus on Atmel AT91RM9200
+ *
+ *  Copyright (C) 2003 SAN People (Pty) Ltd
+ *
+ * Based on SPI driver by Rick Bronson
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/highmem.h>
+#include <linux/pagemap.h>
+#include <asm/arch/spi.h>
+
+#ifdef CONFIG_DEVFS_FS
+#include <linux/devfs_fs_kernel.h>
+#endif
+
+
+#undef DEBUG_SPIDEV
+
+/* ......................................................................... */
+
+/*
+ * Read or Write to SPI bus.
+ */
+static ssize_t spidev_rd_wr(struct file *file, char *buf, size_t count, loff_t *offset)
+{
+	unsigned int spi_device = (unsigned int) file->private_data;
+
+	struct mm_struct * mm;
+	struct page ** maplist;
+	struct spi_transfer_list* list;
+	int    pgcount;
+
+	unsigned int ofs, pagelen;
+	int res, i, err;
+
+	if (!count) {
+		return 0;
+	}
+
+	list = kmalloc(sizeof(struct spi_transfer_list), GFP_KERNEL);
+	if (!list) {
+		return -ENOMEM;
+	}
+
+	mm = current->mm;
+
+	pgcount = ((unsigned long)buf+count+PAGE_SIZE-1)/PAGE_SIZE - (unsigned long)buf/PAGE_SIZE;
+
+	if (pgcount >= MAX_SPI_TRANSFERS) {
+		kfree(list);
+		return -EFBIG;
+	}
+
+	maplist = kmalloc (pgcount * sizeof (struct page *), GFP_KERNEL);
+
+	if (!maplist) {
+		kfree(list);
+		return -ENOMEM;
+	}
+	flush_cache_all();
+	down_read(&mm->mmap_sem);
+	err= get_user_pages(current, mm, (unsigned long)buf, pgcount, 1, 0, maplist, NULL);
+	up_read(&mm->mmap_sem);
+
+	if (err < 0) {
+		kfree(list);
+		kfree(maplist);
+		return err;
+	}
+	pgcount = err;
+
+#ifdef DEBUG_SPIDEV
+	printk("spidev_rd_rw: %i %i\n", count, pgcount);
+#endif
+
+	/* Set default return value = transfer length */
+	res = count;
+
+	/*
+	 * At this point, the virtual area buf[0] .. buf[count-1] will have
+	 * corresponding pages mapped in the physical memory and locked until
+	 * we unmap the kiobuf.  The pages cannot be swapped out or moved
+	 * around.
+	 */
+	ofs = (unsigned long) buf & (PAGE_SIZE -1);
+	pagelen = PAGE_SIZE - ofs;
+	if (count < pagelen)
+		pagelen = count;
+
+	for (i = 0; i < pgcount; i++) {
+		flush_dcache_page(maplist[i]);
+
+		list->tx[i] = list->rx[i] = page_address(maplist[i]) + ofs;
+		list->txlen[i] = list->rxlen[i] = pagelen;
+
+#ifdef DEBUG_SPIDEV
+		printk("  %i: %x  (%i)\n", i, list->tx[i], list->txlen[i]);
+#endif
+
+		ofs = 0;	/* all subsequent transfers start at beginning of a page */
+		count = count - pagelen;
+		pagelen = (count < PAGE_SIZE) ? count : PAGE_SIZE;
+	}
+	list->nr_transfers = pgcount;
+
+	/* Perform transfer on SPI bus */
+	spi_access_bus(spi_device);
+	spi_transfer(list);
+	spi_release_bus(spi_device);
+
+	while (pgcount--) {
+		page_cache_release (maplist[pgcount]);
+	}
+	flush_cache_all();
+
+	kfree(maplist);
+	kfree(list);
+
+	return res;
+}
+
+static int spidev_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int spi_device = MINOR(inode->i_rdev);
+
+	if (spi_device >= NR_SPI_DEVICES)
+		return -ENODEV;
+
+	// TODO: This interface can be used to configure the SPI bus.
+	// Configurable options could include: Speed, Clock Polarity, Clock Phase
+
+	switch(cmd) {
+		default:
+			return -ENOIOCTLCMD;
+	}
+}
+
+/*
+ * Open the SPI device
+ */
+static int spidev_open(struct inode *inode, struct file *file)
+{
+	unsigned int spi_device = MINOR(inode->i_rdev);
+
+	if (spi_device >= NR_SPI_DEVICES)
+		return -ENODEV;
+
+	/*
+	 * 'private_data' is actually a pointer, but we overload it with the
+	 * value we want to store.
+	 */
+	file->private_data = (void *)spi_device;
+
+	return 0;
+}
+
+/*
+ * Close the SPI device
+ */
+static int spidev_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+/* ......................................................................... */
+
+static struct file_operations spidev_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= spidev_rd_wr,
+	.write		= (int (*) (struct file *file, const char *buf, size_t count, loff_t *offset))spidev_rd_wr,
+	.ioctl		= spidev_ioctl,
+	.open		= spidev_open,
+	.release	= spidev_close,
+};
+
+/*
+ * Install the SPI /dev interface driver
+ */
+static int __init at91_spidev_init(void)
+{
+#ifdef CONFIG_DEVFS_FS
+	int i;
+#endif
+
+	if (register_chrdev(SPI_MAJOR, "spi", &spidev_fops)) {
+		printk(KERN_ERR "at91_spidev: Unable to get major %d for SPI bus\n", SPI_MAJOR);
+		return -EIO;
+	}
+
+#ifdef CONFIG_DEVFS_FS
+	devfs_mk_dir("spi");
+	for (i = 0; i < NR_SPI_DEVICES; i++) {
+		devfs_mk_cdev(MKDEV(SPI_MAJOR, i), S_IFCHR | S_IRUSR | S_IWUSR, "spi/%d",i);
+	}
+#endif
+	printk(KERN_INFO "AT91 SPI driver loaded\n");
+
+	return 0;
+}
+
+/*
+ * Remove the SPI /dev interface driver
+ */
+static void __exit at91_spidev_exit(void)
+{
+#ifdef CONFIG_DEVFS_FS
+	int i;
+	for (i = 0; i < NR_SPI_DEVICES; i++) {
+		devfs_remove("spi/%d", i);
+	}
+
+	devfs_remove("spi");
+#endif
+
+	if (unregister_chrdev(SPI_MAJOR, "spi")) {
+		printk(KERN_ERR "at91_spidev: Unable to release major %d for SPI bus\n", SPI_MAJOR);
+		return;
+	}
+}
+
+module_init(at91_spidev_init);
+module_exit(at91_spidev_exit);
+
+MODULE_LICENSE("GPL")
+MODULE_AUTHOR("Andrew Victor")
+MODULE_DESCRIPTION("SPI /dev interface for Atmel AT91RM9200")
Index: linux-2.6.21.7/drivers/i2c/busses/Kconfig
===================================================================
--- linux-2.6.21.7.orig/drivers/i2c/busses/Kconfig
+++ linux-2.6.21.7/drivers/i2c/busses/Kconfig
@@ -81,6 +81,14 @@ config I2C_AT91
 	  This supports the use of the I2C interface on Atmel AT91
 	  processors.
 
+config I2C_AT91_CLOCKRATE
+	prompt "Atmel AT91 I2C/TWI clock-rate"
+	depends on I2C_AT91
+	int
+	default 100000
+	help
+	  Set the AT91 I2C/TWI clock-rate.
+
 config I2C_AU1550
 	tristate "Au1550/Au1200 SMBus interface"
 	depends on I2C && (SOC_AU1550 || SOC_AU1200)
@@ -545,6 +553,14 @@ config I2C_VOODOO3
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-voodoo3.
 
+config I2C_PCA
+	tristate "PCA9564"
+	depends on I2C
+	select I2C_ALGOPCA
+	help
+	  This driver support the Philips PCA 9564 Parallel bus to I2C
+	  bus controller.
+
 config I2C_PCA_ISA
 	tristate "PCA9564 on an ISA bus"
 	depends on I2C
Index: linux-2.6.21.7/drivers/i2c/busses/Makefile
===================================================================
--- linux-2.6.21.7.orig/drivers/i2c/busses/Makefile
+++ linux-2.6.21.7/drivers/i2c/busses/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_I2C_OMAP)		+= i2c-omap.o
 obj-$(CONFIG_I2C_PARPORT)	+= i2c-parport.o
 obj-$(CONFIG_I2C_PARPORT_LIGHT)	+= i2c-parport-light.o
 obj-$(CONFIG_I2C_PASEMI)	+= i2c-pasemi.o
+obj-$(CONFIG_I2C_PCA)		+= i2c-pca.o
 obj-$(CONFIG_I2C_PCA_ISA)	+= i2c-pca-isa.o
 obj-$(CONFIG_I2C_PIIX4)		+= i2c-piix4.o
 obj-$(CONFIG_I2C_PNX)		+= i2c-pnx.o
Index: linux-2.6.21.7/drivers/i2c/busses/i2c-at91.c
===================================================================
--- linux-2.6.21.7.orig/drivers/i2c/busses/i2c-at91.c
+++ linux-2.6.21.7/drivers/i2c/busses/i2c-at91.c
@@ -31,8 +31,11 @@
 #include <asm/arch/board.h>
 #include <asm/arch/cpu.h>
 
-#define TWI_CLOCK		100000		/* Hz. max 400 Kbits/sec */
 
+/* Clockrate is configurable - max 400 Kbits/sec */
+static unsigned int clockrate = CONFIG_I2C_AT91_CLOCKRATE;
+module_param(clockrate, uint, 0);
+MODULE_PARM_DESC(clockrate, "The TWI clockrate");
 
 static struct clk *twi_clk;
 static void __iomem *twi_base;
@@ -53,7 +56,7 @@ static void __devinit at91_twi_hwinit(vo
 	at91_twi_write(AT91_TWI_CR, AT91_TWI_MSEN);	/* Set Master mode */
 
 	/* Calcuate clock dividers */
-	cdiv = (clk_get_rate(twi_clk) / (2 * TWI_CLOCK)) - 3;
+	cdiv = (clk_get_rate(twi_clk) / (2 * clockrate)) - 3;
 	cdiv = cdiv + 1;	/* round up */
 	ckdiv = 0;
 	while (cdiv > 255) {
@@ -61,11 +64,12 @@ static void __devinit at91_twi_hwinit(vo
 		cdiv = cdiv >> 1;
 	}
 
-	if (cpu_is_at91rm9200()) {			/* AT91RM9200 Errata #22 */
-		if (ckdiv > 5) {
-			printk(KERN_ERR "AT91 I2C: Invalid TWI_CLOCK value!\n");
-			ckdiv = 5;
-		}
+	if (cpu_is_at91rm9200() && (ckdiv > 5)) {	/* AT91RM9200 Errata #22 */
+		printk(KERN_ERR "AT91 I2C: Invalid TWI clockrate!\n");
+		ckdiv = 5;
+	} else if (ckdiv > 7) {
+		printk(KERN_ERR "AT91 I2C: Invalid TWI clockrate!\n");
+		ckdiv = 7;
 	}
 
 	at91_twi_write(AT91_TWI_CWGR, (ckdiv << 16) | (cdiv << 8) | cdiv);
Index: linux-2.6.21.7/drivers/i2c/busses/i2c-pca.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/drivers/i2c/busses/i2c-pca.c
@@ -0,0 +1,213 @@
+/*
+ *  Platform driver for PCA9564 I2C bus controller.
+ *
+ *  (C) 2006 Andrew Victor
+ *
+ *  Based on i2c-pca-isa.c driver for PCA9564 on ISA boards
+ *    Copyright (C) 2004 Arcom Control Systems
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/platform_device.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-pca.h>
+
+#include <asm/io.h>
+
+#include "../algos/i2c-algo-pca.h"
+
+#define PCA_OWN_ADDRESS		0x55	/* our address for slave mode */
+#define PCA_CLOCK		I2C_PCA_CON_59kHz
+
+//#define REG_SHIFT		2
+#define REG_SHIFT		0
+
+//#define DEBUG_IO
+
+#define PCA_IO_SIZE 4
+
+static void __iomem *base_addr;
+static int irq;
+static wait_queue_head_t pca_wait;
+
+static int pca_getown(struct i2c_algo_pca_data *adap)
+{
+	return PCA_OWN_ADDRESS;
+}
+
+static int pca_getclock(struct i2c_algo_pca_data *adap)
+{
+	return PCA_CLOCK;
+}
+
+static void pca_writebyte(struct i2c_algo_pca_data *adap, int reg, int val)
+{
+#ifdef DEBUG_IO
+	static char *names[] = { "T/O", "DAT", "ADR", "CON" };
+	printk("*** write %s at %#lx <= %#04x\n", names[reg], (unsigned long) base_addr+reg, val);
+#endif
+	udelay(1);
+	outb(val, base_addr + (reg << REG_SHIFT));
+}
+
+static int pca_readbyte(struct i2c_algo_pca_data *adap, int reg)
+{
+	int res;
+
+	udelay(1);
+	res = inb(base_addr + (reg << REG_SHIFT));
+#ifdef DEBUG_IO
+	{
+		static char *names[] = { "STA", "DAT", "ADR", "CON" };
+		printk("*** read  %s => %#04x\n", names[reg], res);
+	}
+#endif
+	return res;
+}
+
+static int pca_waitforinterrupt(struct i2c_algo_pca_data *adap)
+{
+	int ret = 0;
+
+	if (irq > -1) {
+		ret = wait_event_interruptible(pca_wait,
+				pca_readbyte(adap, I2C_PCA_CON) & I2C_PCA_CON_SI);
+	} else {
+		while ((pca_readbyte(adap, I2C_PCA_CON) & I2C_PCA_CON_SI) == 0)
+			udelay(100);
+	}
+	return ret;
+}
+
+static irqreturn_t pca_handler(int this_irq, void *dev_id)
+{
+	wake_up_interruptible(&pca_wait);
+	return IRQ_HANDLED;
+}
+
+static struct i2c_algo_pca_data pca_i2c_data = {
+	.get_own		= pca_getown,
+	.get_clock		= pca_getclock,
+	.write_byte		= pca_writebyte,
+	.read_byte		= pca_readbyte,
+	.wait_for_interrupt	= pca_waitforinterrupt,
+};
+
+static struct i2c_adapter pca_i2c_ops = {
+	.owner          = THIS_MODULE,
+	.id		= I2C_HW_A_PLAT,
+	.algo_data	= &pca_i2c_data,
+	.name		= "PCA9564",
+	.class		= I2C_CLASS_HWMON,
+};
+
+static int __devinit pca_i2c_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	init_waitqueue_head(&pca_wait);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	if (!request_mem_region(res->start, PCA_IO_SIZE, "PCA9564"))
+		return -ENXIO;
+
+	base_addr = ioremap(res->start, PCA_IO_SIZE);
+	if (base_addr == NULL)
+		goto out_region;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq > -1) {
+		if (request_irq(irq, pca_handler, 0, "pca9564", NULL) < 0) {
+			printk(KERN_ERR "i2c-pca: Request irq%d failed\n", irq);
+			goto out_remap;
+		}
+	}
+
+	/* set up the driverfs linkage to our parent device */
+	pca_i2c_ops.dev.parent = &pdev->dev;
+
+	if (i2c_pca_add_bus(&pca_i2c_ops) < 0) {
+		printk(KERN_ERR "i2c-pca: Failed to add i2c bus\n");
+		goto out_irq;
+	}
+
+	return 0;
+
+ out_irq:
+	if (irq > -1)
+		free_irq(irq, &pca_i2c_ops);
+
+ out_remap:
+	iounmap(base_addr);
+
+ out_region:
+	release_mem_region(res->start, PCA_IO_SIZE);
+	return -ENODEV;
+}
+
+static int __devexit pca_i2c_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	i2c_del_adapter(&pca_i2c_ops);
+
+	if (irq > 0)
+		free_irq(irq, NULL);
+
+	iounmap(base_addr);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, PCA_IO_SIZE);
+
+	return 0;
+}
+
+static struct platform_driver pca_i2c_driver = {
+	.probe		= pca_i2c_probe,
+	.remove		= __devexit_p(pca_i2c_remove),
+	.driver		= {
+		.name	= "pca9564",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init pca_i2c_init(void)
+{
+	return platform_driver_register(&pca_i2c_driver);
+}
+
+static void __exit pca_i2c_exit(void)
+{
+	platform_driver_unregister(&pca_i2c_driver);
+}
+
+module_init(pca_i2c_init);
+module_exit(pca_i2c_exit);
+
+MODULE_AUTHOR("Andrew Victor");
+MODULE_DESCRIPTION("PCA9564 platform driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.21.7/drivers/input/touchscreen/ads7846.c
===================================================================
--- linux-2.6.21.7.orig/drivers/input/touchscreen/ads7846.c
+++ linux-2.6.21.7/drivers/input/touchscreen/ads7846.c
@@ -39,7 +39,8 @@
 /*
  * This code has been heavily tested on a Nokia 770, and lightly
  * tested on other ads7846 devices (OSK/Mistral, Lubbock).
- * Support for ads7843 and ads7845 has only been stubbed in.
+ * Support for ads7843 tested on Atmel at91sam926x-EK.
+ * Support for ads7845 has only been stubbed in.
  *
  * IRQ handling needs a workaround because of a shortcoming in handling
  * edge triggered IRQs on some platforms like the OMAP1/2. These
@@ -246,18 +247,16 @@ static int ads7846_read12_ser(struct dev
 
 	/* REVISIT:  take a few more samples, and compare ... */
 
-	/* maybe off internal vREF */
-	if (use_internal) {
-		req->ref_off = REF_OFF;
-		req->xfer[4].tx_buf = &req->ref_off;
-		req->xfer[4].len = 1;
-		spi_message_add_tail(&req->xfer[4], &req->msg);
-
-		req->xfer[5].rx_buf = &req->scratch;
-		req->xfer[5].len = 2;
-		CS_CHANGE(req->xfer[5]);
-		spi_message_add_tail(&req->xfer[5], &req->msg);
-	}
+	/* converter in low power mode & enable PENIRQ */
+	req->ref_off = PWRDOWN;
+	req->xfer[4].tx_buf = &req->ref_off;
+	req->xfer[4].len = 1;
+	spi_message_add_tail(&req->xfer[4], &req->msg);
+
+	req->xfer[5].rx_buf = &req->scratch;
+	req->xfer[5].len = 2;
+	CS_CHANGE(req->xfer[5]);
+	spi_message_add_tail(&req->xfer[5], &req->msg);
 
 	ts->irq_disabled = 1;
 	disable_irq(spi->irq);
@@ -536,6 +535,9 @@ static void ads7846_rx(void *ads)
 	} else
 		Rt = 0;
 
+	if (ts->model == 7843)
+		Rt = ts->pressure_max / 2;
+
 	/* Sample found inconsistent by debouncing or pressure is beyond
 	 * the maximum. Don't report it to user space, repeat at least
 	 * once more the measurement
Index: linux-2.6.21.7/drivers/leds/Kconfig
===================================================================
--- linux-2.6.21.7.orig/drivers/leds/Kconfig
+++ linux-2.6.21.7/drivers/leds/Kconfig
@@ -76,6 +76,13 @@ config LEDS_NET48XX
 	  This option enables support for the Soekris net4801 and net4826 error
 	  LED.
 
+config LEDS_AT91
+	tristate "LED support using AT91 GPIOs"
+	depends on LEDS_CLASS && ARCH_AT91 && !LEDS
+	help
+	  This option enables support for LEDs connected to GPIO lines
+	  on AT91-based boards.
+
 config LEDS_WRAP
 	tristate "LED Support for the WRAP series LEDs"
 	depends on LEDS_CLASS && SCx200_GPIO
Index: linux-2.6.21.7/drivers/leds/Makefile
===================================================================
--- linux-2.6.21.7.orig/drivers/leds/Makefile
+++ linux-2.6.21.7/drivers/leds/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_LEDS_NET48XX)		+= leds-net4
 obj-$(CONFIG_LEDS_WRAP)			+= leds-wrap.o
 obj-$(CONFIG_LEDS_H1940)		+= leds-h1940.o
 obj-$(CONFIG_LEDS_COBALT)		+= leds-cobalt.o
+obj-$(CONFIG_LEDS_AT91)			+= leds-at91.o
 
 # LED Triggers
 obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
Index: linux-2.6.21.7/drivers/leds/leds-at91.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/drivers/leds/leds-at91.c
@@ -0,0 +1,140 @@
+/*
+ * AT91 GPIO based LED driver
+ *
+ * Copyright (C) 2006 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+
+static LIST_HEAD(at91_led_list);	/* list of AT91 LEDs */
+
+struct at91_led {
+	struct led_classdev	cdev;
+	struct list_head	list;
+	struct at91_gpio_led	*led_data;
+};
+
+/*
+ * Change the state of the LED.
+ */
+static void at91_led_set(struct led_classdev *cdev, enum led_brightness value)
+{
+	struct at91_led	*led = container_of(cdev, struct at91_led, cdev);
+	short		active = (value == LED_OFF);
+
+	if (led->led_data->flags & 1)	/* active high/low? */
+		active = !active;
+	at91_set_gpio_value(led->led_data->gpio, active);
+}
+
+static int __devexit at91_led_remove(struct platform_device *pdev)
+{
+	struct at91_led		*led;
+
+	list_for_each_entry (led, &at91_led_list, list)
+		led_classdev_unregister(&led->cdev);
+
+#warning "Free allocated memory"
+	// TODO: Free memory.	kfree(led);
+
+	return 0;
+}
+
+static int __init at91_led_probe(struct platform_device *pdev)
+{
+	int			status = 0;
+	struct at91_gpio_led	*pdata = pdev->dev.platform_data;
+	unsigned		nr_leds;
+	struct at91_led		*led;
+
+	if (!pdata)
+		return -ENODEV;
+
+	nr_leds = pdata->index;		/* first index stores number of LEDs */
+
+	while (nr_leds--) {
+		led = kzalloc(sizeof(struct at91_led), GFP_KERNEL);
+		if (!led) {
+			dev_err(&pdev->dev, "No memory for device\n");
+			status = -ENOMEM;
+			goto cleanup;
+		}
+		led->led_data = pdata;
+		led->cdev.name = pdata->name;
+		led->cdev.brightness_set = at91_led_set,
+		led->cdev.default_trigger = pdata->trigger;
+
+		status = led_classdev_register(&pdev->dev, &led->cdev);
+		if (status < 0) {
+			dev_err(&pdev->dev, "led_classdev_register failed - %d\n", status);
+cleanup:
+			at91_led_remove(pdev);
+			break;
+		}
+		list_add(&led->list, &at91_led_list);
+		pdata++;
+	}
+	return status;
+}
+
+#ifdef CONFIG_PM
+static int at91_led_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct at91_led	*led;
+
+	list_for_each_entry (led, &at91_led_list, list)
+		led_classdev_suspend(&led->cdev);
+
+	return 0;
+}
+
+static int at91_led_resume(struct platform_device *dev)
+{
+	struct at91_led	*led;
+
+	list_for_each_entry (led, &at91_led_list, list)
+		led_classdev_resume(&led->cdev);
+
+	return 0;
+}
+#else
+#define	at91_led_suspend	NULL
+#define	at91_led_resume		NULL
+#endif
+
+static struct platform_driver at91_led_driver = {
+	.probe		= at91_led_probe,
+	.remove		= __devexit_p(at91_led_remove),
+	.suspend	= at91_led_suspend,
+	.resume		= at91_led_resume,
+	.driver		= {
+		.name	= "at91_leds",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init at91_led_init(void)
+{
+	return platform_driver_register(&at91_led_driver);
+}
+module_init(at91_led_init);
+
+static void __exit at91_led_exit(void)
+{
+	platform_driver_unregister(&at91_led_driver);
+}
+module_exit(at91_led_exit);
+
+MODULE_DESCRIPTION("AT91 GPIO LED driver");
+MODULE_AUTHOR("David Brownell");
+MODULE_LICENSE("GPL");
Index: linux-2.6.21.7/drivers/mmc/at91_mci.c
===================================================================
--- linux-2.6.21.7.orig/drivers/mmc/at91_mci.c
+++ linux-2.6.21.7/drivers/mmc/at91_mci.c
@@ -86,7 +86,7 @@
 
 #define AT91_MCI_ERRORS	(AT91_MCI_RINDE | AT91_MCI_RDIRE | AT91_MCI_RCRCE	\
 		| AT91_MCI_RENDE | AT91_MCI_RTOE | AT91_MCI_DCRCE		\
-		| AT91_MCI_DTOE | AT91_MCI_OVRE | AT91_MCI_UNRE)			
+		| AT91_MCI_DTOE | AT91_MCI_OVRE | AT91_MCI_UNRE)
 
 #define at91_mci_read(host, reg)	__raw_readl((host)->baseaddr + (reg))
 #define at91_mci_write(host, reg, val)	__raw_writel((val), (host)->baseaddr + (reg))
@@ -561,9 +561,7 @@ static void at91mci_completed_command(st
 	pr_debug("Status = %08X [%08X %08X %08X %08X]\n",
 		 status, cmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3]);
 
-	if (status & (AT91_MCI_RINDE | AT91_MCI_RDIRE | AT91_MCI_RCRCE |
-			AT91_MCI_RENDE | AT91_MCI_RTOE | AT91_MCI_DCRCE |
-			AT91_MCI_DTOE | AT91_MCI_OVRE | AT91_MCI_UNRE)) {
+	if (status & AT91_MCI_ERRORS) {
 		if ((status & AT91_MCI_RCRCE) &&
 			((cmd->opcode == MMC_SEND_OP_COND) || (cmd->opcode == SD_APP_OP_COND))) {
 			cmd->error = MMC_ERR_NONE;
@@ -665,15 +663,15 @@ static irqreturn_t at91_mci_irq(int irq,
 
 	int_status = at91_mci_read(host, AT91_MCI_SR);
 	int_mask = at91_mci_read(host, AT91_MCI_IMR);
-	
+
 	pr_debug("MCI irq: status = %08X, %08X, %08X\n", int_status, int_mask,
 		int_status & int_mask);
-	
+
 	int_status = int_status & int_mask;
 
 	if (int_status & AT91_MCI_ERRORS) {
 		completed = 1;
-		
+
 		if (int_status & AT91_MCI_UNRE)
 			pr_debug("MMC: Underrun error\n");
 		if (int_status & AT91_MCI_OVRE)
@@ -821,7 +819,7 @@ static int __init at91_mci_probe(struct 
 	mmc->f_min = 375000;
 	mmc->f_max = 25000000;
 	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
-	mmc->caps = MMC_CAP_BYTEBLOCK;
+	mmc->caps = MMC_CAP_BYTEBLOCK | MMC_CAP_MULTIWRITE;
 
 	mmc->max_blk_size = 4095;
 	mmc->max_blk_count = mmc->max_req_size;
@@ -895,6 +893,8 @@ static int __init at91_mci_probe(struct 
 
 	mmc_add_host(mmc);
 
+	device_init_wakeup(&pdev->dev, 1);
+
 	/*
 	 * monitor card insertion/removal if we can
 	 */
@@ -924,6 +924,8 @@ static int __exit at91_mci_remove(struct
 
 	host = mmc_priv(mmc);
 
+	device_init_wakeup(&pdev->dev, 0);
+
 	if (host->present != -1) {
 		free_irq(host->board->det_pin, host);
 		cancel_delayed_work(&host->mmc->detect);
@@ -951,8 +953,12 @@ static int __exit at91_mci_remove(struct
 static int at91_mci_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	struct at91mci_host *host = mmc_priv(mmc);
 	int ret = 0;
 
+	if (device_may_wakeup(&pdev->dev))
+		enable_irq_wake(host->board->det_pin);
+
 	if (mmc)
 		ret = mmc_suspend_host(mmc, state);
 
@@ -962,8 +968,12 @@ static int at91_mci_suspend(struct platf
 static int at91_mci_resume(struct platform_device *pdev)
 {
 	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	struct at91mci_host *host = mmc_priv(mmc);
 	int ret = 0;
 
+	if (device_may_wakeup(&pdev->dev))
+		disable_irq_wake(host->board->det_pin);
+
 	if (mmc)
 		ret = mmc_resume_host(mmc);
 
Index: linux-2.6.21.7/drivers/mtd/devices/Kconfig
===================================================================
--- linux-2.6.21.7.orig/drivers/mtd/devices/Kconfig
+++ linux-2.6.21.7/drivers/mtd/devices/Kconfig
@@ -267,5 +267,11 @@ config MTD_DOCPROBE_55AA
 	  LinuxBIOS or if you need to recover a DiskOnChip Millennium on which
 	  you have managed to wipe the first block.
 
-endmenu
+config MTD_AT91_DATAFLASH
+	tristate "AT91RM9200 DataFlash AT45DBxxx (legacy driver)"
+	depends on MTD && ARCH_AT91RM9200 && AT91_SPI
+	help
+	  This enables access to the DataFlash (AT45DBxxx) on the AT91RM9200.
+	  If you have such a board, say 'Y'.
 
+endmenu
Index: linux-2.6.21.7/drivers/mtd/devices/Makefile
===================================================================
--- linux-2.6.21.7.orig/drivers/mtd/devices/Makefile
+++ linux-2.6.21.7/drivers/mtd/devices/Makefile
@@ -17,3 +17,4 @@ obj-$(CONFIG_MTD_LART)		+= lart.o
 obj-$(CONFIG_MTD_BLOCK2MTD)	+= block2mtd.o
 obj-$(CONFIG_MTD_DATAFLASH)	+= mtd_dataflash.o
 obj-$(CONFIG_MTD_M25P80)	+= m25p80.o
+obj-$(CONFIG_MTD_AT91_DATAFLASH)+= at91_dataflash.o
Index: linux-2.6.21.7/drivers/mtd/devices/at91_dataflash.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/drivers/mtd/devices/at91_dataflash.c
@@ -0,0 +1,667 @@
+/*
+ * Atmel DataFlash driver for Atmel AT91RM9200 (Thunder)
+ *
+ *  Copyright (C) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/arch/spi.h>
+
+#undef DEBUG_DATAFLASH
+
+#define DATAFLASH_MAX_DEVICES	4	/* max number of dataflash devices */
+#undef	DATAFLASH_ALWAYS_ADD_DEVICE	/* always add whole device when using partitions? */
+
+#define OP_READ_CONTINUOUS	0xE8
+#define OP_READ_PAGE		0xD2
+#define OP_READ_BUFFER1		0xD4
+#define OP_READ_BUFFER2		0xD6
+#define OP_READ_STATUS		0xD7
+
+#define OP_ERASE_PAGE		0x81
+#define OP_ERASE_BLOCK		0x50
+
+#define OP_TRANSFER_BUF1	0x53
+#define OP_TRANSFER_BUF2	0x55
+#define OP_COMPARE_BUF1		0x60
+#define OP_COMPARE_BUF2		0x61
+
+#define OP_PROGRAM_VIA_BUF1	0x82
+#define OP_PROGRAM_VIA_BUF2	0x85
+
+struct dataflash_local
+{
+	int spi;			/* SPI chip-select number */
+
+	unsigned int page_size;		/* number of bytes per page */
+	unsigned short page_offset;	/* page offset in flash address */
+};
+
+
+/* Detected DataFlash devices */
+static struct mtd_info* mtd_devices[DATAFLASH_MAX_DEVICES];
+static int nr_devices = 0;
+
+/* ......................................................................... */
+
+#ifdef CONFIG_MTD_PARTITIONS
+
+static struct mtd_partition static_partitions_2M[] =
+{
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 1 * 32 * 8 * 528,	/* 1st sector = 32 blocks * 8 pages * 528 bytes */
+		.mask_flags	= MTD_WRITEABLE,	/* read-only */
+	},
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= 6 * 32 * 8 * 528,	/* 6 sectors */
+	},
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= MTDPART_SIZ_FULL,	/* rest = 9 sectors */
+	}
+};
+
+static struct mtd_partition static_partitions_4M[] =
+{
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 1 * 64 * 8 * 528,	/* 1st sector = 64 blocks * 8 pages * 528 bytes */
+		.mask_flags	= MTD_WRITEABLE,	/* read-only */
+	},
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= 4 * 64 * 8 * 528,	/* 4 sectors */
+	},
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= MTDPART_SIZ_FULL,	/* rest = 11 sectors */
+	}
+};
+
+#if defined(CONFIG_MACH_KAFA)
+static struct mtd_partition static_partitions_8M[] =
+{
+	{
+		name:		"romboot",
+		offset:		0,
+		size:		16 * 1056,	/* 160 Kb */
+		mask_flags:	MTD_WRITEABLE,		/* read-only */
+	},
+	{
+		name:		"uboot",
+		offset:		MTDPART_OFS_APPEND, /* Sperry, NXTBLK is broken */
+		size:		128 * 1056,		/* 1 MB */
+	},
+	{
+		name:		"kernel",
+		offset:		MTDPART_OFS_APPEND, /* Sperry, NXTBLK is broken */
+		size:		1024 * 1056,		/* 1 MB */
+	},
+	{
+		name:		"filesystem",
+		offset:		MTDPART_OFS_APPEND, /* Sperry, NXTBLK is broken */
+		size:		MTDPART_SIZ_FULL,
+	}
+};
+
+#elif defined(CONFIG_MACH_MULTMDP)
+
+static struct mtd_partition static_partitions_8M[] =
+{
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 12 * 1056,		/* 1st sector = 32 blocks * 8 pages * 1056 bytes */
+		.mask_flags	= MTD_WRITEABLE,	/* read-only */
+	},
+	{
+		.name		= "configuration",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= 20 * 1056,
+	},
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= 1520 * 1056,
+	},
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= MTDPART_SIZ_FULL,
+	}
+};
+
+#else
+
+static struct mtd_partition static_partitions_8M[] =
+{
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 1 * 32 * 8 * 1056,	/* 1st sector = 32 blocks * 8 pages * 1056 bytes */
+		.mask_flags	= MTD_WRITEABLE,	/* read-only */
+	},
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= 5 * 32 * 8 * 1056,	/* 5 sectors */
+	},
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_NXTBLK,
+		.size		= MTDPART_SIZ_FULL,	/* rest = 26 sectors */
+	}
+};
+#endif
+
+static const char *part_probes[] = { "cmdlinepart", NULL, };
+
+#endif
+
+/* ......................................................................... */
+
+/* Allocate a single SPI transfer descriptor.  We're assuming that if multiple
+   SPI transfers occur at the same time, spi_access_bus() will serialize them.
+   If this is not valid, then either (i) each dataflash 'priv' structure
+   needs it's own transfer descriptor, (ii) we lock this one, or (iii) use
+   another mechanism.   */
+static struct spi_transfer_list* spi_transfer_desc;
+
+/*
+ * Perform a SPI transfer to access the DataFlash device.
+ */
+static int do_spi_transfer(int nr, char* tx, int tx_len, char* rx, int rx_len,
+		char* txnext, int txnext_len, char* rxnext, int rxnext_len)
+{
+	struct spi_transfer_list* list = spi_transfer_desc;
+
+	list->tx[0] = tx;	list->txlen[0] = tx_len;
+	list->rx[0] = rx;	list->rxlen[0] = rx_len;
+
+	list->tx[1] = txnext;	list->txlen[1] = txnext_len;
+	list->rx[1] = rxnext;	list->rxlen[1] = rxnext_len;
+
+	list->nr_transfers = nr;
+
+	return spi_transfer(list);
+}
+
+/* ......................................................................... */
+
+/*
+ * Poll the DataFlash device until it is READY.
+ */
+static void at91_dataflash_waitready(void)
+{
+	char* command = kmalloc(2, GFP_KERNEL);
+
+	if (!command)
+		return;
+
+	do {
+		command[0] = OP_READ_STATUS;
+		command[1] = 0;
+
+		do_spi_transfer(1, command, 2, command, 2, NULL, 0, NULL, 0);
+	} while ((command[1] & 0x80) == 0);
+
+	kfree(command);
+}
+
+/*
+ * Return the status of the DataFlash device.
+ */
+static unsigned short at91_dataflash_status(void)
+{
+	unsigned short status;
+	char* command = kmalloc(2, GFP_KERNEL);
+
+	if (!command)
+		return 0;
+
+	command[0] = OP_READ_STATUS;
+	command[1] = 0;
+
+	do_spi_transfer(1, command, 2, command, 2, NULL, 0, NULL, 0);
+	status = command[1];
+
+	kfree(command);
+	return status;
+}
+
+/* ......................................................................... */
+
+/*
+ * Erase blocks of flash.
+ */
+static int at91_dataflash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct dataflash_local *priv = (struct dataflash_local *) mtd->priv;
+	unsigned int pageaddr;
+	char* command;
+
+#ifdef DEBUG_DATAFLASH
+	printk("dataflash_erase: addr=%i len=%i\n", instr->addr, instr->len);
+#endif
+
+	/* Sanity checks */
+	if (instr->addr + instr->len > mtd->size)
+		return -EINVAL;
+	if ((instr->len % mtd->erasesize != 0) || (instr->len % priv->page_size != 0))
+		return -EINVAL;
+	if ((instr->addr % priv->page_size) != 0)
+		return -EINVAL;
+
+	command = kmalloc(4, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+
+	while (instr->len > 0) {
+		/* Calculate flash page address */
+		pageaddr = (instr->addr / priv->page_size) << priv->page_offset;
+
+		command[0] = OP_ERASE_PAGE;
+		command[1] = (pageaddr & 0x00FF0000) >> 16;
+		command[2] = (pageaddr & 0x0000FF00) >> 8;
+		command[3] = 0;
+#ifdef DEBUG_DATAFLASH
+		printk("ERASE: (%x) %x %x %x [%i]\n", command[0], command[1], command[2], command[3], pageaddr);
+#endif
+
+		/* Send command to SPI device */
+		spi_access_bus(priv->spi);
+		do_spi_transfer(1, command, 4, command, 4, NULL, 0, NULL, 0);
+
+		at91_dataflash_waitready();		/* poll status until ready */
+		spi_release_bus(priv->spi);
+
+		instr->addr += priv->page_size;		/* next page */
+		instr->len -= priv->page_size;
+	}
+
+	kfree(command);
+
+	/* Inform MTD subsystem that erase is complete */
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback)
+		instr->callback(instr);
+
+	return 0;
+}
+
+/*
+ * Read from the DataFlash device.
+ *   from   : Start offset in flash device
+ *   len    : Amount to read
+ *   retlen : About of data actually read
+ *   buf    : Buffer containing the data
+ */
+static int at91_dataflash_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	struct dataflash_local *priv = (struct dataflash_local *) mtd->priv;
+	unsigned int addr;
+	char* command;
+
+#ifdef DEBUG_DATAFLASH
+	printk("dataflash_read: %lli .. %lli\n", from, from+len);
+#endif
+
+	*retlen = 0;
+
+	/* Sanity checks */
+	if (!len)
+		return 0;
+	if (from + len > mtd->size)
+		return -EINVAL;
+
+	/* Calculate flash page/byte address */
+	addr = (((unsigned)from / priv->page_size) << priv->page_offset) + ((unsigned)from % priv->page_size);
+
+	command = kmalloc(8, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+
+	command[0] = OP_READ_CONTINUOUS;
+	command[1] = (addr & 0x00FF0000) >> 16;
+	command[2] = (addr & 0x0000FF00) >> 8;
+	command[3] = (addr & 0x000000FF);
+#ifdef DEBUG_DATAFLASH
+	printk("READ: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+
+	/* Send command to SPI device */
+	spi_access_bus(priv->spi);
+	do_spi_transfer(2, command, 8, command, 8, buf, len, buf, len);
+	spi_release_bus(priv->spi);
+
+	*retlen = len;
+	kfree(command);
+	return 0;
+}
+
+/*
+ * Write to the DataFlash device.
+ *   to     : Start offset in flash device
+ *   len    : Amount to write
+ *   retlen : Amount of data actually written
+ *   buf    : Buffer containing the data
+ */
+static int at91_dataflash_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
+{
+	struct dataflash_local *priv = (struct dataflash_local *) mtd->priv;
+	unsigned int pageaddr, addr, offset, writelen;
+	size_t remaining;
+	u_char *writebuf;
+	unsigned short status;
+	int res = 0;
+	char* command;
+	char* tmpbuf = NULL;
+
+#ifdef DEBUG_DATAFLASH
+	printk("dataflash_write: %lli .. %lli\n", to, to+len);
+#endif
+
+	*retlen = 0;
+
+	/* Sanity checks */
+	if (!len)
+		return 0;
+	if (to + len > mtd->size)
+		return -EINVAL;
+
+	command = kmalloc(4, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+
+	pageaddr = ((unsigned)to / priv->page_size);
+	offset = ((unsigned)to % priv->page_size);
+	if (offset + len > priv->page_size)
+		writelen = priv->page_size - offset;
+	else
+		writelen = len;
+	writebuf = (u_char *)buf;
+	remaining = len;
+
+	/* Allocate temporary buffer */
+	tmpbuf = kmalloc(priv->page_size, GFP_KERNEL);
+	if (!tmpbuf) {
+		kfree(command);
+		return -ENOMEM;
+	}
+
+	/* Gain access to the SPI bus */
+	spi_access_bus(priv->spi);
+
+	while (remaining > 0) {
+#ifdef DEBUG_DATAFLASH
+		printk("write @ %i:%i len=%i\n", pageaddr, offset, writelen);
+#endif
+
+		/* (1) Transfer to Buffer1 */
+		if (writelen != priv->page_size) {
+			addr = pageaddr << priv->page_offset;
+			command[0] = OP_TRANSFER_BUF1;
+			command[1] = (addr & 0x00FF0000) >> 16;
+			command[2] = (addr & 0x0000FF00) >> 8;
+			command[3] = 0;
+#ifdef DEBUG_DATAFLASH
+			printk("TRANSFER: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+			do_spi_transfer(1, command, 4, command, 4, NULL, 0, NULL, 0);
+			at91_dataflash_waitready();
+		}
+
+		/* (2) Program via Buffer1 */
+		addr = (pageaddr << priv->page_offset) + offset;
+		command[0] = OP_PROGRAM_VIA_BUF1;
+		command[1] = (addr & 0x00FF0000) >> 16;
+		command[2] = (addr & 0x0000FF00) >> 8;
+		command[3] = (addr & 0x000000FF);
+#ifdef DEBUG_DATAFLASH
+		printk("PROGRAM: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+		do_spi_transfer(2, command, 4, command, 4, writebuf, writelen, tmpbuf, writelen);
+		at91_dataflash_waitready();
+
+		/* (3) Compare to Buffer1 */
+		addr = pageaddr << priv->page_offset;
+		command[0] = OP_COMPARE_BUF1;
+		command[1] = (addr & 0x00FF0000) >> 16;
+		command[2] = (addr & 0x0000FF00) >> 8;
+		command[3] = 0;
+#ifdef DEBUG_DATAFLASH
+		printk("COMPARE: (%x) %x %x %x\n", command[0], command[1], command[2], command[3]);
+#endif
+		do_spi_transfer(1, command, 4, command, 4, NULL, 0, NULL, 0);
+		at91_dataflash_waitready();
+
+		/* Get result of the compare operation */
+		status = at91_dataflash_status();
+		if ((status & 0x40) == 1) {
+			printk("at91_dataflash: Write error on page %i\n", pageaddr);
+			remaining = 0;
+			res = -EIO;
+		}
+
+		remaining = remaining - writelen;
+		pageaddr++;
+		offset = 0;
+		writebuf += writelen;
+		*retlen += writelen;
+
+		if (remaining > priv->page_size)
+			writelen = priv->page_size;
+		else
+			writelen = remaining;
+	}
+
+	/* Release SPI bus */
+	spi_release_bus(priv->spi);
+
+	kfree(tmpbuf);
+	kfree(command);
+	return res;
+}
+
+/* ......................................................................... */
+
+/*
+ * Initialize and register DataFlash device with MTD subsystem.
+ */
+static int __init add_dataflash(int channel, char *name, int IDsize,
+		int nr_pages, int pagesize, int pageoffset)
+{
+	struct mtd_info *device;
+	struct dataflash_local *priv;
+#ifdef CONFIG_MTD_PARTITIONS
+	struct mtd_partition *mtd_parts = 0;
+	int mtd_parts_nr = 0;
+#endif
+
+	if (nr_devices >= DATAFLASH_MAX_DEVICES) {
+		printk(KERN_ERR "at91_dataflash: Too many devices detected\n");
+		return 0;
+	}
+
+	device = kmalloc(sizeof(struct mtd_info) + strlen(name) + 8, GFP_KERNEL);
+	if (!device)
+		return -ENOMEM;
+	memset(device, 0, sizeof(struct mtd_info));
+
+	device->name = (char *)&device[1];
+	sprintf(device->name, "%s.spi%d", name, channel);
+	device->size = nr_pages * pagesize;
+	device->erasesize = pagesize;
+	device->writesize = pagesize;
+	device->owner = THIS_MODULE;
+	device->type = MTD_DATAFLASH;
+	device->flags = MTD_WRITEABLE;
+	device->erase = at91_dataflash_erase;
+	device->read = at91_dataflash_read;
+	device->write = at91_dataflash_write;
+
+	priv = (struct dataflash_local *) kmalloc(sizeof(struct dataflash_local), GFP_KERNEL);
+	if (!priv) {
+		kfree(device);
+		return -ENOMEM;
+	}
+	memset(priv, 0, sizeof(struct dataflash_local));
+
+	priv->spi = channel;
+	priv->page_size = pagesize;
+	priv->page_offset = pageoffset;
+	device->priv = priv;
+
+	mtd_devices[nr_devices] = device;
+	nr_devices++;
+	printk("at91_dataflash: %s detected [spi%i] (%i bytes)\n", name, channel, device->size);
+
+#ifdef CONFIG_MTD_PARTITIONS
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	mtd_parts_nr = parse_mtd_partitions(device, part_probes, &mtd_parts, 0);
+#endif
+	if (mtd_parts_nr <= 0) {
+		switch (IDsize) {
+			case SZ_2M:
+				mtd_parts = static_partitions_2M;
+				mtd_parts_nr = ARRAY_SIZE(static_partitions_2M);
+				break;
+			case SZ_4M:
+				mtd_parts = static_partitions_4M;
+				mtd_parts_nr = ARRAY_SIZE(static_partitions_4M);
+				break;
+			case SZ_8M:
+				mtd_parts = static_partitions_8M;
+				mtd_parts_nr = ARRAY_SIZE(static_partitions_8M);
+				break;
+		}
+	}
+
+	if (mtd_parts_nr > 0) {
+#ifdef DATAFLASH_ALWAYS_ADD_DEVICE
+		add_mtd_device(device);
+#endif
+		return add_mtd_partitions(device, mtd_parts, mtd_parts_nr);
+	}
+#endif
+	return add_mtd_device(device);		/* add whole device */
+}
+
+/*
+ * Detect and initialize DataFlash device connected to specified SPI channel.
+ *
+ *   Device            Density         ID code                 Nr Pages        Page Size       Page offset
+ *   AT45DB011B        1Mbit   (128K)  xx0011xx (0x0c)         512             264             9
+ *   AT45DB021B        2Mbit   (256K)  xx0101xx (0x14)         1025            264             9
+ *   AT45DB041B        4Mbit   (512K)  xx0111xx (0x1c)         2048            264             9
+ *   AT45DB081B        8Mbit   (1M)    xx1001xx (0x24)         4096            264             9
+ *   AT45DB0161B       16Mbit  (2M)    xx1011xx (0x2c)         4096            528             10
+ *   AT45DB0321B       32Mbit  (4M)    xx1101xx (0x34)         8192            528             10
+ *   AT45DB0642        64Mbit  (8M)    xx1111xx (0x3c)         8192            1056            11
+ *   AT45DB1282        128Mbit (16M)   xx0100xx (0x10)         16384           1056            11
+ */
+static int __init at91_dataflash_detect(int channel)
+{
+	int res = 0;
+	unsigned short status;
+
+	spi_access_bus(channel);
+	status = at91_dataflash_status();
+	spi_release_bus(channel);
+	if (status != 0xff) {			/* no dataflash device there */
+		switch (status & 0x3c) {
+			case 0x0c:	/* 0 0 1 1 */
+				res = add_dataflash(channel, "AT45DB011B", SZ_128K, 512, 264, 9);
+				break;
+			case 0x14:	/* 0 1 0 1 */
+				res = add_dataflash(channel, "AT45DB021B", SZ_256K, 1025, 264, 9);
+				break;
+			case 0x1c:	/* 0 1 1 1 */
+				res = add_dataflash(channel, "AT45DB041B", SZ_512K, 2048, 264, 9);
+				break;
+			case 0x24:	/* 1 0 0 1 */
+				res = add_dataflash(channel, "AT45DB081B", SZ_1M, 4096, 264, 9);
+				break;
+			case 0x2c:	/* 1 0 1 1 */
+				res = add_dataflash(channel, "AT45DB161B", SZ_2M, 4096, 528, 10);
+				break;
+			case 0x34:	/* 1 1 0 1 */
+				res = add_dataflash(channel, "AT45DB321B", SZ_4M, 8192, 528, 10);
+				break;
+			case 0x3c:	/* 1 1 1 1 */
+				res = add_dataflash(channel, "AT45DB642", SZ_8M, 8192, 1056, 11);
+				break;
+// Currently unsupported since Atmel removed the "Main Memory Program via Buffer" commands.
+//			case 0x10:	/* 0 1 0 0 */
+//				res = add_dataflash(channel, "AT45DB1282", SZ_16M, 16384, 1056, 11);
+//				break;
+			default:
+				printk(KERN_ERR "at91_dataflash: Unknown device (%x)\n", status & 0x3c);
+		}
+	}
+
+	return res;
+}
+
+static int __init at91_dataflash_init(void)
+{
+	spi_transfer_desc = kmalloc(sizeof(struct spi_transfer_list), GFP_KERNEL);
+	if (!spi_transfer_desc)
+		return -ENOMEM;
+
+	/* DataFlash (SPI chip select 0) */
+	at91_dataflash_detect(0);
+
+#ifdef CONFIG_MTD_AT91_DATAFLASH_CARD
+	/* DataFlash card (SPI chip select 3) */
+	at91_dataflash_detect(3);
+#endif
+
+	return 0;
+}
+
+static void __exit at91_dataflash_exit(void)
+{
+	int i;
+
+	for (i = 0; i < DATAFLASH_MAX_DEVICES; i++) {
+		if (mtd_devices[i]) {
+#ifdef CONFIG_MTD_PARTITIONS
+			del_mtd_partitions(mtd_devices[i]);
+#else
+			del_mtd_device(mtd_devices[i]);
+#endif
+			kfree(mtd_devices[i]->priv);
+			kfree(mtd_devices[i]);
+		}
+	}
+	nr_devices = 0;
+	kfree(spi_transfer_desc);
+}
+
+
+module_init(at91_dataflash_init);
+module_exit(at91_dataflash_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andrew Victor");
+MODULE_DESCRIPTION("DataFlash driver for Atmel AT91RM9200");
Index: linux-2.6.21.7/drivers/mtd/nand/at91_nand.c
===================================================================
--- linux-2.6.21.7.orig/drivers/mtd/nand/at91_nand.c
+++ linux-2.6.21.7/drivers/mtd/nand/at91_nand.c
@@ -82,6 +82,10 @@ static void at91_nand_disable(struct at9
 		at91_set_gpio_value(host->board->enable_pin, 1);
 }
 
+#ifdef CONFIG_MTD_PARTITIONS
+const char *part_probes[] = { "cmdlinepart", NULL };
+#endif
+
 /*
  * Probe for the NAND device.
  */
@@ -151,6 +155,12 @@ static int __init at91_nand_probe(struct
 #ifdef CONFIG_MTD_PARTITIONS
 	if (host->board->partition_info)
 		partitions = host->board->partition_info(mtd->size, &num_partitions);
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	else {
+		mtd->name = "at91_nand";
+		num_partitions = parse_mtd_partitions(mtd, part_probes, &partitions, 0);
+	}
+#endif
 
 	if ((!partitions) || (num_partitions == 0)) {
 		printk(KERN_ERR "at91_nand: No parititions defined, or unsupported device.\n");
Index: linux-2.6.21.7/drivers/net/arm/at91_ether.c
===================================================================
--- linux-2.6.21.7.orig/drivers/net/arm/at91_ether.c
+++ linux-2.6.21.7/drivers/net/arm/at91_ether.c
@@ -225,6 +225,16 @@ static irqreturn_t at91ether_phy_interru
 		if (!(phy & ((1 << 2) | 1)))
 			goto done;
 	}
+	else if (lp->phy_type == MII_T78Q21x3_ID) {			/* ack interrupt in Teridian PHY */
+		read_phy(lp->phy_address, MII_T78Q21INT_REG, &phy);
+		if (!(phy & ((1 << 2) | 1)))
+			goto done;
+	}
+	else if (lp->phy_type == MII_DP83848_ID) {
+		read_phy(lp->phy_address, MII_DPPHYSTS_REG, &phy);	/* ack interrupt in DP83848 PHY */
+		if (!(phy & (1 << 7)))
+			goto done;
+	}
 
 	update_linkspeed(dev, 0);
 
@@ -280,6 +290,19 @@ static void enable_phyirq(struct net_dev
 		dsintr = (1 << 10) | ( 1 << 8);
 		write_phy(lp->phy_address, MII_TPISTATUS, dsintr);
 	}
+	else if (lp->phy_type == MII_T78Q21x3_ID) {	/* for Teridian PHY */
+		read_phy(lp->phy_address, MII_T78Q21INT_REG, &dsintr);
+		dsintr = dsintr | 0x500;		/* set bits 8, 10 */
+		write_phy(lp->phy_address, MII_T78Q21INT_REG, dsintr);
+	}
+	else if (lp->phy_type == MII_DP83848_ID) {	/* National Semiconductor DP83848 PHY */
+		read_phy(lp->phy_address, MII_DPMISR_REG, &dsintr);
+		dsintr = dsintr | 0x3c;			/* set bits 2..5 */
+		write_phy(lp->phy_address, MII_DPMISR_REG, dsintr);
+		read_phy(lp->phy_address, MII_DPMICR_REG, &dsintr);
+		dsintr = dsintr | 0x3;			/* set bits 0,1 */
+		write_phy(lp->phy_address, MII_DPMICR_REG, dsintr);
+	}
 
 	disable_mdi();
 	spin_unlock_irq(&lp->lock);
@@ -323,6 +346,19 @@ static void disable_phyirq(struct net_de
 		dsintr = ~((1 << 10) | (1 << 8));
 		write_phy(lp->phy_address, MII_TPISTATUS, dsintr);
 	}
+	else if (lp->phy_type == MII_T78Q21x3_ID) {	/* for Teridian PHY */
+		read_phy(lp->phy_address, MII_T78Q21INT_REG, &dsintr);
+		dsintr = dsintr & ~0x500;			/* clear bits 8, 10 */
+		write_phy(lp->phy_address, MII_T78Q21INT_REG, dsintr);
+	}
+	else if (lp->phy_type == MII_DP83848_ID) {	/* National Semiconductor DP83848 PHY */
+		read_phy(lp->phy_address, MII_DPMICR_REG, &dsintr);
+		dsintr = dsintr & ~0x3;				/* clear bits 0, 1 */
+		write_phy(lp->phy_address, MII_DPMICR_REG, dsintr);
+		read_phy(lp->phy_address, MII_DPMISR_REG, &dsintr);
+		dsintr = dsintr & ~0x3c;			/* clear bits 2..5 */
+		write_phy(lp->phy_address, MII_DPMISR_REG, dsintr);
+	}
 
 	disable_mdi();
 	spin_unlock_irq(&lp->lock);
@@ -535,8 +571,8 @@ static void at91ether_sethashtable(struc
 		mc_filter[bitnr >> 5] |= 1 << (bitnr & 31);
 	}
 
-	at91_emac_write(AT91_EMAC_HSH, mc_filter[0]);
-	at91_emac_write(AT91_EMAC_HSL, mc_filter[1]);
+	at91_emac_write(AT91_EMAC_HSL, mc_filter[0]);
+	at91_emac_write(AT91_EMAC_HSH, mc_filter[1]);
 }
 
 /*
@@ -943,14 +979,22 @@ static int __init at91ether_setup(unsign
 	struct net_device *dev;
 	struct at91_private *lp;
 	unsigned int val;
-	int res;
+	struct resource *res;
+	int ret;
 
 	dev = alloc_etherdev(sizeof(struct at91_private));
 	if (!dev)
 		return -ENOMEM;
 
-	dev->base_addr = AT91_VA_BASE_EMAC;
-	dev->irq = AT91RM9200_ID_EMAC;
+	/* Get I/O base address and IRQ */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		free_netdev(dev);
+		return -ENODEV;
+	}
+	dev->base_addr = res->start;
+	dev->irq = platform_get_irq(pdev, 0);
+
 	SET_MODULE_OWNER(dev);
 
 	/* Install the interrupt handler */
@@ -1023,12 +1067,12 @@ static int __init at91ether_setup(unsign
 	lp->phy_address = phy_address;	/* MDI address of PHY */
 
 	/* Register the network interface */
-	res = register_netdev(dev);
-	if (res) {
+	ret = register_netdev(dev);
+	if (ret) {
 		free_irq(dev->irq, dev);
 		free_netdev(dev);
 		dma_free_coherent(NULL, sizeof(struct recv_desc_bufs), lp->dlist, (dma_addr_t)lp->dlist_phys);
-		return res;
+		return ret;
 	}
 
 	/* Determine current link speed */
@@ -1063,10 +1107,16 @@ static int __init at91ether_setup(unsign
 		printk(KERN_INFO "%s: Broadcom BCM5221 PHY\n", dev->name);
 	else if (phy_type == MII_DP83847_ID)
 		printk(KERN_INFO "%s: National Semiconductor DP83847 PHY\n", dev->name);
+	else if (phy_type == MII_DP83848_ID)
+		printk(KERN_INFO "%s: National Semiconductor DP83848 PHY\n", dev->name);
 	else if (phy_type == MII_AC101L_ID)
 		printk(KERN_INFO "%s: Altima AC101L PHY\n", dev->name);
 	else if (phy_type == MII_KS8721_ID)
 		printk(KERN_INFO "%s: Micrel KS8721 PHY\n", dev->name);
+	else if (phy_type == MII_T78Q21x3_ID)
+		printk(KERN_INFO "%s: Teridian 78Q21x3 PHY\n", dev->name);
+	else if (phy_type == MII_LAN83C185_ID)
+		printk(KERN_INFO "%s: SMSC LAN83C185 PHY\n", dev->name);
 
 	return 0;
 }
@@ -1104,8 +1154,11 @@ static int __init at91ether_probe(struct
 			case MII_RTL8201_ID:		/* Realtek RTL8201: PHY_ID1 = 0, PHY_ID2 = 0x8201 */
 			case MII_BCM5221_ID:		/* Broadcom BCM5221: PHY_ID1 = 0x40, PHY_ID2 = 0x61e0 */
 			case MII_DP83847_ID:		/* National Semiconductor DP83847:  */
+			case MII_DP83848_ID:		/* National Semiconductor DP83848:  */
 			case MII_AC101L_ID:		/* Altima AC101L: PHY_ID1 = 0x22, PHY_ID2 = 0x5520 */
 			case MII_KS8721_ID:		/* Micrel KS8721: PHY_ID1 = 0x22, PHY_ID2 = 0x1610 */
+			case MII_T78Q21x3_ID:		/* Teridian 78Q21x3: PHY_ID1 = 0x0E, PHY_ID2 = 7237 */
+			case MII_LAN83C185_ID:		/* SMSC LAN83C185: PHY_ID1 = 0x0007, PHY_ID2 = 0xC0A1 */
 				detected = at91ether_setup(phy_id, phy_address, pdev, ether_clk);
 				break;
 		}
Index: linux-2.6.21.7/drivers/net/arm/at91_ether.h
===================================================================
--- linux-2.6.21.7.orig/drivers/net/arm/at91_ether.h
+++ linux-2.6.21.7/drivers/net/arm/at91_ether.h
@@ -17,39 +17,46 @@
 
 
 /* Davicom 9161 PHY */
-#define MII_DM9161_ID	0x0181b880
-#define MII_DM9161A_ID	0x0181b8a0
-
-/* Davicom specific registers */
-#define MII_DSCR_REG	16
-#define MII_DSCSR_REG	17
-#define MII_DSINTR_REG	21
+#define MII_DM9161_ID		0x0181b880
+#define MII_DM9161A_ID		0x0181b8a0
+#define MII_DSCR_REG		16
+#define MII_DSCSR_REG		17
+#define MII_DSINTR_REG		21
 
 /* Intel LXT971A PHY */
-#define MII_LXT971A_ID	0x001378E0
-
-/* Intel specific registers */
-#define MII_ISINTE_REG	18
-#define MII_ISINTS_REG	19
-#define MII_LEDCTRL_REG	20
+#define MII_LXT971A_ID		0x001378E0
+#define MII_ISINTE_REG		18
+#define MII_ISINTS_REG		19
+#define MII_LEDCTRL_REG		20
 
 /* Realtek RTL8201 PHY */
-#define MII_RTL8201_ID	0x00008200
+#define MII_RTL8201_ID		0x00008200
 
 /* Broadcom BCM5221 PHY */
-#define MII_BCM5221_ID	0x004061e0
-
-/* Broadcom specific registers */
-#define MII_BCMINTR_REG	26
+#define MII_BCM5221_ID		0x004061e0
+#define MII_BCMINTR_REG		26
 
 /* National Semiconductor DP83847 */
-#define MII_DP83847_ID	0x20005c30
+#define MII_DP83847_ID		0x20005c30
+
+/* National Semiconductor DP83848 */
+#define MII_DP83848_ID		0x20005c90
+#define MII_DPPHYSTS_REG	16
+#define MII_DPMICR_REG		17
+#define MII_DPMISR_REG		18
 
 /* Altima AC101L PHY */
-#define MII_AC101L_ID	0x00225520
+#define MII_AC101L_ID		0x00225520
 
 /* Micrel KS8721 PHY */
-#define MII_KS8721_ID	0x00221610
+#define MII_KS8721_ID		0x00221610
+
+/* Teridian 78Q2123/78Q2133 */
+#define MII_T78Q21x3_ID		0x000e7230
+#define MII_T78Q21INT_REG	17
+
+/* SMSC LAN83C185 */
+#define MII_LAN83C185_ID	0x0007C0A0
 
 /* ........................................................................ */
 
Index: linux-2.6.21.7/drivers/pcmcia/at91_cf.c
===================================================================
--- linux-2.6.21.7.orig/drivers/pcmcia/at91_cf.c
+++ linux-2.6.21.7/drivers/pcmcia/at91_cf.c
@@ -332,20 +332,27 @@ static int at91_cf_suspend(struct platfo
 	struct at91_cf_data	*board = cf->board;
 
 	pcmcia_socket_dev_suspend(&pdev->dev, mesg);
+
 	if (device_may_wakeup(&pdev->dev)) {
 		enable_irq_wake(board->det_pin);
 		if (board->irq_pin)
 			enable_irq_wake(board->irq_pin);
-	} else {
-		disable_irq_wake(board->det_pin);
-		if (board->irq_pin)
-			disable_irq_wake(board->irq_pin);
 	}
+
 	return 0;
 }
 
 static int at91_cf_resume(struct platform_device *pdev)
 {
+	struct at91_cf_socket	*cf = platform_get_drvdata(pdev);
+	struct at91_cf_data	*board = cf->board;
+
+	if (device_may_wakeup(&pdev->dev)) {
+		disable_irq_wake(board->det_pin);
+		if (board->irq_pin)
+			disable_irq_wake(board->irq_pin);
+	}
+
 	pcmcia_socket_dev_resume(&pdev->dev);
 	return 0;
 }
@@ -360,7 +367,6 @@ static struct platform_driver at91_cf_dr
 		.name		= (char *) driver_name,
 		.owner		= THIS_MODULE,
 	},
-	.probe		= at91_cf_probe,
 	.remove		= __exit_p(at91_cf_remove),
 	.suspend	= at91_cf_suspend,
 	.resume		= at91_cf_resume,
@@ -370,7 +376,7 @@ static struct platform_driver at91_cf_dr
 
 static int __init at91_cf_init(void)
 {
-	return platform_driver_register(&at91_cf_driver);
+	return platform_driver_probe(&at91_cf_driver, at91_cf_probe);
 }
 module_init(at91_cf_init);
 
Index: linux-2.6.21.7/drivers/serial/atmel_serial.c
===================================================================
--- linux-2.6.21.7.orig/drivers/serial/atmel_serial.c
+++ linux-2.6.21.7/drivers/serial/atmel_serial.c
@@ -7,6 +7,8 @@
  *  Based on drivers/char/serial_sa1100.c, by Deep Blue Solutions Ltd.
  *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
  *
+ *  DMA support added by Chip Coldwell.
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -33,6 +35,7 @@
 #include <linux/sysrq.h>
 #include <linux/tty_flip.h>
 #include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
 #include <linux/atmel_pdc.h>
 
 #include <asm/io.h>
@@ -47,6 +50,11 @@
 
 #include "atmel_serial.h"
 
+#define SUPPORT_PDC
+#define PDC_BUFFER_SIZE		(L1_CACHE_BYTES << 3)
+#warning "Revisit"
+#define PDC_RX_TIMEOUT		(3 * 10)		/* 3 bytes */
+
 #if defined(CONFIG_SERIAL_ATMEL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
 #define SUPPORT_SYSRQ
 #endif
@@ -107,6 +115,13 @@
 static int (*atmel_open_hook)(struct uart_port *);
 static void (*atmel_close_hook)(struct uart_port *);
 
+struct atmel_dma_buffer {
+	unsigned char	*buf;
+	dma_addr_t	dma_addr;
+	size_t		dma_size;
+	unsigned int	ofs;
+};
+
 /*
  * We wrap our port structure around the generic uart_port.
  */
@@ -114,10 +129,20 @@ struct atmel_uart_port {
 	struct uart_port	uart;		/* uart */
 	struct clk		*clk;		/* uart clock */
 	unsigned short		suspended;	/* is port suspended? */
+
+	short			use_dma_rx;	/* enable PDC receiver */
+	short			pdc_rx_idx;	/* current PDC RX buffer */
+	struct atmel_dma_buffer	pdc_rx[2];	/* PDC receier */
+
+	short			use_dma_tx;	/* enable PDC transmitter */
+	struct atmel_dma_buffer	pdc_tx;		/* PDC transmitter */
 };
 
 static struct atmel_uart_port atmel_ports[ATMEL_MAX_UART];
 
+#define PDC_RX_BUF(port)	&(port)->pdc_rx[(port)->pdc_rx_idx]
+#define PDC_RX_SWITCH(port)	(port)->pdc_rx_idx = !(port)->pdc_rx_idx
+
 #ifdef SUPPORT_SYSRQ
 static struct console atmel_console;
 #endif
@@ -205,7 +230,12 @@ static void atmel_stop_tx(struct uart_po
 {
 	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
 
-	UART_PUT_IDR(port, ATMEL_US_TXRDY);
+	if (atmel_port->use_dma_tx) {
+		UART_PUT_PTCR(port, ATMEL_PDC_TXTDIS);		/* disable PDC transmit */
+		UART_PUT_IDR(port, ATMEL_US_ENDTX | ATMEL_US_TXBUFE);
+	}
+	else
+		UART_PUT_IDR(port, ATMEL_US_TXRDY);
 }
 
 /*
@@ -215,7 +245,17 @@ static void atmel_start_tx(struct uart_p
 {
 	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
 
-	UART_PUT_IER(port, ATMEL_US_TXRDY);
+	if (atmel_port->use_dma_tx) {
+		if (UART_GET_PTSR(port) & ATMEL_PDC_TXTEN)
+			/* The transmitter is already running.  Yes, we
+			   really need this.*/
+			return;
+
+		UART_PUT_IER(port, ATMEL_US_ENDTX | ATMEL_US_TXBUFE);
+		UART_PUT_PTCR(port, ATMEL_PDC_TXTEN);		/* re-enable PDC transmit */
+	}
+	else
+		UART_PUT_IER(port, ATMEL_US_TXRDY);
 }
 
 /*
@@ -225,7 +265,12 @@ static void atmel_stop_rx(struct uart_po
 {
 	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
 
-	UART_PUT_IDR(port, ATMEL_US_RXRDY);
+	if (atmel_port->use_dma_rx) {
+		UART_PUT_PTCR(port, ATMEL_PDC_RXTDIS);		/* disable PDC receive */
+		UART_PUT_IDR(port, ATMEL_US_ENDRX | ATMEL_US_TIMEOUT);
+	}
+	else
+		UART_PUT_IDR(port, ATMEL_US_RXRDY);
 }
 
 /*
@@ -248,6 +293,134 @@ static void atmel_break_ctl(struct uart_
 }
 
 /*
+ * Receive data via the PDC.  A buffer has been fulled.
+ */
+static void atmel_pdc_endrx(struct uart_port *port)
+{
+	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
+	struct tty_struct *tty = port->info->tty;
+	struct atmel_dma_buffer *pdc = PDC_RX_BUF(atmel_port);
+	unsigned int count;
+
+	count = pdc->dma_size - pdc->ofs;
+	if (likely(count > 0)) {
+		dma_sync_single_for_cpu(port->dev, pdc->dma_addr, pdc->dma_size, DMA_FROM_DEVICE);
+		tty_insert_flip_string(tty, pdc->buf + pdc->ofs, count);
+		tty_flip_buffer_push(tty);
+
+		port->icount.rx += count;
+	}
+
+	/* Set this buffer as the next receive buffer */
+	pdc->ofs = 0;
+	UART_PUT_RNPR(port, pdc->dma_addr);
+	UART_PUT_RNCR(port, pdc->dma_size);
+
+	/* Switch to next buffer */
+	PDC_RX_SWITCH(atmel_port);		/* next PDC buffer */
+}
+
+/*
+ * Receive data via the PDC.  At least one byte was received, but the
+ * buffer was not full when the inter-character timeout expired.
+ */
+static void atmel_pdc_timeout(struct uart_port *port)
+{
+	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
+	struct tty_struct *tty = port->info->tty;
+	struct atmel_dma_buffer *pdc = PDC_RX_BUF(atmel_port);
+	/* unsigned */ int ofs, count;
+
+	ofs = UART_GET_RPR(port) - pdc->dma_addr;	/* current DMA adress */
+	count = ofs - pdc->ofs;
+
+	if (likely(count > 0)) {
+		dma_sync_single_for_cpu(port->dev, pdc->dma_addr, pdc->dma_size, DMA_FROM_DEVICE);
+		tty_insert_flip_string(tty, pdc->buf + pdc->ofs, count);
+		tty_flip_buffer_push(tty);
+
+		pdc->ofs = ofs;
+		port->icount.rx += count;
+	}
+
+	/* reset the UART timeout */
+	UART_PUT_CR(port, ATMEL_US_STTTO);
+}
+
+/*
+ * Deal with parity, framing and overrun errors.
+ */
+static void atmel_pdc_rxerr(struct uart_port *port, unsigned int status)
+{
+	/* clear error */
+	UART_PUT_CR(port, ATMEL_US_RSTSTA);
+
+	if (status & ATMEL_US_RXBRK) {
+		status &= ~(ATMEL_US_PARE | ATMEL_US_FRAME);	/* ignore side-effect */
+		port->icount.brk++;
+	}
+	if (status & ATMEL_US_PARE)
+		port->icount.parity++;
+	if (status & ATMEL_US_FRAME)
+		port->icount.frame++;
+	if (status & ATMEL_US_OVRE)
+		port->icount.overrun++;
+}
+
+/*
+ * A transmission via the PDC is complete.
+ */
+static void atmel_pdc_endtx(struct uart_port *port)
+{
+	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
+	struct circ_buf *xmit = &port->info->xmit;
+	struct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;
+
+	xmit->tail += pdc->ofs;
+	if (xmit->tail >= SERIAL_XMIT_SIZE)
+		xmit->tail -= SERIAL_XMIT_SIZE;
+
+	port->icount.tx += pdc->ofs;
+	pdc->ofs = 0;
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+}
+
+/*
+ * The PDC transmitter is idle, so either start the next transfer or
+ * disable the transmitter.
+ */
+static void atmel_pdc_txbufe(struct uart_port *port)
+{
+	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
+	struct circ_buf *xmit = &port->info->xmit;
+	struct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;
+	int count;
+
+	if (!uart_circ_empty(xmit)) {
+		/* more to transmit - setup next transfer */
+		UART_PUT_PTCR(port, ATMEL_PDC_TXTDIS);			/* disable PDC transmit */
+		dma_sync_single_for_device(port->dev, pdc->dma_addr, pdc->dma_size, DMA_TO_DEVICE);
+
+		if (xmit->tail < xmit->head)
+			count = xmit->head - xmit->tail;
+		else
+			count = SERIAL_XMIT_SIZE - xmit->tail;
+		pdc->ofs = count;
+
+		UART_PUT_TPR(port, pdc->dma_addr + xmit->tail);
+		UART_PUT_TCR(port, count);
+		UART_PUT_PTCR(port, ATMEL_PDC_TXTEN);			/* re-enable PDC transmit */
+	}
+	else {
+		/* nothing left to transmit - disable the transmitter */
+		UART_PUT_PTCR(port, ATMEL_PDC_TXTDIS);			/* disable PDC transmit */
+		UART_PUT_IDR(port, ATMEL_US_ENDTX | ATMEL_US_TXBUFE);
+	}
+}
+
+/*
  * Characters received (called from interrupt handler)
  */
 static void atmel_rx_chars(struct uart_port *port)
@@ -349,6 +522,14 @@ static irqreturn_t atmel_interrupt(int i
 	status = UART_GET_CSR(port);
 	pending = status & UART_GET_IMR(port);
 	while (pending) {
+		/* PDC receive */
+		if (pending & ATMEL_US_ENDRX)
+			atmel_pdc_endrx(port);
+		if (pending & ATMEL_US_TIMEOUT)
+			atmel_pdc_timeout(port);
+		if (atmel_port->use_dma_rx && pending & (ATMEL_US_RXBRK | ATMEL_US_OVRE | ATMEL_US_FRAME | ATMEL_US_PARE))
+			atmel_pdc_rxerr(port, pending);
+
 		/* Interrupt receive */
 		if (pending & ATMEL_US_RXRDY)
 			atmel_rx_chars(port);
@@ -363,6 +544,12 @@ static irqreturn_t atmel_interrupt(int i
 		if (pending & (ATMEL_US_RIIC | ATMEL_US_DSRIC | ATMEL_US_DCDIC | ATMEL_US_CTSIC))
 			wake_up_interruptible(&port->info->delta_msr_wait);
 
+		/* PDC transmit */
+		if (pending & ATMEL_US_ENDTX)
+			atmel_pdc_endtx(port);
+		if (pending & ATMEL_US_TXBUFE)
+			atmel_pdc_txbufe(port);
+
 		/* Interrupt transmit */
 		if (pending & ATMEL_US_TXRDY)
 			atmel_tx_chars(port);
@@ -401,6 +588,47 @@ static int atmel_startup(struct uart_por
 	}
 
 	/*
+	 * Initialize DMA (if necessary)
+	 */
+	if (atmel_port->use_dma_rx) {
+		int i;
+
+		for (i = 0; i < 2; i++) {
+			struct atmel_dma_buffer *pdc = &atmel_port->pdc_rx[i];
+
+			pdc->buf = kmalloc(PDC_BUFFER_SIZE, GFP_KERNEL);
+			if (pdc->buf == NULL) {
+				if (i != 0) {
+					dma_unmap_single(port->dev, atmel_port->pdc_rx[0].dma_addr, PDC_BUFFER_SIZE, DMA_FROM_DEVICE);
+					kfree(atmel_port->pdc_rx[0].buf);
+				}
+				free_irq(port->irq, port);
+				return -ENOMEM;
+			}
+			pdc->dma_addr = dma_map_single(port->dev, pdc->buf, PDC_BUFFER_SIZE, DMA_FROM_DEVICE);
+			pdc->dma_size = PDC_BUFFER_SIZE;
+			pdc->ofs = 0;
+		}
+
+		atmel_port->pdc_rx_idx = 0;
+
+		UART_PUT_RPR(port, atmel_port->pdc_rx[0].dma_addr);
+		UART_PUT_RCR(port, PDC_BUFFER_SIZE);
+
+		UART_PUT_RNPR(port, atmel_port->pdc_rx[1].dma_addr);
+		UART_PUT_RNCR(port, PDC_BUFFER_SIZE);
+	}
+	if (atmel_port->use_dma_tx) {
+		struct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;
+		struct circ_buf *xmit = &port->info->xmit;
+
+		pdc->buf = xmit->buf;
+		pdc->dma_addr = dma_map_single(port->dev, pdc->buf, SERIAL_XMIT_SIZE, DMA_TO_DEVICE);
+		pdc->dma_size = SERIAL_XMIT_SIZE;
+		pdc->ofs = 0;
+	}
+
+	/*
 	 * If there is a specific "open" function (to register
 	 * control line interrupts)
 	 */
@@ -418,7 +646,15 @@ static int atmel_startup(struct uart_por
 	UART_PUT_CR(port, ATMEL_US_RSTSTA | ATMEL_US_RSTRX);
 	UART_PUT_CR(port, ATMEL_US_TXEN | ATMEL_US_RXEN);		/* enable xmit & rcvr */
 
-	UART_PUT_IER(port, ATMEL_US_RXRDY);		/* enable receive only */
+	if (atmel_port->use_dma_rx) {
+		UART_PUT_RTOR(port, PDC_RX_TIMEOUT);		/* set UART timeout */
+		UART_PUT_CR(port, ATMEL_US_STTTO);
+
+		UART_PUT_IER(port, ATMEL_US_ENDRX | ATMEL_US_TIMEOUT);
+		UART_PUT_PTCR(port, ATMEL_PDC_RXTEN);		/* enable PDC controller */
+	}
+	else
+		UART_PUT_IER(port, ATMEL_US_RXRDY);		/* enable receive only */
 
 	return 0;
 }
@@ -431,6 +667,31 @@ static void atmel_shutdown(struct uart_p
 	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
 
 	/*
+	 * Ensure everything is stopped.
+	 */
+	atmel_stop_rx(port);
+	atmel_stop_tx(port);
+
+	/*
+	 * Shut-down the DMA.
+	 */
+	if (atmel_port->use_dma_rx) {
+		int i;
+
+		for (i = 0; i < 2; i++) {
+			struct atmel_dma_buffer *pdc = &atmel_port->pdc_rx[i];
+
+			dma_unmap_single(port->dev, pdc->dma_addr, pdc->dma_size, DMA_FROM_DEVICE);
+			kfree(pdc->buf);
+		}
+	}
+	if (atmel_port->use_dma_tx) {
+		struct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;
+
+		dma_unmap_single(port->dev, pdc->dma_addr, pdc->dma_size, DMA_TO_DEVICE);
+	}
+
+	/*
 	 * Disable all interrupts, port and break condition.
 	 */
 	UART_PUT_CR(port, ATMEL_US_RSTSTA);
@@ -481,14 +742,20 @@ static void atmel_serial_pm(struct uart_
  */
 static void atmel_set_termios(struct uart_port *port, struct ktermios * termios, struct ktermios * old)
 {
+	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
 	unsigned long flags;
 	unsigned int mode, imr, quot, baud;
 
+	/* Get current mode register */
+	mode = UART_GET_MR(port) & ~(ATMEL_US_USCLKS | ATMEL_US_CHRL | ATMEL_US_NBSTOP | ATMEL_US_PAR);
+
 	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
 	quot = uart_get_divisor(port, baud);
 
-	/* Get current mode register */
-	mode = UART_GET_MR(port) & ~(ATMEL_US_CHRL | ATMEL_US_NBSTOP | ATMEL_US_PAR);
+	if (quot > 65535) {	/* BRGR is 16-bit, so switch to slower clock */
+		quot /= 8;
+		mode |= ATMEL_US_USCLKS_MCK_DIV8;
+	}
 
 	/* byte size */
 	switch (termios->c_cflag & CSIZE) {
@@ -534,6 +801,9 @@ static void atmel_set_termios(struct uar
 	if (termios->c_iflag & (BRKINT | PARMRK))
 		port->read_status_mask |= ATMEL_US_RXBRK;
 
+	if (atmel_port->use_dma_rx)	/* need to enable error interrupts */
+		UART_PUT_IER(port, port->read_status_mask);
+
 	/*
 	 * Characters to ignore
 	 */
@@ -712,6 +982,13 @@ static void __devinit atmel_init_port(st
 		clk_enable(atmel_port->clk);
 		port->uartclk = clk_get_rate(atmel_port->clk);
 	}
+
+#ifdef SUPPORT_PDC
+	atmel_port->use_dma_rx = data->use_dma_rx;
+	atmel_port->use_dma_tx = data->use_dma_tx;
+	if (atmel_port->use_dma_tx)
+		port->fifosize = PDC_BUFFER_SIZE;
+#endif
 }
 
 /*
@@ -888,7 +1165,8 @@ static int atmel_serial_suspend(struct p
 	struct uart_port *port = platform_get_drvdata(pdev);
 	struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
 
-	if (device_may_wakeup(&pdev->dev) && !at91_suspend_entering_slow_clock())
+	if (device_may_wakeup(&pdev->dev)
+			&& !clk_must_disable(atmel_port->clk))
 		enable_irq_wake(port->irq);
 	else {
 		uart_suspend_port(&atmel_uart, port);
Index: linux-2.6.21.7/drivers/serial/atmel_serial.h
===================================================================
--- linux-2.6.21.7.orig/drivers/serial/atmel_serial.h
+++ linux-2.6.21.7/drivers/serial/atmel_serial.h
@@ -46,6 +46,9 @@
 #define			ATMEL_US_USMODE_ISO7816_T1	6
 #define			ATMEL_US_USMODE_IRDA		8
 #define		ATMEL_US_USCLKS		(3   <<  4)		/* Clock Selection */
+#define			ATMEL_US_USCLKS_MCK		(0 <<  4)
+#define			ATMEL_US_USCLKS_MCK_DIV8	(1 <<  4)
+#define			ATMEL_US_USCLKS_SCK		(3 <<  4)
 #define		ATMEL_US_CHRL		(3   <<  6)		/* Character Length */
 #define			ATMEL_US_CHRL_5			(0 <<  6)
 #define			ATMEL_US_CHRL_6			(1 <<  6)
Index: linux-2.6.21.7/drivers/spi/Kconfig
===================================================================
--- linux-2.6.21.7.orig/drivers/spi/Kconfig
+++ linux-2.6.21.7/drivers/spi/Kconfig
@@ -54,6 +54,7 @@ comment "SPI Master Controller Drivers"
 config SPI_ATMEL
 	tristate "Atmel SPI Controller"
 	depends on (ARCH_AT91 || AVR32) && SPI_MASTER
+	select SPI_AT91_MANUAL_CS if ARCH_AT91RM9200
 	help
 	  This selects a driver for the Atmel SPI Controller, present on
 	  many AT32 (AVR32) and AT91 (ARM) chips.
@@ -82,6 +83,24 @@ config SPI_BUTTERFLY
 	  inexpensive battery powered microcontroller evaluation board.
 	  This same cable can be used to flash new firmware.
 
+config SPI_AT91
+	tristate "AT91RM9200 Bitbang SPI Master"
+	depends on SPI_MASTER && ARCH_AT91RM9200 && !SPI_ATMEL && EXPERIMENTAL
+	select SPI_BITBANG
+	select SPI_AT91_MANUAL_CS
+	help
+	  This is dumb PIO bitbanging driver for the Atmel AT91RM9200.
+	  The SPI_ATMEL driver will be its replacement, using the native
+	  SPI hardware and its DMA controller.
+
+config SPI_AT91_MANUAL_CS
+	bool
+	depends on ARCH_AT91RM9200
+	help
+	  Works around an AT91RM9200 problem whereby the SPI chip-select
+	  will be wrongly disabled.  The workaround uses those pins as
+	  GPIOs instead of letting the SPI controller manage them.
+
 config SPI_IMX
 	tristate "Freescale iMX SPI controller"
 	depends on SPI_MASTER && ARCH_IMX && EXPERIMENTAL
Index: linux-2.6.21.7/drivers/spi/Makefile
===================================================================
--- linux-2.6.21.7.orig/drivers/spi/Makefile
+++ linux-2.6.21.7/drivers/spi/Makefile
@@ -20,6 +20,7 @@ obj-$(CONFIG_SPI_OMAP_UWIRE)		+= omap_uw
 obj-$(CONFIG_SPI_MPC83xx)		+= spi_mpc83xx.o
 obj-$(CONFIG_SPI_S3C24XX_GPIO)		+= spi_s3c24xx_gpio.o
 obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24xx.o
+obj-$(CONFIG_SPI_AT91)			+= spi_at91_bitbang.o
 # 	... add above this line ...
 
 # SPI protocol drivers (device/link on bus)
Index: linux-2.6.21.7/drivers/spi/spi_at91_bitbang.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/drivers/spi/spi_at91_bitbang.c
@@ -0,0 +1,207 @@
+/*
+ * at91_spi.c - at91 SPI driver (BOOTSTRAP/BITBANG VERSION)
+ *
+ * Copyright (C) 2006 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+
+#include <asm/arch/gpio.h>
+
+
+/*
+ * FIXME this bitbanging version is just to help bootstrap systems until
+ * there's a native SPI+IRQ+DMA controller driver ... such a driver should
+ * be a drop-in replacement for this one, and much faster.
+ *
+ * remember:
+ *
+ *	- other at91 parts (like at91sam9) have multiple controllers
+ *	  and different pin muxing; this version is at91rm9200 specfic.
+ *
+ *	- at91sam9261 SPI0 pins are directly muxed with MMC/SD pins.
+ *
+ *	- rm9200 spi chipselects drop wrongly, so the native driver
+ *	  will need to use gpios much like this does.
+ *
+ *	- real hardware only allows 8..16 bits per word, while this
+ *	  bitbanger allows 1..32 (incompatible superset).
+ *
+ *	- this disregards clock parameters.  with inlined gpio calls,
+ *	  gcc 3.4.4 produces about 1.5 mbit/sec, more than 2x faster
+ *	  than using the subroutined veresion from txrx_word().
+ *
+ *	- suspend/resume and <linux/clk.h> support is missing ...
+ */
+
+#define	spi_miso_bit	AT91_PIN_PA0
+#define	spi_mosi_bit	AT91_PIN_PA1
+#define	spi_sck_bit	AT91_PIN_PA2
+
+struct at91_spi {
+	struct spi_bitbang	bitbang;
+	struct platform_device	*pdev;
+};
+
+/*----------------------------------------------------------------------*/
+
+static inline void setsck(struct spi_device *spi, int is_on)
+{
+	at91_set_gpio_value(spi_sck_bit, is_on);
+}
+
+static inline void setmosi(struct spi_device *spi, int is_on)
+{
+	at91_set_gpio_value(spi_mosi_bit, is_on);
+}
+
+static inline int getmiso(struct spi_device *spi)
+{
+	return at91_get_gpio_value(spi_miso_bit);
+}
+
+static void at91_spi_chipselect(struct spi_device *spi, int is_active)
+{
+	unsigned long cs = (unsigned long) spi->controller_data;
+
+	/* set default clock polarity */
+	if (is_active)
+		setsck(spi, spi->mode & SPI_CPOL);
+
+	/* only support active-low (default) */
+	at91_set_gpio_value(cs, !is_active);
+}
+
+/*
+ * NOTE:  this is "as fast as we can"; it should be a function of
+ * the device clock ...
+ */
+#define	spidelay(X)	do{} while(0)
+
+#define	EXPAND_BITBANG_TXRX
+#include <linux/spi/spi_bitbang.h>
+
+static u32 at91_spi_txrx_word_mode0(struct spi_device *spi,
+		unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, 8);
+}
+
+static u32 at91_spi_txrx_word_mode1(struct spi_device *spi,
+		unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha1(spi, nsecs, 0, word, 8);
+}
+
+static u32 at91_spi_txrx_word_mode2(struct spi_device *spi,
+		unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha0(spi, nsecs, 1, word, 8);
+}
+
+static u32 at91_spi_txrx_word_mode3(struct spi_device *spi,
+		unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha1(spi, nsecs, 1, word, 8);
+}
+
+/*----------------------------------------------------------------------*/
+
+static int __init at91_spi_probe(struct platform_device *pdev)
+{
+	int			status;
+	struct spi_master	*master;
+	struct at91_spi		*at91_spi;
+
+	if (pdev->id != 0)	/* SPI0 bus */
+		return -EINVAL;
+
+	master = spi_alloc_master(&pdev->dev, sizeof *at91_spi);
+	if (!master)
+		return -ENOMEM;
+
+	at91_spi = spi_master_get_devdata(master);
+	at91_spi->pdev = pdev;
+	platform_set_drvdata(pdev, at91_spi);
+
+	/* SPI and bitbang hookup */
+	master->bus_num = 0;
+	master->num_chipselect = 4;
+
+	at91_spi->bitbang.master = spi_master_get(master);
+	at91_spi->bitbang.chipselect = at91_spi_chipselect;
+	at91_spi->bitbang.txrx_word[SPI_MODE_0] = at91_spi_txrx_word_mode0;
+	at91_spi->bitbang.txrx_word[SPI_MODE_1] = at91_spi_txrx_word_mode1;
+	at91_spi->bitbang.txrx_word[SPI_MODE_2] = at91_spi_txrx_word_mode2;
+	at91_spi->bitbang.txrx_word[SPI_MODE_3] = at91_spi_txrx_word_mode3;
+
+	status = spi_bitbang_start(&at91_spi->bitbang);
+	if (status < 0)
+		(void) spi_master_put(at91_spi->bitbang.master);
+
+	return status;
+}
+
+static int __exit at91_spi_remove(struct platform_device *pdev)
+{
+	struct at91_spi	*at91_spi = platform_get_drvdata(pdev);
+	int status;
+
+	/* stop() unregisters child devices too */
+	status = spi_bitbang_stop(&at91_spi->bitbang);
+	(void) spi_master_put(at91_spi->bitbang.master);
+
+	platform_set_drvdata(pdev, NULL);
+	return status;
+}
+
+static struct platform_driver at91_spi_driver = {
+	.probe		= at91_spi_probe,
+	.remove		= __exit_p(at91_spi_remove),
+	.driver		= {
+		.name	= "at91_spi",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init at91_spi_init(void)
+{
+	at91_set_gpio_output(spi_sck_bit, 0);
+	at91_set_gpio_output(spi_mosi_bit, 0);
+	at91_set_gpio_input(spi_miso_bit, 1 /* pullup */);
+
+	/* register driver */
+	return platform_driver_register(&at91_spi_driver);
+}
+
+static void __exit at91_spi_exit(void)
+{
+	platform_driver_unregister(&at91_spi_driver);
+}
+
+device_initcall(at91_spi_init);
+module_exit(at91_spi_exit);
+
+MODULE_ALIAS("at91_spi.0");
+
+MODULE_DESCRIPTION("AT91 SPI support (BOOTSTRAP/BITBANG VERSION)");
+MODULE_AUTHOR("David Brownell");
+MODULE_LICENSE("GPL");
Index: linux-2.6.21.7/drivers/usb/gadget/Kconfig
===================================================================
--- linux-2.6.21.7.orig/drivers/usb/gadget/Kconfig
+++ linux-2.6.21.7/drivers/usb/gadget/Kconfig
@@ -189,7 +189,7 @@ config USB_OTG
 
 config USB_GADGET_AT91
 	boolean "AT91 USB Device Port"
-	depends on ARCH_AT91
+	depends on ARCH_AT91 && !ARCH_AT91SAM9RL
 	select USB_GADGET_SELECTED
 	help
 	   Many Atmel AT91 processors (such as the AT91RM2000) have a
Index: linux-2.6.21.7/drivers/usb/gadget/at91_udc.c
===================================================================
--- linux-2.6.21.7.orig/drivers/usb/gadget/at91_udc.c
+++ linux-2.6.21.7/drivers/usb/gadget/at91_udc.c
@@ -1804,7 +1804,7 @@ static int at91udc_suspend(struct platfo
 	 */
 	if ((!udc->suspended && udc->addr)
 			|| !wake
-			|| at91_suspend_entering_slow_clock()) {
+			|| clk_must_disable(udc->fclk)) {
 		pullup(udc, 0);
 		wake = 0;
 	} else
Index: linux-2.6.21.7/drivers/usb/host/ohci-at91.c
===================================================================
--- linux-2.6.21.7.orig/drivers/usb/host/ohci-at91.c
+++ linux-2.6.21.7/drivers/usb/host/ohci-at91.c
@@ -299,7 +299,7 @@ ohci_hcd_at91_drv_suspend(struct platfor
 	 *
 	 * REVISIT: some boards will be able to turn VBUS off...
 	 */
-	if (at91_suspend_entering_slow_clock()) {
+	if (clk_must_disable(fclk)) {
 		ohci_usb_reset (ohci);
 		at91_stop_clock();
 	}
Index: linux-2.6.21.7/drivers/video/Kconfig
===================================================================
--- linux-2.6.21.7.orig/drivers/video/Kconfig
+++ linux-2.6.21.7/drivers/video/Kconfig
@@ -663,6 +663,17 @@ config FB_EPSON1355
 	  framebuffer.  Product specs at
 	  <http://www.erd.epson.com/vdc/html/products.htm>.
 
+config FB_S1D15605
+	tristate "Epson S1D15605 framebuffer support"
+	depends on FB
+	default m if MACH_KB9200
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  Build in support for the S1D15605 Epson Research 128x64
+	  LCD controller as a framebuffer.
+
 config FB_S1D13XXX
 	tristate "Epson S1D13XXX framebuffer support"
 	depends on FB
@@ -674,6 +685,22 @@ config FB_S1D13XXX
 	  working with S1D13806). Product specs at
 	  <http://www.erd.epson.com/vdc/html/legacy_13xxx.htm>
 
+config FB_ATMEL
+	tristate "AT91/AT32 LCD Controller support"
+	depends on FB && (ARCH_AT91SAM9261 || ARCH_AT91SAM9263 || ARCH_AT91SAM9RL || AVR32)
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  This enables support for the AT91/AT32 LCD Controller.
+
+config FB_INTSRAM
+	bool "Frame Buffer in internal SRAM"
+	depends on FB_ATMEL && ARCH_AT91SAM9261
+	help
+	  Say Y if you want to map Frame Buffer in internal SRAM. Say N if you want
+	  to let frame buffer in external SDRAM.
+
 config FB_NVIDIA
 	tristate "nVidia Framebuffer Support"
 	depends on FB && PCI
Index: linux-2.6.21.7/drivers/video/Makefile
===================================================================
--- linux-2.6.21.7.orig/drivers/video/Makefile
+++ linux-2.6.21.7/drivers/video/Makefile
@@ -75,6 +75,8 @@ obj-$(CONFIG_FB_G364)             += g36
 obj-$(CONFIG_FB_SA1100)           += sa1100fb.o
 obj-$(CONFIG_FB_HIT)              += hitfb.o
 obj-$(CONFIG_FB_EPSON1355)	  += epson1355fb.o
+obj-$(CONFIG_FB_S1D15605)	  += s1d15605fb.o
+obj-$(CONFIG_FB_ATMEL)            += atmel_lcdfb.o
 obj-$(CONFIG_FB_PVR2)             += pvr2fb.o
 obj-$(CONFIG_FB_VOODOO1)          += sstfb.o
 obj-$(CONFIG_FB_ARMCLCD)	  += amba-clcd.o
Index: linux-2.6.21.7/drivers/video/atmel_lcdfb.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/drivers/video/atmel_lcdfb.c
@@ -0,0 +1,752 @@
+/*
+ *  Driver for AT91/AT32 LCD Controller
+ *
+ *  Copyright (C) 2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/gpio.h>
+
+#include <video/atmel_lcdc.h>
+
+#define lcdc_readl(sinfo, reg)		__raw_readl((sinfo)->mmio+(reg))
+#define lcdc_writel(sinfo, reg, val)	__raw_writel((val), (sinfo)->mmio+(reg))
+
+/* configurable parameters */
+#define ATMEL_LCDC_CVAL_DEFAULT		0xc8
+#define ATMEL_LCDC_DMA_BURST_LEN	8
+
+#if defined(CONFIG_ARCH_AT91SAM9263)
+#define ATMEL_LCDC_FIFO_SIZE		2048
+#else
+#define ATMEL_LCDC_FIFO_SIZE		512
+#endif
+
+#if defined(CONFIG_ARCH_AT91)
+#define	ATMEL_LCDFB_FBINFO_DEFAULT	FBINFO_DEFAULT
+
+static inline void atmel_lcdfb_update_dma2d(struct atmel_lcdfb_info *sinfo,
+					struct fb_var_screeninfo *var)
+{
+
+}
+#elif defined(CONFIG_AVR32)
+#define	ATMEL_LCDFB_FBINFO_DEFAULT	(FBINFO_DEFAULT \
+					| FBINFO_PARTIAL_PAN_OK \
+					| FBINFO_HWACCEL_XPAN \
+					| FBINFO_HWACCEL_YPAN)
+
+static void atmel_lcdfb_update_dma2d(struct atmel_lcdfb_info *sinfo,
+				     struct fb_var_screeninfo *var)
+{
+	u32 dma2dcfg;
+	u32 pixeloff;
+
+	pixeloff = (var->xoffset * var->bits_per_pixel) & 0x1f;
+
+	dma2dcfg = ((var->xres_virtual - var->xres) * var->bits_per_pixel) / 8;
+	dma2dcfg |= pixeloff << ATMEL_LCDC_PIXELOFF_OFFSET;
+	lcdc_writel(sinfo, ATMEL_LCDC_DMA2DCFG, dma2dcfg);
+
+	/* Update configuration */
+	lcdc_writel(sinfo, ATMEL_LCDC_DMACON,
+		    lcdc_readl(sinfo, ATMEL_LCDC_DMACON)
+		    | ATMEL_LCDC_DMAUPDT);
+}
+#endif
+
+
+static struct fb_fix_screeninfo atmel_lcdfb_fix __initdata = {
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.visual		= FB_VISUAL_TRUECOLOR,
+	.xpanstep	= 0,
+	.ypanstep	= 0,
+	.ywrapstep	= 0,
+	.accel		= FB_ACCEL_NONE,
+};
+
+
+static void atmel_lcdfb_update_dma(struct fb_info *info,
+			       struct fb_var_screeninfo *var)
+{
+	struct atmel_lcdfb_info *sinfo = info->par;
+	struct fb_fix_screeninfo *fix = &info->fix;
+	unsigned long dma_addr;
+
+	dma_addr = (fix->smem_start + var->yoffset * fix->line_length
+		    + var->xoffset * var->bits_per_pixel / 8);
+
+	dma_addr &= ~3UL;
+
+	/* Set framebuffer DMA base address and pixel offset */
+	lcdc_writel(sinfo, ATMEL_LCDC_DMABADDR1, dma_addr);
+
+	atmel_lcdfb_update_dma2d(sinfo, var);
+}
+
+static inline void atmel_lcdfb_free_video_memory(struct atmel_lcdfb_info *sinfo)
+{
+	struct fb_info *info = sinfo->info;
+
+	dma_free_writecombine(info->device, info->fix.smem_len,
+				info->screen_base, info->fix.smem_start);
+}
+
+/**
+ *	atmel_lcdfb_alloc_video_memory - Allocate framebuffer memory
+ *	@sinfo: the frame buffer to allocate memory for
+ */
+static int atmel_lcdfb_alloc_video_memory(struct atmel_lcdfb_info *sinfo)
+{
+	struct fb_info *info = sinfo->info;
+	struct fb_var_screeninfo *var = &info->var;
+
+	info->fix.smem_len = (var->xres_virtual * var->yres_virtual
+			    * ((var->bits_per_pixel + 7) / 8));
+
+	info->screen_base = dma_alloc_writecombine(info->device, info->fix.smem_len,
+					(dma_addr_t *)&info->fix.smem_start, GFP_KERNEL);
+
+	if (!info->screen_base) {
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/**
+ *      atmel_lcdfb_check_var - Validates a var passed in.
+ *      @var: frame buffer variable screen structure
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ *	Checks to see if the hardware supports the state requested by
+ *	var passed in. This function does not alter the hardware
+ *	state!!!  This means the data stored in struct fb_info and
+ *	struct atmel_lcdfb_info do not change. This includes the var
+ *	inside of struct fb_info.  Do NOT change these. This function
+ *	can be called on its own if we intent to only test a mode and
+ *	not actually set it. The stuff in modedb.c is a example of
+ *	this. If the var passed in is slightly off by what the
+ *	hardware can support then we alter the var PASSED in to what
+ *	we can do. If the hardware doesn't support mode change a
+ *	-EINVAL will be returned by the upper layers. You don't need
+ *	to implement this function then. If you hardware doesn't
+ *	support changing the resolution then this function is not
+ *	needed. In this case the driver would just provide a var that
+ *	represents the static state the screen is in.
+ *
+ *	Returns negative errno on error, or zero on success.
+ */
+static int atmel_lcdfb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	struct device *dev = info->device;
+	struct atmel_lcdfb_info *sinfo = info->par;
+	unsigned long clk_value_khz;
+
+	clk_value_khz = clk_get_rate(sinfo->lcdc_clk) / 1000;
+
+	dev_dbg(dev, "%s:\n", __func__);
+	dev_dbg(dev, "  resolution: %ux%u\n", var->xres, var->yres);
+	dev_dbg(dev, "  pixclk:     %lu KHz\n", PICOS2KHZ(var->pixclock));
+	dev_dbg(dev, "  bpp:        %u\n", var->bits_per_pixel);
+	dev_dbg(dev, "  clk:        %lu KHz\n", clk_value_khz);
+
+	if ((PICOS2KHZ(var->pixclock) * var->bits_per_pixel / 8) > clk_value_khz) {
+		dev_err(dev, "%lu KHz pixel clock is too fast\n", PICOS2KHZ(var->pixclock));
+		return -EINVAL;
+	}
+
+	/* Force same alignment for each line */
+	var->xres = (var->xres + 3) & ~3UL;
+	var->xres_virtual = (var->xres_virtual + 3) & ~3UL;
+
+	var->red.msb_right = var->green.msb_right = var->blue.msb_right = 0;
+	var->transp.msb_right = 0;
+	var->transp.offset = var->transp.length = 0;
+	var->xoffset = var->yoffset = 0;
+
+	switch (var->bits_per_pixel) {
+	case 2:
+	case 4:
+	case 8:
+		var->red.offset = var->green.offset = var->blue.offset = 0;
+		var->red.length = var->green.length = var->blue.length
+			= var->bits_per_pixel;
+		break;
+	case 15:
+	case 16:
+		var->red.offset = 0;
+		var->green.offset = 5;
+		var->blue.offset = 10;
+		var->red.length = var->green.length = var->blue.length = 5;
+		break;
+	case 24:
+	case 32:
+		var->red.offset = 0;
+		var->green.offset = 8;
+		var->blue.offset = 16;
+		var->red.length = var->green.length = var->blue.length = 8;
+		break;
+	default:
+		dev_err(dev, "color depth %d not supported\n",
+					var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ *      atmel_lcdfb_set_par - Alters the hardware state.
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ *	Using the fb_var_screeninfo in fb_info we set the resolution
+ *	of the this particular framebuffer. This function alters the
+ *	par AND the fb_fix_screeninfo stored in fb_info. It doesn't
+ *	not alter var in fb_info since we are using that data. This
+ *	means we depend on the data in var inside fb_info to be
+ *	supported by the hardware.  atmel_lcdfb_check_var is always called
+ *	before atmel_lcdfb_set_par to ensure this.  Again if you can't
+ *	change the resolution you don't need this function.
+ *
+ */
+static int atmel_lcdfb_set_par(struct fb_info *info)
+{
+	struct atmel_lcdfb_info *sinfo = info->par;
+	unsigned long value;
+	unsigned long clk_value_khz;
+
+	dev_dbg(info->device, "%s:\n", __func__);
+	dev_dbg(info->device, "  * resolution: %ux%u (%ux%u virtual)\n",
+		 info->var.xres, info->var.yres,
+		 info->var.xres_virtual, info->var.yres_virtual);
+
+	/* Turn off the LCD controller and the DMA controller */
+	lcdc_writel(sinfo, ATMEL_LCDC_PWRCON, sinfo->guard_time << ATMEL_LCDC_GUARDT_OFFSET);
+
+	lcdc_writel(sinfo, ATMEL_LCDC_DMACON, 0);
+
+	if (info->var.bits_per_pixel <= 8)
+		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	else
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+
+	info->fix.line_length = info->var.xres_virtual * (info->var.bits_per_pixel / 8);
+
+	/* Re-initialize the DMA engine... */
+	dev_dbg(info->device, "  * update DMA engine\n");
+	atmel_lcdfb_update_dma(info, &info->var);
+
+	/* ...set frame size and burst length = 8 words (?) */
+	value = (info->var.yres * info->var.xres * info->var.bits_per_pixel) / 32;
+	value |= ((ATMEL_LCDC_DMA_BURST_LEN - 1) << ATMEL_LCDC_BLENGTH_OFFSET);
+	lcdc_writel(sinfo, ATMEL_LCDC_DMAFRMCFG, value);
+
+	/* Now, the LCDC core... */
+
+	/* Set pixel clock */
+	clk_value_khz = clk_get_rate(sinfo->lcdc_clk) / 1000;
+
+	value = clk_value_khz / PICOS2KHZ(info->var.pixclock);
+
+	if (clk_value_khz % PICOS2KHZ(info->var.pixclock))
+		value++;
+
+	value = (value / 2) - 1;
+
+	if (value <= 0) {
+		dev_notice(info->device, "Bypassing pixel clock divider\n");
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDCON1, ATMEL_LCDC_BYPASS);
+	} else
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDCON1, value << ATMEL_LCDC_CLKVAL_OFFSET);
+
+	/* Initialize control register 2 */
+	value = sinfo->default_lcdcon2;
+
+	if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
+		value |= ATMEL_LCDC_INVLINE_INVERTED;
+	if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
+		value |= ATMEL_LCDC_INVFRAME_INVERTED;
+
+	switch (info->var.bits_per_pixel) {
+		case 1:	value |= ATMEL_LCDC_PIXELSIZE_1; break;
+		case 2: value |= ATMEL_LCDC_PIXELSIZE_2; break;
+		case 4: value |= ATMEL_LCDC_PIXELSIZE_4; break;
+		case 8: value |= ATMEL_LCDC_PIXELSIZE_8; break;
+		case 15: /* fall through */
+		case 16: value |= ATMEL_LCDC_PIXELSIZE_16; break;
+		case 24: value |= ATMEL_LCDC_PIXELSIZE_24; break;
+		case 32: value |= ATMEL_LCDC_PIXELSIZE_32; break;
+		default: BUG(); break;
+	}
+	dev_dbg(info->device, "  * LCDCON2 = %08lx\n", value);
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDCON2, value);
+
+	/* Vertical timing */
+	value = (info->var.vsync_len - 1) << ATMEL_LCDC_VPW_OFFSET;
+	value |= info->var.upper_margin << ATMEL_LCDC_VBP_OFFSET;
+	value |= info->var.lower_margin;
+	dev_dbg(info->device, "  * LCDTIM1 = %08lx\n", value);
+	lcdc_writel(sinfo, ATMEL_LCDC_TIM1, value);
+
+	/* Horizontal timing */
+	value = (info->var.right_margin - 1) << ATMEL_LCDC_HFP_OFFSET;
+	value |= (info->var.hsync_len - 1) << ATMEL_LCDC_HPW_OFFSET;
+	value |= (info->var.left_margin - 1);
+	dev_dbg(info->device, "  * LCDTIM2 = %08lx\n", value);
+	lcdc_writel(sinfo, ATMEL_LCDC_TIM2, value);
+
+	/* Display size */
+	value = (info->var.xres - 1) << ATMEL_LCDC_HOZVAL_OFFSET;
+	value |= info->var.yres - 1;
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDFRMCFG, value);
+
+	/* FIFO Threshold: Use formula from data sheet */
+	value = ATMEL_LCDC_FIFO_SIZE - (2 * ATMEL_LCDC_DMA_BURST_LEN + 3);
+	lcdc_writel(sinfo, ATMEL_LCDC_FIFO, value);
+
+	/* Toggle LCD_MODE every frame */
+	lcdc_writel(sinfo, ATMEL_LCDC_MVAL, 0);
+
+	/* Disable all interrupts */
+	lcdc_writel(sinfo, ATMEL_LCDC_IDR, ~0UL);
+
+	/* Set contrast */
+	value = ATMEL_LCDC_PS_DIV8 | ATMEL_LCDC_POL_POSITIVE | ATMEL_LCDC_ENA_PWMENABLE;
+	lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, value);
+	lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_VAL, ATMEL_LCDC_CVAL_DEFAULT);
+	/* ...wait for DMA engine to become idle... */
+	while (lcdc_readl(sinfo, ATMEL_LCDC_DMACON) & ATMEL_LCDC_DMABUSY)
+		msleep(10);
+
+	dev_dbg(info->device, "  * re-enable DMA engine\n");
+	/* ...and enable it with updated configuration */
+	lcdc_writel(sinfo, ATMEL_LCDC_DMACON, sinfo->default_dmacon);
+
+	dev_dbg(info->device, "  * re-enable LCDC core\n");
+	lcdc_writel(sinfo, ATMEL_LCDC_PWRCON,
+		(sinfo->guard_time << ATMEL_LCDC_GUARDT_OFFSET) | ATMEL_LCDC_PWR);
+
+	dev_dbg(info->device, "  * DONE\n");
+
+	return 0;
+}
+
+static inline unsigned int chan_to_field(unsigned int chan, const struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+/**
+ *  	atmel_lcdfb_setcolreg - Optional function. Sets a color register.
+ *      @regno: Which register in the CLUT we are programming
+ *      @red: The red value which can be up to 16 bits wide
+ *	@green: The green value which can be up to 16 bits wide
+ *	@blue:  The blue value which can be up to 16 bits wide.
+ *	@transp: If supported the alpha value which can be up to 16 bits wide.
+ *      @info: frame buffer info structure
+ *
+ *  	Set a single color register. The values supplied have a 16 bit
+ *  	magnitude which needs to be scaled in this function for the hardware.
+ *	Things to take into consideration are how many color registers, if
+ *	any, are supported with the current color visual. With truecolor mode
+ *	no color palettes are supported. Here a psuedo palette is created
+ *	which we store the value in pseudo_palette in struct fb_info. For
+ *	pseudocolor mode we have a limited color palette. To deal with this
+ *	we can program what color is displayed for a particular pixel value.
+ *	DirectColor is similar in that we can program each color field. If
+ *	we have a static colormap we don't need to implement this function.
+ *
+ *	Returns negative errno on error, or zero on success. In an
+ *	ideal world, this would have been the case, but as it turns
+ *	out, the other drivers return 1 on failure, so that's what
+ *	we're going to do.
+ */
+static int atmel_lcdfb_setcolreg(unsigned int regno, unsigned int red,
+			     unsigned int green, unsigned int blue,
+			     unsigned int transp, struct fb_info *info)
+{
+	struct atmel_lcdfb_info *sinfo = info->par;
+	unsigned int val;
+	u32 *pal;
+	int ret = 1;
+
+	if (info->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green
+				      + 7471 * blue) >> 16;
+
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		if (regno < 16) {
+			pal = info->pseudo_palette;
+
+			val  = chan_to_field(red, &info->var.red);
+			val |= chan_to_field(green, &info->var.green);
+			val |= chan_to_field(blue, &info->var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_PSEUDOCOLOR:
+		if (regno < 256) {
+			val  = ((red   >> 11) & 0x001f);
+			val |= ((green >>  6) & 0x03e0);
+			val |= ((blue  >>  1) & 0x7c00);
+
+			/*
+			 * TODO: intensity bit. Maybe something like
+			 *   ~(red[10] ^ green[10] ^ blue[10]) & 1
+			 */
+
+			lcdc_writel(sinfo, ATMEL_LCDC_LUT(regno), val);
+			ret = 0;
+		}
+		break;
+	}
+
+	return ret;
+}
+
+static int atmel_lcdfb_pan_display(struct fb_var_screeninfo *var,
+			       struct fb_info *info)
+{
+	dev_dbg(info->device, "%s\n", __func__);
+
+	atmel_lcdfb_update_dma(info, var);
+
+	return 0;
+}
+
+static struct fb_ops atmel_lcdfb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= atmel_lcdfb_check_var,
+	.fb_set_par	= atmel_lcdfb_set_par,
+	.fb_setcolreg	= atmel_lcdfb_setcolreg,
+	.fb_pan_display	= atmel_lcdfb_pan_display,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+};
+
+static irqreturn_t atmel_lcdfb_interrupt(int irq, void *dev_id)
+{
+	struct fb_info *info = dev_id;
+	struct atmel_lcdfb_info *sinfo = info->par;
+	u32 status;
+
+	status = lcdc_readl(sinfo, ATMEL_LCDC_ISR);
+	lcdc_writel(sinfo, ATMEL_LCDC_IDR, status);
+	return IRQ_HANDLED;
+}
+
+static int __init atmel_lcdfb_init_fbinfo(struct atmel_lcdfb_info *sinfo)
+{
+	struct fb_info *info = sinfo->info;
+	int ret = 0;
+
+	memset_io(info->screen_base, 0, info->fix.smem_len);
+	info->var.activate |= FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW;
+
+	dev_info(info->device,
+	       "%luKiB frame buffer at %08lx (mapped at %p)\n",
+	       (unsigned long)info->fix.smem_len / 1024,
+	       (unsigned long)info->fix.smem_start,
+	       info->screen_base);
+
+	/* Allocate colormap */
+	ret = fb_alloc_cmap(&info->cmap, 256, 0);
+	if (ret < 0)
+		dev_err(info->device, "Alloc color map failed\n");
+
+	return ret;
+}
+
+static void atmel_lcdfb_start_clock(struct atmel_lcdfb_info *sinfo)
+{
+	if (sinfo->bus_clk)
+		clk_enable(sinfo->bus_clk);
+	clk_enable(sinfo->lcdc_clk);
+}
+
+static void atmel_lcdfb_stop_clock(struct atmel_lcdfb_info *sinfo)
+{
+	if (sinfo->bus_clk)
+		clk_disable(sinfo->bus_clk);
+	clk_disable(sinfo->lcdc_clk);
+}
+
+
+static int __init atmel_lcdfb_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct fb_info *info;
+	struct atmel_lcdfb_info *sinfo;
+	struct atmel_lcdfb_info *pdata_sinfo;
+	struct resource *regs = NULL;
+	struct resource *map = NULL;
+	int ret;
+
+	dev_dbg(dev, "%s BEGIN\n", __func__);
+
+	ret = -ENOMEM;
+	info = framebuffer_alloc(sizeof(struct atmel_lcdfb_info), dev);
+	if (!info) {
+		dev_err(dev, "cannot allocate memory\n");
+		goto out;
+	}
+
+	sinfo = info->par;
+
+	if (dev->platform_data) {
+		pdata_sinfo = (struct atmel_lcdfb_info *)dev->platform_data;
+		sinfo->default_bpp = pdata_sinfo->default_bpp;
+		sinfo->default_dmacon = pdata_sinfo->default_dmacon;
+		sinfo->default_lcdcon2 = pdata_sinfo->default_lcdcon2;
+		sinfo->default_monspecs = pdata_sinfo->default_monspecs;
+		sinfo->atmel_lcdfb_power_control = pdata_sinfo->atmel_lcdfb_power_control;
+		sinfo->guard_time = pdata_sinfo->guard_time;
+	} else {
+		dev_err(dev, "cannot get default configuration\n");
+		goto free_info;
+	}
+	sinfo->info = info;
+	sinfo->pdev = pdev;
+
+	strcpy(info->fix.id, sinfo->pdev->name);
+	info->flags = ATMEL_LCDFB_FBINFO_DEFAULT;
+	info->pseudo_palette = sinfo->pseudo_palette;
+	info->fbops = &atmel_lcdfb_ops;
+
+	memcpy(&info->monspecs, sinfo->default_monspecs, sizeof(info->monspecs));
+	info->fix = atmel_lcdfb_fix;
+
+	/* Enable LCDC Clocks */
+	if (cpu_is_at91sam9261()) {
+		sinfo->bus_clk = clk_get(dev, "hck1");
+		if (IS_ERR(sinfo->bus_clk)) {
+			ret = PTR_ERR(sinfo->bus_clk);
+			goto free_info;
+		}
+	}
+	sinfo->lcdc_clk = clk_get(dev, "lcdc_clk");
+	if (IS_ERR(sinfo->lcdc_clk)) {
+		ret = PTR_ERR(sinfo->lcdc_clk);
+		goto put_bus_clk;
+	}
+	atmel_lcdfb_start_clock(sinfo);
+
+	ret = fb_find_mode(&info->var, info, NULL, info->monspecs.modedb,
+			info->monspecs.modedb_len, info->monspecs.modedb,
+			sinfo->default_bpp);
+	if (!ret) {
+		dev_err(dev, "no suitable video mode found\n");
+		goto stop_clk;
+	}
+
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs) {
+		dev_err(dev, "resources unusable\n");
+		ret = -ENXIO;
+		goto stop_clk;
+	}
+
+	sinfo->irq_base = platform_get_irq(pdev, 0);
+	if (sinfo->irq_base < 0) {
+		dev_err(dev, "unable to get irq\n");
+		ret = sinfo->irq_base;
+		goto stop_clk;
+	}
+
+	/* Initialize video memory */
+	map = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (map) {
+		/* use a pre-allocated memory buffer */
+		info->fix.smem_start = map->start;
+		info->fix.smem_len = map->end - map->start + 1;
+		if (!request_mem_region(info->fix.smem_start,
+					info->fix.smem_len, pdev->name)) {
+			ret = -EBUSY;
+			goto stop_clk;
+		}
+
+		info->screen_base = ioremap(info->fix.smem_start, info->fix.smem_len);
+		if (!info->screen_base)
+			goto release_intmem;
+	} else {
+		/* alocate memory buffer */
+		ret = atmel_lcdfb_alloc_video_memory(sinfo);
+		if (ret < 0) {
+			dev_err(dev, "cannot allocate framebuffer: %d\n", ret);
+			goto stop_clk;
+		}
+	}
+
+	/* LCDC registers */
+	info->fix.mmio_start = regs->start;
+	info->fix.mmio_len = regs->end - regs->start + 1;
+
+	if (!request_mem_region(info->fix.mmio_start,
+				info->fix.mmio_len, pdev->name)) {
+		ret = -EBUSY;
+		goto free_fb;
+	}
+
+	sinfo->mmio = ioremap(info->fix.mmio_start, info->fix.mmio_len);
+	if (!sinfo->mmio) {
+		dev_err(dev, "cannot map LCDC registers\n");
+		goto release_mem;
+	}
+
+	/* interrupt */
+	ret = request_irq(sinfo->irq_base, atmel_lcdfb_interrupt, 0, pdev->name, info);
+	if (ret) {
+		dev_err(dev, "request_irq failed: %d\n", ret);
+		goto unmap_mmio;
+	}
+
+	ret = atmel_lcdfb_init_fbinfo(sinfo);
+	if (ret < 0) {
+		dev_err(dev, "init fbinfo failed: %d\n", ret);
+		goto unregister_irqs;
+	}
+
+	/*
+	 * This makes sure that our colour bitfield
+	 * descriptors are correctly initialised.
+	 */
+	atmel_lcdfb_check_var(&info->var, info);
+
+	ret = fb_set_var(info, &info->var);
+	if (ret) {
+		dev_warn(dev, "unable to set display parameters\n");
+		goto free_cmap;
+	}
+
+	dev_set_drvdata(dev, info);
+
+	/*
+	 * Tell the world that we're ready to go
+	 */
+	ret = register_framebuffer(info);
+	if (ret < 0) {
+		dev_err(dev, "failed to register framebuffer device: %d\n", ret);
+		goto free_cmap;
+	}
+
+	/* Power up the LCDC screen */
+	if (sinfo->atmel_lcdfb_power_control)
+		sinfo->atmel_lcdfb_power_control(1);
+
+	dev_info(dev, "fb%d: Atmel LCDC at 0x%08lx (mapped at %p), irq %lu\n",
+		       info->node, info->fix.mmio_start, sinfo->mmio, sinfo->irq_base);
+
+	return 0;
+
+
+free_cmap:
+	fb_dealloc_cmap(&info->cmap);
+unregister_irqs:
+	free_irq(sinfo->irq_base, info);
+unmap_mmio:
+	iounmap(sinfo->mmio);
+release_mem:
+ 	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
+free_fb:
+	if (map)
+		iounmap(info->screen_base);
+	else
+		atmel_lcdfb_free_video_memory(sinfo);
+
+release_intmem:
+	if (map)
+		release_mem_region(info->fix.smem_start, info->fix.smem_len);
+stop_clk:
+	atmel_lcdfb_stop_clock(sinfo);
+	clk_put(sinfo->lcdc_clk);
+put_bus_clk:
+	if (sinfo->bus_clk)
+		clk_put(sinfo->bus_clk);
+free_info:
+	framebuffer_release(info);
+out:
+	dev_dbg(dev, "%s FAILED\n", __func__);
+	return ret;
+}
+
+static int __exit atmel_lcdfb_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct fb_info *info = dev_get_drvdata(dev);
+	struct atmel_lcdfb_info *sinfo = info->par;
+
+	if (!sinfo)
+		return 0;
+
+	if (sinfo->atmel_lcdfb_power_control)
+		sinfo->atmel_lcdfb_power_control(0);
+	unregister_framebuffer(info);
+	atmel_lcdfb_stop_clock(sinfo);
+	clk_put(sinfo->lcdc_clk);
+	if (sinfo->bus_clk)
+		clk_put(sinfo->bus_clk);
+	fb_dealloc_cmap(&info->cmap);
+	free_irq(sinfo->irq_base, info);
+	iounmap(sinfo->mmio);
+ 	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
+	if (platform_get_resource(pdev, IORESOURCE_MEM, 1)) {
+		iounmap(info->screen_base);
+		release_mem_region(info->fix.smem_start, info->fix.smem_len);
+	} else {
+		atmel_lcdfb_free_video_memory(sinfo);
+	}
+
+	dev_set_drvdata(dev, NULL);
+	framebuffer_release(info);
+
+	return 0;
+}
+
+static struct platform_driver atmel_lcdfb_driver = {
+	.remove		= __exit_p(atmel_lcdfb_remove),
+	.driver		= {
+		.name	= "atmel_lcdfb",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init atmel_lcdfb_init(void)
+{
+	return platform_driver_probe(&atmel_lcdfb_driver, atmel_lcdfb_probe);
+}
+
+static void __exit atmel_lcdfb_exit(void)
+{
+	platform_driver_unregister(&atmel_lcdfb_driver);
+}
+
+module_init(atmel_lcdfb_init);
+module_exit(atmel_lcdfb_exit);
+
+MODULE_DESCRIPTION("AT91/AT32 LCD Controller framebuffer driver");
+MODULE_AUTHOR("Nicolas Ferre <nicolas.ferre@rfo.atmel.com>");
+MODULE_LICENSE("GPL");
Index: linux-2.6.21.7/drivers/video/backlight/Kconfig
===================================================================
--- linux-2.6.21.7.orig/drivers/video/backlight/Kconfig
+++ linux-2.6.21.7/drivers/video/backlight/Kconfig
@@ -63,3 +63,11 @@ config BACKLIGHT_PROGEAR
 	help
 	  If you have a Frontpath ProGear say Y to enable the
 	  backlight driver.
+
+config BACKLIGHT_KB920x
+	tristate "KwikByte KB9202 Backlight Driver"
+	depends on BACKLIGHT_CLASS_DEVICE && MACH_KB9200
+	default y
+	help
+	  If you have a KwikByte KB9202 board, say Y to enable the
+	  backlight driver.
Index: linux-2.6.21.7/drivers/video/backlight/Makefile
===================================================================
--- linux-2.6.21.7.orig/drivers/video/backlight/Makefile
+++ linux-2.6.21.7/drivers/video/backlight/Makefile
@@ -6,3 +6,4 @@ obj-$(CONFIG_BACKLIGHT_CORGI)	+= corgi_b
 obj-$(CONFIG_BACKLIGHT_HP680)	+= hp680_bl.o
 obj-$(CONFIG_BACKLIGHT_LOCOMO)	+= locomolcd.o
 obj-$(CONFIG_BACKLIGHT_PROGEAR) += progear_bl.o
+obj-$(CONFIG_BACKLIGHT_KB920x)	+= kb920x_bl.o
Index: linux-2.6.21.7/drivers/video/backlight/kb920x_bl.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/drivers/video/backlight/kb920x_bl.c
@@ -0,0 +1,164 @@
+/*
+ * Backlight Driver for KB9202
+ *
+ * Copyright (c) 2006 KwikByte
+ *
+ * Based on Sharp's Corgi Backlight Driver
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+
+#include <asm/arch/gpio.h>
+
+/* The backlight is on(1)/off(0) */
+#define	KB9202_DEFAULT_INTENSITY	1
+#define	KB9202_MAX_INTENSITY		1
+
+static int kb9202bl_suspended;
+static int current_intensity = 0;
+static DEFINE_SPINLOCK(bl_lock);
+
+static int kb9202bl_set_intensity(struct backlight_device *bd)
+{
+	unsigned long flags;
+	int intensity = bd->props.brightness;
+
+	if (bd->props.power != FB_BLANK_UNBLANK)
+		intensity = 0;
+	if (bd->props.fb_blank != FB_BLANK_UNBLANK)
+		intensity = 0;
+	if (kb9202bl_suspended)
+		intensity = 0;
+
+	if ((!current_intensity) && (bd->props.power == FB_BLANK_UNBLANK))
+		intensity = 1;
+
+	spin_lock_irqsave(&bl_lock, flags);
+	if (intensity)
+		gpio_set_value(AT91_PIN_PC23, 1);
+	else
+		gpio_set_value(AT91_PIN_PC23, 0);
+	spin_unlock_irqrestore(&bl_lock, flags);
+
+	current_intensity = intensity;
+
+	return 0;
+}
+
+static int kb9202bl_get_intensity(struct backlight_device *bd)
+{
+	return current_intensity;
+}
+
+static struct backlight_ops kb9202bl_ops = {
+	.get_brightness	= kb9202bl_get_intensity,
+	.update_status	= kb9202bl_set_intensity,
+};
+
+static int __init kb9202bl_probe(struct platform_device *pdev)
+{
+	struct backlight_device *bd;
+
+	bd = backlight_device_register ("kb9202-bl", &pdev->dev, NULL, &kb9202bl_ops);
+	if (IS_ERR(bd))
+		return PTR_ERR(bd);
+
+	platform_set_drvdata(pdev, bd);
+
+	bd->props.max_brightness = KB9202_MAX_INTENSITY;
+	bd->props.brightness = KB9202_DEFAULT_INTENSITY;
+	(void) kb9202bl_set_intensity(bd);
+
+	return 0;
+}
+
+static int kb9202bl_remove(struct platform_device *pdev)
+{
+	struct backlight_device *bd = platform_get_drvdata(pdev);
+
+	bd->props.brightness = 0;
+	bd->props.power = 0;
+	(void) kb9202bl_set_intensity(bd);
+
+	backlight_device_unregister(bd);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int kb9202bl_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct backlight_device *bd = platform_get_drvdata(pdev);
+
+	kb9202bl_suspended = 1;
+	(void) kb9202bl_set_intensity(bd);
+	return 0;
+}
+
+static int kb9202bl_resume(struct platform_device *dev)
+{
+	struct backlight_device *bd = platform_get_drvdata(pdev);
+
+	kb9202bl_suspended = 0;
+	(void) kb9202bl_set_intensity(bd);
+	return 0;
+}
+#else
+#define kb9202bl_suspend	NULL
+#define kb9202bl_resume		NULL
+#endif
+
+static struct platform_driver kb9202bl_driver = {
+	.probe		= kb9202bl_probe,
+	.remove		= kb9202bl_remove,
+	.suspend	= kb9202bl_suspend,
+	.resume		= kb9202bl_resume,
+	.driver		= {
+		.name	= "kb9202-bl",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static struct platform_device *kb9202bl_device;
+
+static int __init kb9202bl_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&kb9202bl_driver);
+	if (!ret) {
+		kb9202bl_device = platform_device_alloc("kb9202-bl", -1);
+		if (!kb9202bl_device)
+			return -ENOMEM;
+
+		ret = platform_device_add(kb9202bl_device);
+		if (ret) {
+			platform_device_put(kb9202bl_device);
+			platform_driver_unregister(&kb9202bl_driver);
+		}
+	}
+	return ret;
+}
+
+static void __exit kb9202bl_exit(void)
+{
+	platform_device_unregister(kb9202bl_device);
+	platform_driver_unregister(&kb9202bl_driver);
+}
+
+module_init(kb9202bl_init);
+module_exit(kb9202bl_exit);
+
+MODULE_AUTHOR("KwikByte <kb9200_dev@kwikbyte.com>");
+MODULE_DESCRIPTION("KB9202 Backlight Driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.21.7/drivers/video/s1d15605fb.c
===================================================================
--- /dev/null
+++ linux-2.6.21.7/drivers/video/s1d15605fb.c
@@ -0,0 +1,659 @@
+/*
+ *  drivers/video/s1d15605.c
+ *
+ * Adapted from several sources including:
+ * 1) Driver for AT91 LCD Controller
+ *    Copyright (C) 2006 Atmel
+ *
+ * 2) Copyright (C) 2005 S. Kevin Hester
+ *
+ *   This file is subject to the terms and conditions of the GNU General Public
+ *   License. See the file COPYING in the main directory of this archive for
+ *   more details.
+ *
+ *   This is a basic framebuffer driver for the Optrex F-51320 128x64 mono LCD
+ *   display.  This display uses a clone of the common Epson SED 1531 display
+ *   controller.
+ *
+ *   I've heavily borrowed code from the vfb.c driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifdef DEBUG
+#define MSG(string, args...) printk("s1d15605fb:" string, ##args)
+#else
+#define MSG(string, args...)
+#endif
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/uaccess.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+
+#ifdef CONFIG_PMAC_BACKLIGHT
+#include <asm/backlight.h>
+#endif
+
+#define VIDEOWIDTH		128
+#define VIDEOHEIGHT		64
+#define VIDEODEPTH		1	/* bits/pixel */
+#define VIDEOWIDTH_BYTES	((VIDEOWIDTH * VIDEODEPTH) / 8)
+
+/* The number of bytes that actually go to the device */
+#define ACTUALVIDEOMEMSIZE	(VIDEOWIDTH_BYTES * VIDEOHEIGHT)
+#define VIDEOMEMSIZE		PAGE_SIZE
+
+static struct fb_var_screeninfo s1d15605_default __initdata = {
+	.xres		= VIDEOWIDTH,
+	.yres		= VIDEOHEIGHT,
+	.xres_virtual	= VIDEOWIDTH,
+	.yres_virtual	= VIDEOHEIGHT,
+	.bits_per_pixel	= VIDEODEPTH,
+	.red		= { 0, 1, 0 },
+	.green		= { 0, 1, 0 },
+	.blue		= { 0, 1, 0 },
+	.activate	= FB_ACTIVATE_NOW,
+	.pixclock	= 20000,
+	.vmode		= FB_VMODE_NONINTERLACED,
+};
+
+static struct fb_fix_screeninfo s1d15605_fix __initdata = {
+	.id		= "s1d15605",
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.visual		= FB_VISUAL_MONO10,
+	.xpanstep	= 0,
+	.ypanstep	= 0,
+	.ywrapstep	= 0,
+	.accel		= FB_ACCEL_NONE,
+};
+
+struct s1d15605fb_info {
+	struct fb_info		*info;
+	char			*mmio;
+	unsigned long		reset_pin;
+	struct platform_device	*pdev;
+};
+
+/*
+ * LCD device interface
+ */
+#define	RESET_DISPLAY		0xE2
+#define	LCD_BIAS_1_9		0xA2
+#define	ADC_SELECT_REVERSE	0xA1
+#define	COMMON_OUTPUT_NORMAL	0xC0
+#define	V5_RESISTOR_RATIO	0x26
+#define	ELECTRONIC_VOLUME_SET	0x81
+#define	ELECTRONIC_VOLUME_INIT	0x20
+#define	POWER_CONTROL_SET	0x28
+#define	VOLTAGE_REGULATOR	0x02
+#define	VOLTAGE_FOLLOWER	0x01
+#define	BOOSTER_CIRCUIT		0x04
+#define	DISPLAY_ON		0xAF
+#define	START_LINE_SET		0x40
+#define	PAGE_ADDRESS_SET	0xB0
+#define	COLUMN_ADDRESS_HIGH	0x10
+#define	COLUMN_ADDRESS_LOW	0x00
+#define	RESISTOR_RATIO_START	0x20
+
+#define	NUM_OF_PAGES		8
+#define	NUM_OF_COLUMNS		128
+
+#define	WRITE_COMMAND(x)	__raw_writeb((x), (sinfo)->mmio)
+#define	READ_COMMAND		__raw_readb((sinfo)->mmio)
+#define	WRITE_DATA(x)		__raw_writeb((x), (sinfo)->mmio + (0x10000))
+#define	READ_DATA		__raw_readb((sinfo)->mmio + (0x10000))
+
+
+/*
+ *	s1d15605fb_resize_framebuffer
+ *
+ *	Free allocated space if different.  Allocate on new of changed.
+ *	Returns -ENOMEM if the new framebuffer can not be allocated,
+ *	zero on success.
+ */
+static int s1d15605fb_resize_framebuffer(struct s1d15605fb_info *sinfo)
+{
+	struct fb_info			*info = sinfo->info;
+	struct fb_fix_screeninfo	*fix = &info->fix;
+	struct fb_var_screeninfo	*var = &info->var;
+	unsigned int			new_size;
+	void				*new_vaddr;
+
+	new_size = ((var->xres_virtual * var->yres_virtual * var->bits_per_pixel) / 8);
+
+	MSG("%s: x (%d) y (%d) bpp (%d): new size 0x%08x\n", __FUNCTION__,
+		var->xres_virtual, var->yres_virtual, var->bits_per_pixel, new_size);
+
+	if (new_size == fix->smem_len)
+		return 0;
+
+	if (fix->smem_len) {
+		kfree(info->screen_base);
+	}
+
+	new_vaddr = kmalloc(new_size, GFP_KERNEL);
+
+	if (!new_vaddr) {
+		fix->smem_len = 0;
+		return -ENOMEM;
+	}
+
+	info->screen_base = new_vaddr;
+	fix->smem_start = (unsigned)new_vaddr;
+	fix->smem_len = new_size;
+	fix->line_length = (var->xres_virtual * var->bits_per_pixel) / 8;
+
+	dev_info(info->device,
+		"%luKiB frame buffer at %08lx (mapped at %p)\n",
+		(unsigned long)info->fix.smem_len / 1024,
+		(unsigned long)info->fix.smem_start,
+		info->screen_base);
+
+	return 0;
+}
+
+
+/*
+ * The s1d15605 seems to be divided into eight 128 pixel wide pages (from top to
+ * bottom) each page seems to be eight pixels high, where these eight pixels are
+ * one byte
+ */
+static void s1d15605_update(struct fb_info *info)
+{
+	struct s1d15605fb_info	*sinfo = info->par;
+	int			page, i, row, colmask;
+	u8			retVal, *rowPtr;
+
+	WRITE_COMMAND(START_LINE_SET);
+	for (page = 0; page < NUM_OF_PAGES; ++page) {
+		WRITE_COMMAND(PAGE_ADDRESS_SET + page);
+		WRITE_COMMAND(COLUMN_ADDRESS_HIGH);
+		WRITE_COMMAND(COLUMN_ADDRESS_LOW);
+
+		for (i = 0; i < NUM_OF_COLUMNS; ++i)
+		{
+			/* point of opportunity: optimization */
+			colmask = (1 << (i & 0x7));
+			rowPtr = (u8*)(info->screen_base);
+			rowPtr += (VIDEOWIDTH_BYTES * 8 * page);
+			rowPtr += (i >> 3);
+			retVal = 0;
+			for (row = 0; row < 8; ++row)
+			{
+				retVal = (retVal >> 1) | (((*rowPtr) & colmask) ? 0x80 : 0);
+				rowPtr += VIDEOWIDTH_BYTES;
+			}
+			WRITE_DATA(retVal);
+		}
+	}
+
+	WRITE_COMMAND(DISPLAY_ON);
+}
+
+
+/*
+ * Setting the video mode has been split into two parts.
+ * First part, xxxfb_check_var, must not write anything
+ * to hardware, it should only verify and adjust var.
+ * This means it doesn't alter par but it does use hardware
+ * data from it to check this var.
+ */
+static int s1d15605_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	/*
+	 * Some very basic checks
+	 */
+	if (!var->xres)
+		var->xres = 1;
+	if (!var->yres)
+		var->yres = 1;
+	if (var->xres > var->xres_virtual)
+		var->xres_virtual = var->xres;
+	if (var->yres > var->yres_virtual)
+		var->yres_virtual = var->yres;
+
+	if(var->bits_per_pixel > VIDEODEPTH)
+		return -EINVAL;
+
+	/*
+	 * Memory limit
+	 */
+	if (((var->yres_virtual * var->bits_per_pixel * var->yres_virtual) >> 3) >
+			ACTUALVIDEOMEMSIZE)
+		return -ENOMEM;
+
+	/*
+	 * Now that we checked it we alter var. The reason being is that the video
+	 * mode passed in might not work but slight changes to it might make it
+	 * work. This way we let the user know what is acceptable.
+	 */
+	switch (var->bits_per_pixel) {
+	case 1:
+		var->red.offset = var->green.offset = var->blue.offset = 0;
+		var->red.length = var->green.length = var->blue.length
+			= var->bits_per_pixel;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	var->xoffset = var->yoffset = 0;
+	var->red.msb_right = var->green.msb_right = var->blue.msb_right =
+		var->transp.msb_right = 0;
+
+	return 0;
+}
+
+
+/*
+ * This routine actually sets the video mode. It's in here where we
+ * the hardware state info->par and fix which can be affected by the
+ * change in par. For this driver it doesn't do much.
+ */
+static int s1d15605_set_par(struct fb_info *info)
+{
+	int	ret;
+
+	MSG("%s:\n", __func__);
+	MSG("  * resolution: %ux%u (%ux%u virtual)\n",
+		 info->var.xres, info->var.yres,
+		 info->var.xres_virtual, info->var.yres_virtual);
+
+	ret = s1d15605fb_resize_framebuffer(info->par);
+
+	info->fix.visual = FB_VISUAL_MONO10;
+	return ret;
+}
+
+
+/*
+ * Set a single color register. The values supplied are already
+ * rounded down to the hardware's capabilities (according to the
+ * entries in the var structure). Return != 0 for invalid regno.
+ */
+static int s1d15605_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+			u_int transp, struct fb_info *info)
+{
+	if (regno > 1)	/* no. of hw registers - we only do mono now */
+		return 1;
+
+	return 0;
+}
+
+
+/*
+ * Currently, the routine will simply shut-off the backlight and prevent
+ * updates/refreshes.  Modify according to application.
+ *
+ * 0 unblank, 1 blank, 2 no vsync, 3 no hsync, 4 off
+ */
+static int s1d15605_blank(int blank, struct fb_info *info)
+{
+#ifdef CONFIG_PMAC_BACKLIGHT
+	if (blank)
+		pmac_backlight->props.power = FB_BLANK_POWERDOWN;
+	else
+		pmac_backlight->props.power = FB_BLANK_UNBLANK;
+	backlight_update_status(pmac_backlight);
+#endif
+	return 1;
+}
+
+
+/*
+ * Pan or Wrap the Display
+ *
+ * This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag
+ */
+/*
+static int s1d15605_pan_display(struct fb_var_screeninfo *var,
+			struct fb_info *info)
+{
+	if (var->vmode & FB_VMODE_YWRAP) {
+		if (var->yoffset < 0
+		    || var->yoffset >= info->var.yres_virtual
+		    || var->xoffset)
+			return -EINVAL;
+	} else {
+		if (var->xoffset + var->xres > info->var.xres_virtual ||
+		    var->yoffset + var->yres > info->var.yres_virtual)
+			return -EINVAL;
+	}
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+	if (var->vmode & FB_VMODE_YWRAP)
+		info->var.vmode |= FB_VMODE_YWRAP;
+	else
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+	return 0;
+}
+*/
+
+
+static void s1d15605_copyarea(struct fb_info *info, const struct fb_copyarea *region)
+{
+	cfb_copyarea(info, region);
+	s1d15605_update(info);
+}
+
+
+static void s1d15605_fillrect (struct fb_info *info, const struct fb_fillrect *rect)
+{
+	cfb_fillrect(info, rect);
+	s1d15605_update(info);
+}
+
+
+static void s1d15605_imageblit(struct fb_info *p, const struct fb_image *image)
+{
+	cfb_imageblit(p, image);
+	s1d15605_update(p);
+}
+
+
+/*
+ * Write the users data to our framebuffer, and then trigger a psuedo DMA
+ */
+static ssize_t s1d15605_write(struct file *file, const char *buf,
+			size_t count, loff_t *ppos)
+{
+	unsigned long p = *ppos;
+	struct inode *inode = file->f_dentry->d_inode;
+	int fbidx = iminor(inode);
+	struct fb_info *info = registered_fb[fbidx];
+	int err;
+
+	if (p > info->fix.smem_len)
+		return -ENOSPC;
+	if (count >= info->fix.smem_len)
+		count = info->fix.smem_len;
+	err = 0;
+	if (count + p > info->fix.smem_len) {
+		count = info->fix.smem_len - p;
+		err = -ENOSPC;
+	}
+	if (count) {
+		char *base_addr;
+
+		base_addr = info->screen_base;
+		count -= copy_from_user(base_addr+p, buf, count);
+		*ppos += count;
+		err = -EFAULT;
+	}
+
+	s1d15605_update(info);
+
+	if (count)
+		return count;
+
+	return err;
+}
+
+#ifdef	USE_PRIVATE_VMA_FXS
+static void s1d15605_vma_open(struct vm_area_struct *vma)
+{
+	// FIXME - store stats in the device data via vm_private_data
+}
+
+
+static void s1d15605_vma_close(struct vm_area_struct *vma)
+{
+	// FIXME - store stats in the device data via vm_private_data
+}
+
+
+static struct page *s1d15605_vma_nopage(struct vm_area_struct *vma,
+				unsigned long address, int *type)
+{
+	struct page *page;
+	struct fb_info *info = vma->vm_private_data;
+
+	page = virt_to_page(info->screen_base);
+	get_page(page);
+
+	// FIXME - now someone has a link to our page, start periodically blitting
+	// latest updates to the actual device.
+
+	return page;
+}
+
+
+static struct vm_operations_struct s1d15605_vm_ops = {
+	.open	= s1d15605_vma_open,
+	.close	= s1d15605_vma_close,
+	.nopage	= s1d15605_vma_nopage
+};
+
+
+/* We don't do much here - because we have special vm_ops */
+static int s1d15605_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	vma->vm_ops = &s1d15605_vm_ops;
+	vma->vm_flags |= VM_RESERVED;
+	vma->vm_private_data = info;
+	s1d15605_vma_open(vma);
+
+	return 0;
+}
+#endif /* USE_PRIVATE_VMA_FXS */
+
+
+static struct fb_ops s1d15605fb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= s1d15605_check_var,
+	.fb_set_par	= s1d15605_set_par,
+	.fb_setcolreg	= s1d15605_setcolreg,
+	.fb_blank	= s1d15605_blank,
+//	.fb_pan_display	= s1d15605_pan_display,
+	.fb_fillrect	= s1d15605_fillrect,
+	.fb_copyarea	= s1d15605_copyarea,
+	.fb_imageblit	= s1d15605_imageblit,
+	.fb_write	= s1d15605_write,
+#ifdef	USE_PRIVATE_VMA_FXS
+	.fb_mmap	= s1d15605_mmap,
+#endif
+};
+
+
+static void s1d15605_device_init(struct s1d15605fb_info *sinfo) {
+
+	char	value;
+
+	/* release the reset line by reading the device - proto hardware */
+	value = READ_COMMAND;
+	value = READ_COMMAND;
+
+#ifdef CONFIG_MACH_KB9200
+	/* new boards have dedicated reset line */
+	gpio_set_value(sinfo->reset_pin, 1);
+#endif
+
+	/* initialize the device within 5ms */
+	WRITE_COMMAND(RESET_DISPLAY);
+	WRITE_COMMAND(LCD_BIAS_1_9);
+	WRITE_COMMAND(ADC_SELECT_REVERSE);
+	WRITE_COMMAND(COMMON_OUTPUT_NORMAL);
+	WRITE_COMMAND(V5_RESISTOR_RATIO);
+	WRITE_COMMAND(ELECTRONIC_VOLUME_SET);
+	WRITE_COMMAND(ELECTRONIC_VOLUME_INIT);
+	WRITE_COMMAND(POWER_CONTROL_SET | VOLTAGE_REGULATOR | VOLTAGE_FOLLOWER | BOOSTER_CIRCUIT);
+	WRITE_COMMAND(DISPLAY_ON);
+
+	WRITE_COMMAND(RESISTOR_RATIO_START + 4);
+	WRITE_COMMAND(ELECTRONIC_VOLUME_SET);
+	WRITE_COMMAND(0x33);
+}
+
+
+static int s1d15605fb_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct fb_info *info;
+	struct s1d15605fb_info *sinfo;
+	int ret;
+
+	MSG("%s\n", __func__);
+
+	if (!(info = framebuffer_alloc(sizeof(struct s1d15605fb_info), dev))) {
+		dev_err(dev, "Cannot allocate framebuffer struct\n");
+		return -ENOMEM;
+	}
+
+	sinfo = info->par;
+	sinfo->info = info;
+	sinfo->pdev = pdev;
+
+	if (pdev->num_resources < 2) {
+		dev_err(dev, "Resources unusable\n");
+		ret = -ENODEV;
+		goto free_info;
+	}
+
+	info->fbops = &s1d15605fb_ops;
+	strcpy(info->fix.id, pdev->name);
+
+	info->fix.mmio_start = pdev->resource[0].start;
+	info->fix.mmio_len = pdev->resource[0].end - pdev->resource[0].start + 1;
+	sinfo->reset_pin = pdev->resource[1].start;
+
+	ret = s1d15605fb_resize_framebuffer(sinfo);
+	if (ret < 0) {
+		dev_err(dev, "Cannot resize framebuffer: %d\n", ret);
+		goto free_fb;
+	}
+
+	if (!request_mem_region(info->fix.mmio_start,
+				info->fix.mmio_len, pdev->name)) {
+		ret = -EBUSY;
+		goto free_fb;
+	}
+
+	sinfo->mmio = ioremap(info->fix.mmio_start, info->fix.mmio_len);
+	if (!sinfo->mmio) {
+		dev_err(dev, "Cannot map LCD memory region\n");
+		goto release_mem;
+	}
+
+	s1d15605_device_init(sinfo);
+
+	ret = fb_find_mode(&info->var, info, NULL, NULL, 0, NULL, 1);
+
+	if (!ret || (ret == 4))
+		info->var = s1d15605_default;
+
+	info->fix = s1d15605_fix;
+	info->flags = FBINFO_FLAG_DEFAULT |
+/*		FBINFO_HWACCEL_YPAN | */
+		FBINFO_HWACCEL_FILLRECT | FBINFO_HWACCEL_COPYAREA;
+
+	ret = register_framebuffer(info);
+	if (ret < 0) {
+		dev_err(dev, "Failed to register framebuffer device: %d\n", ret);
+		goto unmap_mmio;
+	}
+
+	dev_set_drvdata(dev, info);
+
+	memset(info->screen_base, 0, info->fix.smem_len);
+	info->var.activate |= FB_ACTIVATE_NOW;
+	ret = fb_set_var(info, &info->var);
+	if (ret) {
+		dev_warn(dev, "Unable to set display parameters\n");
+	}
+
+	info->var.activate &= ~(FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW);
+
+	dev_dbg(dev, "%s SUCCESS\n", __func__);
+
+	dev_info(dev, "Driver $Revision: 1.1 $\n");
+
+	return 0;
+
+unmap_mmio:
+	iounmap(sinfo->mmio);
+release_mem:
+	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
+free_fb:
+	kfree(info->screen_base);
+
+free_info:
+	framebuffer_release(info);
+
+	dev_dbg(dev, "%s FAILED\n", __func__);
+	return ret;
+}
+
+
+static int s1d15605fb_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct fb_info *info = dev_get_drvdata(dev);
+	struct s1d15605fb_info *sinfo = info->par;
+
+	if (!sinfo)
+		return 0;
+
+	unregister_framebuffer(info);
+
+	iounmap(sinfo->mmio);
+	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
+
+	kfree(info->screen_base);
+
+	dev_set_drvdata(dev, NULL);
+	framebuffer_release(info);
+	return 0;
+}
+
+
+static struct platform_driver s1d15605fb_driver = {
+	.probe		= s1d15605fb_probe,
+	.remove		= s1d15605fb_remove,
+	.driver		= {
+		.name	= "s1d15605fb",
+		.owner	= THIS_MODULE,
+	},
+};
+
+
+static int __init s1d15605fb_init(void)
+{
+	return platform_driver_register(&s1d15605fb_driver);
+}
+
+
+static void __exit s1d15605fb_exit(void)
+{
+	platform_driver_unregister(&s1d15605fb_driver);
+}
+
+
+module_init(s1d15605fb_init);
+module_exit(s1d15605fb_exit);
+
+
+MODULE_AUTHOR("KwikByte");
+MODULE_DESCRIPTION("Epson S1D15605 LCD Controller framebuffer driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.21.7/include/asm-arm/arch-at91/at91_adc.h
===================================================================
--- /dev/null
+++ linux-2.6.21.7/include/asm-arm/arch-at91/at91_adc.h
@@ -0,0 +1,61 @@
+/*
+ * include/asm-arm/arch-at91/at91_adc.h
+ *
+ * Copyright (C) SAN People
+ *
+ * Analog-to-Digital Converter (ADC) registers.
+ * Based on AT91SAM9260 datasheet revision D.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91_ADC_H
+#define AT91_ADC_H
+
+#define AT91_ADC_CR		0x00		/* Control Register */
+#define		AT91_ADC_SWRST		(1 << 0)	/* Software Reset */
+#define		AT91_ADC_START		(1 << 1)	/* Start Conversion */
+
+#define AT91_ADC_MR		0x04		/* Mode Register */
+#define		AT91_ADC_TRGEN		(1 << 0)	/* Trigger Enable */
+#define		AT91_ADC_TRGSEL		(7 << 1)	/* Trigger Selection */
+#define			AT91_ADC_TRGSEL_TC0		(0 << 1)
+#define			AT91_ADC_TRGSEL_TC1		(1 << 1)
+#define			AT91_ADC_TRGSEL_TC2		(2 << 1)
+#define			AT91_ADC_TRGSEL_EXTERNAL	(6 << 1)
+#define		AT91_ADC_LOWRES		(1 << 4)	/* Low Resolution */
+#define		AT91_ADC_SLEEP		(1 << 5)	/* Sleep Mode */
+#define		AT91_ADC_PRESCAL	(0x3f << 8)	/* Prescalar Rate Selection */
+#define			AT91_ADC_PRESCAL_(x)	((x) << 8)
+#define		AT91_ADC_STARTUP	(0x1f << 16)	/* Startup Up Time */
+#define			AT91_ADC_STARTUP_(x)	((x) << 16)
+#define		AT91_ADC_SHTIM		(0xf  << 24)	/* Sample & Hold Time */
+#define			AT91_ADC_SHTIM_(x)	((x) << 24)
+
+#define AT91_ADC_CHER		0x10		/* Channel Enable Register */
+#define AT91_ADC_CHDR		0x14		/* Channel Disable Register */
+#define AT91_ADC_CHSR		0x18		/* Channel Status Register */
+#define		AT91_ADC_CH(n)		(1 << (n))	/* Channel Number */
+
+#define AT91_ADC_SR		0x1C		/* Status Register */
+#define		AT91_ADC_EOC(n)		(1 << (n))	/* End of Conversion on Channel N */
+#define		AT91_ADC_OVRE(n)	(1 << ((n) + 8))/* Overrun Error on Channel N */
+#define		AT91_ADC_DRDY		(1 << 16)	/* Data Ready */
+#define		AT91_ADC_GOVRE		(1 << 17)	/* General Overrun Error */
+#define		AT91_ADC_ENDRX		(1 << 18)	/* End of RX Buffer */
+#define		AT91_ADC_RXFUFF		(1 << 19)	/* RX Buffer Full */
+
+#define AT91_ADC_LCDR		0x20		/* Last Converted Data Register */
+#define		AT91_ADC_LDATA		(0x3ff)
+
+#define AT91_ADC_IER		0x24		/* Interrupt Enable Register */
+#define AT91_ADC_IDR		0x28		/* Interrupt Disable Register */
+#define AT91_ADC_IMR		0x2C		/* Interrupt Mask Register */
+
+#define AT91_ADC_CHR(n)		(0x30 + ((n) * 4)	/* Channel Data Register N */
+#define		AT91_ADC_DATA		(0x3ff)
+
+#endif
Index: linux-2.6.21.7/include/asm-arm/arch-at91/at91_mci.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/at91_mci.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/at91_mci.h
@@ -26,6 +26,9 @@
 #define AT91_MCI_MR		0x04		/* Mode Register */
 #define		AT91_MCI_CLKDIV		(0xff  <<  0)	/* Clock Divider */
 #define		AT91_MCI_PWSDIV		(7     <<  8)	/* Power Saving Divider */
+#define		AT91_MCI_RDPROOF	(1     << 11)	/* Read Proof Enable [SAM926[03] only] */
+#define		AT91_MCI_WRPROOF	(1     << 12)	/* Write Proof Enable [SAM926[03] only] */
+#define		AT91_MCI_PDCFBYTE	(1     << 13)	/* PDC Force Byte Transfer [SAM926[03] only] */
 #define		AT91_MCI_PDCPADV	(1     << 14)	/* PDC Padding Value */
 #define		AT91_MCI_PDCMODE	(1     << 15)	/* PDC-orientated Mode */
 #define		AT91_MCI_BLKLEN		(0xfff << 18)	/* Data Block Length */
Index: linux-2.6.21.7/include/asm-arm/arch-at91/at91_pmc.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/at91_pmc.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/at91_pmc.h
@@ -37,7 +37,9 @@
 #define	AT91_PMC_PCDR		(AT91_PMC + 0x14)	/* Peripheral Clock Disable Register */
 #define	AT91_PMC_PCSR		(AT91_PMC + 0x18)	/* Peripheral Clock Status Register */
 
-#define	AT91_CKGR_MOR		(AT91_PMC + 0x20)	/* Main Oscillator Register */
+#define AT91_CKGR_UCKR		(AT91_PMC + 0x1C)	/* UTMI Clock Register [SAM9RL only] */
+
+#define	AT91_CKGR_MOR		(AT91_PMC + 0x20)	/* Main Oscillator Register [not on SAM9RL] */
 #define		AT91_PMC_MOSCEN		(1    << 0)		/* Main Oscillator Enable */
 #define		AT91_PMC_OSCBYPASS	(1    << 1)		/* Oscillator Bypass [AT91SAM926x only] */
 #define		AT91_PMC_OSCOUNT	(0xff << 8)		/* Main Oscillator Start-up Time */
Index: linux-2.6.21.7/include/asm-arm/arch-at91/at91rm9200.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/at91rm9200.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/at91rm9200.h
@@ -107,185 +107,4 @@
 #define AT91RM9200_UHP_BASE	0x00300000	/* USB Host controller */
 
 
-#if 0
-/*
- * PIO pin definitions (peripheral A/B multiplexing).
- */
-#define AT91_PA0_MISO		(1 <<  0)	/* A: SPI Master-In Slave-Out */
-#define AT91_PA0_PCK3		(1 <<  0)	/* B: PMC Programmable Clock Output 3 */
-#define AT91_PA1_MOSI		(1 <<  1)	/* A: SPI Master-Out Slave-In */
-#define AT91_PA1_PCK0		(1 <<  1)	/* B: PMC Programmable Clock Output 0 */
-#define AT91_PA2_SPCK		(1 <<  2)	/* A: SPI Serial Clock */
-#define AT91_PA2_IRQ4		(1 <<  2)	/* B: External Interrupt 4 */
-#define AT91_PA3_NPCS0		(1 <<  3)	/* A: SPI Peripheral Chip Select 0 */
-#define AT91_PA3_IRQ5		(1 <<  3)	/* B: External Interrupt 5 */
-#define AT91_PA4_NPCS1		(1 <<  4)	/* A: SPI Peripheral Chip Select 1 */
-#define AT91_PA4_PCK1		(1 <<  4)	/* B: PMC Programmable Clock Output 1 */
-#define AT91_PA5_NPCS2		(1 <<  5)	/* A: SPI Peripheral Chip Select 2 */
-#define AT91_PA5_TXD3		(1 <<  5)	/* B: USART Transmit Data 3 */
-#define AT91_PA6_NPCS3		(1 <<  6)	/* A: SPI Peripheral Chip Select 3 */
-#define AT91_PA6_RXD3		(1 <<  6)	/* B: USART Receive Data 3 */
-#define AT91_PA7_ETXCK_EREFCK	(1 <<  7)	/* A: Ethernet Reference Clock / Transmit Clock */
-#define AT91_PA7_PCK2		(1 <<  7)	/* B: PMC Programmable Clock Output 2 */
-#define AT91_PA8_ETXEN		(1 <<  8)	/* A: Ethernet Transmit Enable */
-#define AT91_PA8_MCCDB		(1 <<  8)	/* B: MMC Multimedia Card B Command */
-#define AT91_PA9_ETX0		(1 <<  9)	/* A: Ethernet Transmit Data 0 */
-#define AT91_PA9_MCDB0		(1 <<  9)	/* B: MMC Multimedia Card B Data 0 */
-#define AT91_PA10_ETX1		(1 << 10)	/* A: Ethernet Transmit Data 1 */
-#define AT91_PA10_MCDB1		(1 << 10)	/* B: MMC Multimedia Card B Data 1 */
-#define AT91_PA11_ECRS_ECRSDV	(1 << 11)	/* A: Ethernet Carrier Sense / Data Valid */
-#define AT91_PA11_MCDB2		(1 << 11)	/* B: MMC Multimedia Card B Data 2 */
-#define AT91_PA12_ERX0		(1 << 12)	/* A: Ethernet Receive Data 0 */
-#define AT91_PA12_MCDB3		(1 << 12)	/* B: MMC Multimedia Card B Data 3 */
-#define AT91_PA13_ERX1		(1 << 13)	/* A: Ethernet Receive Data 1 */
-#define AT91_PA13_TCLK0		(1 << 13)	/* B: TC External Clock Input 0 */
-#define AT91_PA14_ERXER		(1 << 14)	/* A: Ethernet Receive Error */
-#define AT91_PA14_TCLK1		(1 << 14)	/* B: TC External Clock Input 1 */
-#define AT91_PA15_EMDC		(1 << 15)	/* A: Ethernet Management Data Clock */
-#define AT91_PA15_TCLK2		(1 << 15)	/* B: TC External Clock Input 2 */
-#define AT91_PA16_EMDIO		(1 << 16)	/* A: Ethernet Management Data I/O */
-#define AT91_PA16_IRQ6		(1 << 16)	/* B: External Interrupt 6 */
-#define AT91_PA17_TXD0		(1 << 17)	/* A: USART Transmit Data 0 */
-#define AT91_PA17_TIOA0		(1 << 17)	/* B: TC I/O Line A 0 */
-#define AT91_PA18_RXD0		(1 << 18)	/* A: USART Receive Data 0 */
-#define AT91_PA18_TIOB0		(1 << 18)	/* B: TC I/O Line B 0 */
-#define AT91_PA19_SCK0		(1 << 19)	/* A: USART Serial Clock 0 */
-#define AT91_PA19_TIOA1		(1 << 19)	/* B: TC I/O Line A 1 */
-#define AT91_PA20_CTS0		(1 << 20)	/* A: USART Clear To Send 0 */
-#define AT91_PA20_TIOB1		(1 << 20)	/* B: TC I/O Line B 1 */
-#define AT91_PA21_RTS0		(1 << 21)	/* A: USART Ready To Send 0 */
-#define AT91_PA21_TIOA2		(1 << 21)	/* B: TC I/O Line A 2 */
-#define AT91_PA22_RXD2		(1 << 22)	/* A: USART Receive Data 2 */
-#define AT91_PA22_TIOB2		(1 << 22)	/* B: TC I/O Line B 2 */
-#define AT91_PA23_TXD2		(1 << 23)	/* A: USART Transmit Data 2 */
-#define AT91_PA23_IRQ3		(1 << 23)	/* B: External Interrupt 3 */
-#define AT91_PA24_SCK2		(1 << 24)	/* A: USART Serial Clock 2 */
-#define AT91_PA24_PCK1		(1 << 24)	/* B: PMC Programmable Clock Output 1 */
-#define AT91_PA25_TWD		(1 << 25)	/* A: TWI Two-wire Serial Data */
-#define AT91_PA25_IRQ2		(1 << 25)	/* B: External Interrupt 2 */
-#define AT91_PA26_TWCK		(1 << 26)	/* A: TWI Two-wire Serial Clock */
-#define AT91_PA26_IRQ1		(1 << 26)	/* B: External Interrupt 1 */
-#define AT91_PA27_MCCK		(1 << 27)	/* A: MMC Multimedia Card Clock */
-#define AT91_PA27_TCLK3		(1 << 27)	/* B: TC External Clock Input 3 */
-#define AT91_PA28_MCCDA		(1 << 28)	/* A: MMC Multimedia Card A Command */
-#define AT91_PA28_TCLK4		(1 << 28)	/* B: TC External Clock Input 4 */
-#define AT91_PA29_MCDA0		(1 << 29)	/* A: MMC Multimedia Card A Data 0 */
-#define AT91_PA29_TCLK5		(1 << 29)	/* B: TC External Clock Input 5 */
-#define AT91_PA30_DRXD		(1 << 30)	/* A: DBGU Receive Data */
-#define AT91_PA30_CTS2		(1 << 30)	/* B: USART Clear To Send 2 */
-#define AT91_PA31_DTXD		(1 << 31)	/* A: DBGU Transmit Data */
-#define AT91_PA31_RTS2		(1 << 31)	/* B: USART Ready To Send 2 */
-
-#define AT91_PB0_TF0		(1 <<  0)	/* A: SSC Transmit Frame Sync 0 */
-#define AT91_PB0_RTS3		(1 <<  0)	/* B: USART Ready To Send 3 */
-#define AT91_PB1_TK0		(1 <<  1)	/* A: SSC Transmit Clock 0 */
-#define AT91_PB1_CTS3		(1 <<  1)	/* B: USART Clear To Send 3 */
-#define AT91_PB2_TD0		(1 <<  2)	/* A: SSC Transmit Data 0 */
-#define AT91_PB2_SCK3		(1 <<  2)	/* B: USART Serial Clock 3 */
-#define AT91_PB3_RD0		(1 <<  3)	/* A: SSC Receive Data 0 */
-#define AT91_PB3_MCDA1		(1 <<  3)	/* B: MMC Multimedia Card A Data 1 */
-#define AT91_PB4_RK0		(1 <<  4)	/* A: SSC Receive Clock 0 */
-#define AT91_PB4_MCDA2		(1 <<  4)	/* B: MMC Multimedia Card A Data 2 */
-#define AT91_PB5_RF0		(1 <<  5)	/* A: SSC Receive Frame Sync 0 */
-#define AT91_PB5_MCDA3		(1 <<  5)	/* B: MMC Multimedia Card A Data 3 */
-#define AT91_PB6_TF1		(1 <<  6)	/* A: SSC Transmit Frame Sync 1 */
-#define AT91_PB6_TIOA3		(1 <<  6)	/* B: TC I/O Line A 3 */
-#define AT91_PB7_TK1		(1 <<  7)	/* A: SSC Transmit Clock 1 */
-#define AT91_PB7_TIOB3		(1 <<  7)	/* B: TC I/O Line B 3 */
-#define AT91_PB8_TD1		(1 <<  8)	/* A: SSC Transmit Data 1 */
-#define AT91_PB8_TIOA4		(1 <<  8)	/* B: TC I/O Line A 4 */
-#define AT91_PB9_RD1		(1 <<  9)	/* A: SSC Receive Data 1 */
-#define AT91_PB9_TIOB4		(1 <<  9)	/* B: TC I/O Line B 4 */
-#define AT91_PB10_RK1		(1 << 10)	/* A: SSC Receive Clock 1 */
-#define AT91_PB10_TIOA5		(1 << 10)	/* B: TC I/O Line A 5 */
-#define AT91_PB11_RF1		(1 << 11)	/* A: SSC Receive Frame Sync 1 */
-#define AT91_PB11_TIOB5		(1 << 11)	/* B: TC I/O Line B 5 */
-#define AT91_PB12_TF2		(1 << 12)	/* A: SSC Transmit Frame Sync 2 */
-#define AT91_PB12_ETX2		(1 << 12)	/* B: Ethernet Transmit Data 2 */
-#define AT91_PB13_TK2		(1 << 13)	/* A: SSC Transmit Clock 3 */
-#define AT91_PB13_ETX3		(1 << 13)	/* B: Ethernet Transmit Data 3 */
-#define AT91_PB14_TD2		(1 << 14)	/* A: SSC Transmit Data 2 */
-#define AT91_PB14_ETXER		(1 << 14)	/* B: Ethernet Transmit Coding Error */
-#define AT91_PB15_RD2		(1 << 15)	/* A: SSC Receive Data 2 */
-#define AT91_PB15_ERX2		(1 << 15)	/* B: Ethernet Receive Data 2 */
-#define AT91_PB16_RK2		(1 << 16)	/* A: SSC Receive Clock 2 */
-#define AT91_PB16_ERX3		(1 << 16)	/* B: Ethernet Receive Data 3 */
-#define AT91_PB17_RF2		(1 << 17)	/* A: SSC Receive Frame Sync 2 */
-#define AT91_PB17_ERXDV		(1 << 17)	/* B: Ethernet Receive Data Valid */
-#define AT91_PB18_RI1		(1 << 18)	/* A: USART Ring Indicator 1 */
-#define AT91_PB18_ECOL		(1 << 18)	/* B: Ethernet Collision Detected */
-#define AT91_PB19_DTR1		(1 << 19)	/* A: USART Data Terminal Ready 1 */
-#define AT91_PB19_ERXCK		(1 << 19)	/* B: Ethernet Receive Clock */
-#define AT91_PB20_TXD1		(1 << 20)	/* A: USART Transmit Data 1 */
-#define AT91_PB21_RXD1		(1 << 21)	/* A: USART Receive Data 1 */
-#define AT91_PB22_SCK1		(1 << 22)	/* A: USART Serial Clock 1 */
-#define AT91_PB23_DCD1		(1 << 23)	/* A: USART Data Carrier Detect 1 */
-#define AT91_PB24_CTS1		(1 << 24)	/* A: USART Clear To Send 1 */
-#define AT91_PB25_DSR1		(1 << 25)	/* A: USART Data Set Ready 1 */
-#define AT91_PB25_EF100		(1 << 25)	/* B: Ethernet Force 100 Mbit */
-#define AT91_PB26_RTS1		(1 << 26)	/* A: USART Ready To Send 1 */
-#define AT91_PB27_PCK0		(1 << 27)	/* B: PMC Programmable Clock Output 0 */
-#define AT91_PB28_FIQ		(1 << 28)	/* A: Fast Interrupt */
-#define AT91_PB29_IRQ0		(1 << 29)	/* A: External Interrupt 0 */
-
-#define AT91_PC0_BFCK		(1 <<  0)	/* A: Burst Flash Clock */
-#define AT91_PC1_BFRDY_SMOE	(1 <<  1)	/* A: Burst Flash Ready / SmartMedia Output Enable */
-#define AT91_PC2_BFAVD		(1 <<  2)	/* A: Burst Flash Address Valid */
-#define AT91_PC3_BFBAA_SMWE	(1 <<  3)	/* A: Burst Flash Address Advance / SmartMedia Write Enable */
-#define AT91_PC4_BFOE		(1 <<  4)	/* A: Burst Flash Output Enable */
-#define AT91_PC5_BFWE		(1 <<  5)	/* A: Burst Flash Write Enable */
-#define AT91_PC6_NWAIT		(1 <<  6)	/* A: SMC Wait Signal */
-#define AT91_PC7_A23		(1 <<  7)	/* A: Address Bus 23 */
-#define AT91_PC8_A24		(1 <<  8)	/* A: Address Bus 24 */
-#define AT91_PC9_A25_CFRNW	(1 <<  9)	/* A: Address Bus 25 / Compact Flash Read Not Write */
-#define AT91_PC10_NCS4_CFCS	(1 << 10)	/* A: SMC Chip Select 4 / Compact Flash Chip Select */
-#define AT91_PC11_NCS5_CFCE1	(1 << 11)	/* A: SMC Chip Select 5 / Compact Flash Chip Enable 1 */
-#define AT91_PC12_NCS6_CFCE2	(1 << 12)	/* A: SMC Chip Select 6 / Compact Flash Chip Enable 2 */
-#define AT91_PC13_NCS7		(1 << 13)	/* A: Chip Select 7 */
-
-#define AT91_PD0_ETX0		(1 <<  0)	/* A: Ethernet Transmit Data 0 */
-#define AT91_PD1_ETX1		(1 <<  1)	/* A: Ethernet Transmit Data 1 */
-#define AT91_PD2_ETX2		(1 <<  2)	/* A: Ethernet Transmit Data 2 */
-#define AT91_PD3_ETX3		(1 <<  3)	/* A: Ethernet Transmit Data 3 */
-#define AT91_PD4_ETXEN		(1 <<  4)	/* A: Ethernet Transmit Enable */
-#define AT91_PD5_ETXER		(1 <<  5)	/* A: Ethernet Transmit Coding Error */
-#define AT91_PD6_DTXD		(1 <<  6)	/* A: DBGU Transmit Data */
-#define AT91_PD7_PCK0		(1 <<  7)	/* A: PMC Programmable Clock Output 0 */
-#define AT91_PD7_TSYNC		(1 <<  7)	/* B: ETM Trace Synchronization Signal */
-#define AT91_PD8_PCK1		(1 <<  8)	/* A: PMC Programmable Clock Output 1 */
-#define AT91_PD8_TCLK		(1 <<  8)	/* B: ETM Trace Clock */
-#define AT91_PD9_PCK2		(1 <<  9)	/* A: PMC Programmable Clock Output 2 */
-#define AT91_PD9_TPS0		(1 <<  9)	/* B: ETM Trace ARM Pipeline Status 0 */
-#define AT91_PD10_PCK3		(1 << 10)	/* A: PMC Programmable Clock Output 3 */
-#define AT91_PD10_TPS1		(1 << 10)	/* B: ETM Trace ARM Pipeline Status 1 */
-#define AT91_PD11_TPS2		(1 << 11)	/* B: ETM Trace ARM Pipeline Status 2 */
-#define AT91_PD12_TPK0		(1 << 12)	/* B: ETM Trace Packet Port 0 */
-#define AT91_PD13_TPK1		(1 << 13)	/* B: ETM Trace Packet Port 1 */
-#define AT91_PD14_TPK2		(1 << 14)	/* B: ETM Trace Packet Port 2 */
-#define AT91_PD15_TD0		(1 << 15)	/* A: SSC Transmit Data 0 */
-#define AT91_PD15_TPK3		(1 << 15)	/* B: ETM Trace Packet Port 3 */
-#define AT91_PD16_TD1		(1 << 16)	/* A: SSC Transmit Data 1 */
-#define AT91_PD16_TPK4		(1 << 16)	/* B: ETM Trace Packet Port 4 */
-#define AT91_PD17_TD2		(1 << 17)	/* A: SSC Transmit Data 2 */
-#define AT91_PD17_TPK5		(1 << 17)	/* B: ETM Trace Packet Port 5 */
-#define AT91_PD18_NPCS1		(1 << 18)	/* A: SPI Peripheral Chip Select 1 */
-#define AT91_PD18_TPK6		(1 << 18)	/* B: ETM Trace Packet Port 6 */
-#define AT91_PD19_NPCS2		(1 << 19)	/* A: SPI Peripheral Chip Select 2 */
-#define AT91_PD19_TPK7		(1 << 19)	/* B: ETM Trace Packet Port 7 */
-#define AT91_PD20_NPCS3		(1 << 20)	/* A: SPI Peripheral Chip Select 3 */
-#define AT91_PD20_TPK8		(1 << 20)	/* B: ETM Trace Packet Port 8 */
-#define AT91_PD21_RTS0		(1 << 21)	/* A: USART Ready To Send 0 */
-#define AT91_PD21_TPK9		(1 << 21)	/* B: ETM Trace Packet Port 9 */
-#define AT91_PD22_RTS1		(1 << 22)	/* A: USART Ready To Send 1 */
-#define AT91_PD22_TPK10		(1 << 22)	/* B: ETM Trace Packet Port 10 */
-#define AT91_PD23_RTS2		(1 << 23)	/* A: USART Ready To Send 2 */
-#define AT91_PD23_TPK11		(1 << 23)	/* B: ETM Trace Packet Port 11 */
-#define AT91_PD24_RTS3		(1 << 24)	/* A: USART Ready To Send 3 */
-#define AT91_PD24_TPK12		(1 << 24)	/* B: ETM Trace Packet Port 12 */
-#define AT91_PD25_DTR1		(1 << 25)	/* A: USART Data Terminal Ready 1 */
-#define AT91_PD25_TPK13		(1 << 25)	/* B: ETM Trace Packet Port 13 */
-#define AT91_PD26_TPK14		(1 << 26)	/* B: ETM Trace Packet Port 14 */
-#define AT91_PD27_TPK15		(1 << 27)	/* B: ETM Trace Packet Port 15 */
-#endif
-
 #endif
Index: linux-2.6.21.7/include/asm-arm/arch-at91/at91sam9260.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/at91sam9260.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/at91sam9260.h
@@ -117,13 +117,4 @@
 #define AT91SAM9XE_SRAM_BASE	0x00300000	/* Internal SRAM base address */
 
 
-#if 0
-/*
- * PIO pin definitions (peripheral A/B multiplexing).
- */
-
-// TODO: Add
-
-#endif
-
 #endif
Index: linux-2.6.21.7/include/asm-arm/arch-at91/at91sam9260_matrix.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/at91sam9260_matrix.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/at91sam9260_matrix.h
@@ -67,7 +67,7 @@
 #define		AT91_MATRIX_CS4A		(1 << 4)	/* Chip Select 4 Assignment */
 #define			AT91_MATRIX_CS4A_SMC		(0 << 4)
 #define			AT91_MATRIX_CS4A_SMC_CF1	(1 << 4)
-#define		AT91_MATRIX_CS5A		(1 << 5 )	/* Chip Select 5 Assignment */
+#define		AT91_MATRIX_CS5A		(1 << 5)	/* Chip Select 5 Assignment */
 #define			AT91_MATRIX_CS5A_SMC		(0 << 5)
 #define			AT91_MATRIX_CS5A_SMC_CF2	(1 << 5)
 #define		AT91_MATRIX_DBPUC		(1 << 8)	/* Data Bus Pull-up Configuration */
Index: linux-2.6.21.7/include/asm-arm/arch-at91/at91sam9261.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/at91sam9261.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/at91sam9261.h
@@ -98,195 +98,4 @@
 #define AT91SAM9261_LCDC_BASE	0x00600000	/* LDC controller */
 
 
-#if 0
-/*
- * PIO pin definitions (peripheral A/B multiplexing).
- */
-#define AT91_PA0_SPI0_MISO	(1 <<  0)	/* A: SPI0 Master In Slave */
-#define AT91_PA0_MCDA0		(1 <<  0)	/* B: Multimedia Card A Data 0 */
-#define AT91_PA1_SPI0_MOSI	(1 <<  1)	/* A: SPI0 Master Out Slave */
-#define AT91_PA1_MCCDA		(1 <<  1)	/* B: Multimedia Card A Command */
-#define AT91_PA2_SPI0_SPCK	(1 <<  2)	/* A: SPI0 Serial Clock */
-#define AT91_PA2_MCCK		(1 <<  2)	/* B: Multimedia Card Clock */
-#define AT91_PA3_SPI0_NPCS0	(1 <<  3)	/* A: SPI0 Peripheral Chip Select 0 */
-#define AT91_PA4_SPI0_NPCS1	(1 <<  4)	/* A: SPI0 Peripheral Chip Select 1 */
-#define AT91_PA4_MCDA1		(1 <<  4)	/* B: Multimedia Card A Data 1 */
-#define AT91_PA5_SPI0_NPCS2	(1 <<  5)	/* A: SPI0 Peripheral Chip Select 2 */
-#define AT91_PA5_MCDA2		(1 <<  5)	/* B: Multimedia Card A Data 2 */
-#define AT91_PA6_SPI0_NPCS3	(1 <<  6)	/* A: SPI0 Peripheral Chip Select 3 */
-#define AT91_PA6_MCDA3		(1 <<  6)	/* B: Multimedia Card A Data 3 */
-#define AT91_PA7_TWD		(1 <<  7)	/* A: TWI Two-wire Serial Data */
-#define AT91_PA7_PCK0		(1 <<  7)	/* B: PMC Programmable clock Output 0 */
-#define AT91_PA8_TWCK		(1 <<  8)	/* A: TWI Two-wire Serial Clock */
-#define AT91_PA8_PCK1		(1 <<  8)	/* B: PMC Programmable clock Output 1 */
-#define AT91_PA9_DRXD		(1 <<  9)	/* A: DBGU Debug Receive Data */
-#define AT91_PA9_PCK2		(1 <<  9)	/* B: PMC Programmable clock Output 2 */
-#define AT91_PA10_DTXD		(1 << 10)	/* A: DBGU Debug Transmit Data */
-#define AT91_PA10_PCK3		(1 << 10)	/* B: PMC Programmable clock Output 3 */
-#define AT91_PA11_TSYNC		(1 << 11)	/* A: Trace Synchronization Signal */
-#define AT91_PA11_SCK1		(1 << 11)	/* B: USART1 Serial Clock */
-#define AT91_PA12_TCLK		(1 << 12)	/* A: Trace Clock */
-#define AT91_PA12_RTS1		(1 << 12)	/* B: USART1 Ready To Send */
-#define AT91_PA13_TPS0		(1 << 13)	/* A: Trace ARM Pipeline Status 0 */
-#define AT91_PA13_CTS1		(1 << 13)	/* B: USART1 Clear To Send */
-#define AT91_PA14_TPS1		(1 << 14)	/* A: Trace ARM Pipeline Status 1 */
-#define AT91_PA14_SCK2		(1 << 14)	/* B: USART2 Serial Clock */
-#define AT91_PA15_TPS2		(1 << 15)	/* A: Trace ARM Pipeline Status 2 */
-#define AT91_PA15_RTS2		(1 << 15)	/* B: USART2 Ready To Send */
-#define AT91_PA16_TPK0		(1 << 16)	/* A: Trace Packet Port 0 */
-#define AT91_PA16_CTS2		(1 << 16)	/* B: USART2 Clear To Send */
-#define AT91_PA17_TPK1		(1 << 17)	/* A: Trace Packet Port 1 */
-#define AT91_PA17_TF1		(1 << 17)	/* B: SSC1 Transmit Frame Sync */
-#define AT91_PA18_TPK2		(1 << 18)	/* A: Trace Packet Port 2 */
-#define AT91_PA18_TK1		(1 << 18)	/* B: SSC1 Transmit Clock */
-#define AT91_PA19_TPK3		(1 << 19)	/* A: Trace Packet Port 3 */
-#define AT91_PA19_TD1		(1 << 19)	/* B: SSC1 Transmit Data */
-#define AT91_PA20_TPK4		(1 << 20)	/* A: Trace Packet Port 4 */
-#define AT91_PA20_RD1		(1 << 20)	/* B: SSC1 Receive Data */
-#define AT91_PA21_TPK5		(1 << 21)	/* A: Trace Packet Port 5 */
-#define AT91_PA21_RK1		(1 << 21)	/* B: SSC1 Receive Clock */
-#define AT91_PA22_TPK6		(1 << 22)	/* A: Trace Packet Port 6 */
-#define AT91_PA22_RF1		(1 << 22)	/* B: SSC1 Receive Frame Sync */
-#define AT91_PA23_TPK7		(1 << 23)	/* A: Trace Packet Port 7 */
-#define AT91_PA23_RTS0		(1 << 23)	/* B: USART0 Ready To Send */
-#define AT91_PA24_TPK8		(1 << 24)	/* A: Trace Packet Port 8 */
-#define AT91_PA24_SPI1_NPCS1	(1 << 24)	/* B: SPI1 Peripheral Chip Select 1 */
-#define AT91_PA25_TPK9		(1 << 25)	/* A: Trace Packet Port 9 */
-#define AT91_PA25_SPI1_NPCS2	(1 << 25)	/* B: SPI1 Peripheral Chip Select 2 */
-#define AT91_PA26_TPK10		(1 << 26)	/* A: Trace Packet Port 10 */
-#define AT91_PA26_SPI1_NPCS3	(1 << 26)	/* B: SPI1 Peripheral Chip Select 3 */
-#define AT91_PA27_TPK11		(1 << 27)	/* A: Trace Packet Port 11 */
-#define AT91_PA27_SPI0_NPCS1	(1 << 27)	/* B: SPI0 Peripheral Chip Select 1 */
-#define AT91_PA28_TPK12		(1 << 28)	/* A: Trace Packet Port 12 */
-#define AT91_PA28_SPI0_NPCS2	(1 << 28)	/* B: SPI0 Peripheral Chip Select 2 */
-#define AT91_PA29_TPK13		(1 << 29)	/* A: Trace Packet Port 13 */
-#define AT91_PA29_SPI0_NPCS3	(1 << 29)	/* B: SPI0 Peripheral Chip Select 3 */
-#define AT91_PA30_TPK14		(1 << 30)	/* A: Trace Packet Port 14 */
-#define AT91_PA30_A23		(1 << 30)	/* B: Address Bus bit 23 */
-#define AT91_PA31_TPK15		(1 << 31)	/* A: Trace Packet Port 15 */
-#define AT91_PA31_A24		(1 << 31)	/* B: Address Bus bit 24 */
-
-#define AT91_PB0_LCDVSYNC	(1 <<  0)	/* A: LCD Vertical Synchronization */
-#define AT91_PB1_LCDHSYNC	(1 <<  1)	/* A: LCD Horizontal Synchronization */
-#define AT91_PB2_LCDDOTCK	(1 <<  2)	/* A: LCD Dot Clock */
-#define AT91_PB2_PCK0		(1 <<  2)	/* B: PMC Programmable clock Output 0 */
-#define AT91_PB3_LCDDEN		(1 <<  3)	/* A: LCD Data Enable */
-#define AT91_PB4_LCDCC		(1 <<  4)	/* A: LCD Contrast Control */
-#define AT91_PB4_LCDD2		(1 <<  4)	/* B: LCD Data Bus Bit 2 */
-#define AT91_PB5_LCDD0		(1 <<  5)	/* A: LCD Data Bus Bit 0 */
-#define AT91_PB5_LCDD3		(1 <<  5)	/* B: LCD Data Bus Bit 3 */
-#define AT91_PB6_LCDD1		(1 <<  6)	/* A: LCD Data Bus Bit 1 */
-#define AT91_PB6_LCDD4		(1 <<  6)	/* B: LCD Data Bus Bit 4 */
-#define AT91_PB7_LCDD2		(1 <<  7)	/* A: LCD Data Bus Bit 2 */
-#define AT91_PB7_LCDD5		(1 <<  7)	/* B: LCD Data Bus Bit 5 */
-#define AT91_PB8_LCDD3		(1 <<  8)	/* A: LCD Data Bus Bit 3 */
-#define AT91_PB8_LCDD6		(1 <<  8)	/* B: LCD Data Bus Bit 6 */
-#define AT91_PB9_LCDD4		(1 <<  9)	/* A: LCD Data Bus Bit 4 */
-#define AT91_PB9_LCDD7		(1 <<  9)	/* B: LCD Data Bus Bit 7 */
-#define AT91_PB10_LCDD5		(1 << 10)	/* A: LCD Data Bus Bit 5 */
-#define AT91_PB10_LCDD10	(1 << 10)	/* B: LCD Data Bus Bit 10 */
-#define AT91_PB11_LCDD6		(1 << 11)	/* A: LCD Data Bus Bit 6 */
-#define AT91_PB11_LCDD11	(1 << 11)	/* B: LCD Data Bus Bit 11 */
-#define AT91_PB12_LCDD7		(1 << 12)	/* A: LCD Data Bus Bit 7 */
-#define AT91_PB12_LCDD12	(1 << 12)	/* B: LCD Data Bus Bit 12 */
-#define AT91_PB13_LCDD8		(1 << 13)	/* A: LCD Data Bus Bit 8 */
-#define AT91_PB13_LCDD13	(1 << 13)	/* B: LCD Data Bus Bit 13 */
-#define AT91_PB14_LCDD9		(1 << 14)	/* A: LCD Data Bus Bit 9 */
-#define AT91_PB14_LCDD14	(1 << 14)	/* B: LCD Data Bus Bit 14 */
-#define AT91_PB15_LCDD10	(1 << 15)	/* A: LCD Data Bus Bit 10 */
-#define AT91_PB15_LCDD15	(1 << 15)	/* B: LCD Data Bus Bit 15 */
-#define AT91_PB16_LCDD11	(1 << 16)	/* A: LCD Data Bus Bit 11 */
-#define AT91_PB16_LCDD19	(1 << 16)	/* B: LCD Data Bus Bit 19 */
-#define AT91_PB17_LCDD12	(1 << 17)	/* A: LCD Data Bus Bit 12 */
-#define AT91_PB17_LCDD20	(1 << 17)	/* B: LCD Data Bus Bit 20 */
-#define AT91_PB18_LCDD13	(1 << 18)	/* A: LCD Data Bus Bit 13 */
-#define AT91_PB18_LCDD21	(1 << 18)	/* B: LCD Data Bus Bit 21 */
-#define AT91_PB19_LCDD14	(1 << 19)	/* A: LCD Data Bus Bit 14 */
-#define AT91_PB19_LCDD22	(1 << 19)	/* B: LCD Data Bus Bit 22 */
-#define AT91_PB20_LCDD15	(1 << 20)	/* A: LCD Data Bus Bit 15 */
-#define AT91_PB20_LCDD23	(1 << 20)	/* B: LCD Data Bus Bit 23 */
-#define AT91_PB21_TF0		(1 << 21)	/* A: SSC0 Transmit Frame Sync */
-#define AT91_PB21_LCDD16	(1 << 21)	/* B: LCD Data Bus Bit 16 */
-#define AT91_PB22_TK0		(1 << 22)	/* A: SSC0 Transmit Clock */
-#define AT91_PB22_LCDD17	(1 << 22)	/* B: LCD Data Bus Bit 17 */
-#define AT91_PB23_TD0		(1 << 23)	/* A: SSC0 Transmit Data */
-#define AT91_PB23_LCDD18	(1 << 23)	/* B: LCD Data Bus Bit 18 */
-#define AT91_PB24_RD0		(1 << 24)	/* A: SSC0 Receive Data */
-#define AT91_PB24_LCDD19	(1 << 24)	/* B: LCD Data Bus Bit 19 */
-#define AT91_PB25_RK0		(1 << 25)	/* A: SSC0 Receive Clock */
-#define AT91_PB25_LCDD20	(1 << 25)	/* B: LCD Data Bus Bit 20 */
-#define AT91_PB26_RF0		(1 << 26)	/* A: SSC0 Receive Frame Sync */
-#define AT91_PB26_LCDD21	(1 << 26)	/* B: LCD Data Bus Bit 21 */
-#define AT91_PB27_SPI1_NPCS1	(1 << 27)	/* A: SPI1 Peripheral Chip Select 1 */
-#define AT91_PB27_LCDD22	(1 << 27)	/* B: LCD Data Bus Bit 22 */
-#define AT91_PB28_SPI1_NPCS0	(1 << 28)	/* A: SPI1 Peripheral Chip Select 0 */
-#define AT91_PB28_LCDD23	(1 << 28)	/* B: LCD Data Bus Bit 23 */
-#define AT91_PB29_SPI1_SPCK	(1 << 29)	/* A: SPI1 Serial Clock */
-#define AT91_PB29_IRQ2		(1 << 29)	/* B: Interrupt input 2 */
-#define AT91_PB30_SPI1_MISO	(1 << 30)	/* A: SPI1 Master In Slave */
-#define AT91_PB30_IRQ1		(1 << 30)	/* B: Interrupt input 1 */
-#define AT91_PB31_SPI1_MOSI	(1 << 31)	/* A: SPI1 Master Out Slave */
-#define AT91_PB31_PCK2		(1 << 31)	/* B: PMC Programmable clock Output 2 */
-
-#define AT91_PC0_SMOE		(1 << 0)	/* A: SmartMedia Output Enable */
-#define AT91_PC0_NCS6		(1 << 0)	/* B: Chip Select 6 */
-#define AT91_PC1_SMWE		(1 << 1)	/* A: SmartMedia Write Enable */
-#define AT91_PC1_NCS7		(1 << 1)	/* B: Chip Select 7 */
-#define AT91_PC2_NWAIT		(1 << 2)	/* A: NWAIT */
-#define AT91_PC2_IRQ0		(1 << 2)	/* B: Interrupt input 0 */
-#define AT91_PC3_A25_CFRNW	(1 << 3)	/* A: Address Bus[25] / Compact Flash Read Not Write */
-#define AT91_PC4_NCS4_CFCS0	(1 << 4)	/* A: Chip Select 4 / CompactFlash Chip Select 0 */
-#define AT91_PC5_NCS5_CFCS1	(1 << 5)	/* A: Chip Select 5 / CompactFlash Chip Select 1 */
-#define AT91_PC6_CFCE1		(1 << 6)	/* A: CompactFlash Chip Enable 1 */
-#define AT91_PC7_CFCE2		(1 << 7)	/* A: CompactFlash Chip Enable 2 */
-#define AT91_PC8_TXD0		(1 << 8)	/* A: USART0 Transmit Data */
-#define AT91_PC8_PCK2		(1 << 8)	/* B: PMC Programmable clock Output 2 */
-#define AT91_PC9_RXD0		(1 << 9)	/* A: USART0 Receive Data */
-#define AT91_PC9_PCK3		(1 << 9)	/* B: PMC Programmable clock Output 3 */
-#define AT91_PC10_RTS0		(1 << 10)	/* A: USART0 Ready To Send */
-#define AT91_PC10_SCK0		(1 << 10)	/* B: USART0 Serial Clock */
-#define AT91_PC11_CTS0		(1 << 11)	/* A: USART0 Clear To Send */
-#define AT91_PC11_FIQ		(1 << 11)	/* B: AIC Fast Interrupt Input */
-#define AT91_PC12_TXD1		(1 << 12)	/* A: USART1 Transmit Data */
-#define AT91_PC12_NCS6		(1 << 12)	/* B: Chip Select 6 */
-#define AT91_PC13_RXD1		(1 << 13)	/* A: USART1 Receive Data */
-#define AT91_PC13_NCS7		(1 << 13)	/* B: Chip Select 7 */
-#define AT91_PC14_TXD2		(1 << 14)	/* A: USART2 Transmit Data */
-#define AT91_PC14_SPI1_NPCS2	(1 << 14)	/* B: SPI1 Peripheral Chip Select 2 */
-#define AT91_PC15_RXD2		(1 << 15)	/* A: USART2 Receive Data */
-#define AT91_PC15_SPI1_NPCS3	(1 << 15)	/* B: SPI1 Peripheral Chip Select 3 */
-#define AT91_PC16_D16		(1 << 16)	/* A: Data Bus [16] */
-#define AT91_PC16_TCLK0		(1 << 16)	/* B: Timer Counter 0 external clock input */
-#define AT91_PC17_D17		(1 << 17)	/* A: Data Bus [17] */
-#define AT91_PC17_TCLK1		(1 << 17)	/* B: Timer Counter 1 external clock input */
-#define AT91_PC18_D18		(1 << 18)	/* A: Data Bus [18] */
-#define AT91_PC18_TCLK2		(1 << 18)	/* B: Timer Counter 2 external clock input */
-#define AT91_PC19_D19		(1 << 19)	/* A: Data Bus [19] */
-#define AT91_PC19_TIOA0		(1 << 19)	/* B: Timer Counter 0 Multipurpose Timer I/O Pin A */
-#define AT91_PC20_D20		(1 << 20)	/* A: Data Bus [20] */
-#define AT91_PC20_TIOB0		(1 << 20)	/* B: Timer Counter 0 Multipurpose Timer I/O Pin B */
-#define AT91_PC21_D21		(1 << 21)	/* A: Data Bus [21] */
-#define AT91_PC21_TIOA1		(1 << 21)	/* B: Timer Counter 1 Multipurpose Timer I/O Pin A */
-#define AT91_PC22_D22		(1 << 22)	/* A: Data Bus [22] */
-#define AT91_PC22_TIOB1		(1 << 22)	/* B: Timer Counter 1 Multipurpose Timer I/O Pin B */
-#define AT91_PC23_D23		(1 << 23)	/* A: Data Bus [23] */
-#define AT91_PC23_TIOA2		(1 << 23)	/* B: Timer Counter 2 Multipurpose Timer I/O Pin A */
-#define AT91_PC24_D24		(1 << 24)	/* A: Data Bus [24] */
-#define AT91_PC24_TIOB2		(1 << 24)	/* B: Timer Counter 2 Multipurpose Timer I/O Pin B */
-#define AT91_PC25_D25		(1 << 25)	/* A: Data Bus [25] */
-#define AT91_PC25_TF2		(1 << 25)	/* B: SSC2 Transmit Frame Sync */
-#define AT91_PC26_D26		(1 << 26)	/* A: Data Bus [26] */
-#define AT91_PC26_TK2		(1 << 26)	/* B: SSC2 Transmit Clock */
-#define AT91_PC27_D27		(1 << 27)	/* A: Data Bus [27] */
-#define AT91_PC27_TD2		(1 << 27)	/* B: SSC2 Transmit Data */
-#define AT91_PC28_D28		(1 << 28)	/* A: Data Bus [28] */
-#define AT91_PC28_RD2		(1 << 28)	/* B: SSC2 Receive Data */
-#define AT91_PC29_D29		(1 << 29)	/* A: Data Bus [29] */
-#define AT91_PC29_RK2		(1 << 29)	/* B: SSC2 Receive Clock */
-#define AT91_PC30_D30		(1 << 30)	/* A: Data Bus [30] */
-#define AT91_PC30_RF2		(1 << 30)	/* B: SSC2 Receive Frame Sync */
-#define AT91_PC31_D31		(1 << 31)	/* A: Data Bus [31] */
-#define AT91_PC31_PCK1		(1 << 31)	/* B: PMC Programmable clock Output 1 */
-#endif
-
 #endif
Index: linux-2.6.21.7/include/asm-arm/arch-at91/at91sam9263.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/at91sam9263.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/at91sam9263.h
@@ -119,13 +119,5 @@
 #define AT91SAM9263_DMAC_BASE	0x00800000	/* DMA Controller */
 #define AT91SAM9263_UHP_BASE	0x00a00000	/* USB Host controller */
 
-#if 0
-/*
- * PIO pin definitions (peripheral A/B multiplexing).
- */
-
-// TODO: Add
-
-#endif
 
 #endif
Index: linux-2.6.21.7/include/asm-arm/arch-at91/at91sam9rl.h
===================================================================
--- /dev/null
+++ linux-2.6.21.7/include/asm-arm/arch-at91/at91sam9rl.h
@@ -0,0 +1,110 @@
+/*
+ * include/asm-arm/arch-at91/at91sam9260.h
+ *
+ *  Copyright (C) 2007 Atmel Corporation
+ *
+ * Common definitions.
+ * Based on AT91SAM9RL datasheet revision A. (Preliminary)
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef AT91SAM9RL_H
+#define AT91SAM9RL_H
+
+/*
+ * Peripheral identifiers/interrupts.
+ */
+#define AT91_ID_FIQ		0	/* Advanced Interrupt Controller (FIQ) */
+#define AT91_ID_SYS		1	/* System Controller */
+#define AT91SAM9RL_ID_PIOA	2	/* Parallel IO Controller A */
+#define AT91SAM9RL_ID_PIOB	3	/* Parallel IO Controller B */
+#define AT91SAM9RL_ID_PIOC	4	/* Parallel IO Controller C */
+#define AT91SAM9RL_ID_PIOD	5	/* Parallel IO Controller D */
+#define AT91SAM9RL_ID_US0	6	/* USART 0 */
+#define AT91SAM9RL_ID_US1	7	/* USART 1 */
+#define AT91SAM9RL_ID_US2	8	/* USART 2 */
+#define AT91SAM9RL_ID_US3	9	/* USART 3 */
+#define AT91SAM9RL_ID_MCI	10	/* Multimedia Card Interface */
+#define AT91SAM9RL_ID_TWI0	11	/* TWI 0 */
+#define AT91SAM9RL_ID_TWI1	12	/* TWI 1 */
+#define AT91SAM9RL_ID_SPI	13	/* Serial Peripheral Interface */
+#define AT91SAM9RL_ID_SSC0	14	/* Serial Synchronous Controller 0 */
+#define AT91SAM9RL_ID_SSC1	15	/* Serial Synchronous Controller 1 */
+#define AT91SAM9RL_ID_TC0	16	/* Timer Counter 0 */
+#define AT91SAM9RL_ID_TC1	17	/* Timer Counter 1 */
+#define AT91SAM9RL_ID_TC2	18	/* Timer Counter 2 */
+#define AT91SAM9RL_ID_PWMC	19	/* Pulse Width Modulation Controller */
+#define AT91SAM9RL_ID_TSC	20	/* Touch Screen Controller */
+#define AT91SAM9RL_ID_DMA	21	/* DMA Controller */
+#define AT91SAM9RL_ID_UDPHS	22	/* USB Device HS */
+#define AT91SAM9RL_ID_LCDC	23	/* LCD Controller */
+#define AT91SAM9RL_ID_AC97C	24	/* AC97 Controller */
+#define AT91SAM9RL_ID_IRQ0	31	/* Advanced Interrupt Controller (IRQ0) */
+
+
+/*
+ * User Peripheral physical base addresses.
+ */
+#define AT91SAM9RL_BASE_TCB0	0xfffa0000
+#define AT91SAM9RL_BASE_TC0	0xfffa0000
+#define AT91SAM9RL_BASE_TC1	0xfffa0040
+#define AT91SAM9RL_BASE_TC2	0xfffa0080
+#define AT91SAM9RL_BASE_MCI	0xfffa4000
+#define AT91SAM9RL_BASE_TWI0	0xfffa8000
+#define AT91SAM9RL_BASE_TWI1	0xfffac000
+#define AT91SAM9RL_BASE_US0	0xfffb0000
+#define AT91SAM9RL_BASE_US1	0xfffb4000
+#define AT91SAM9RL_BASE_US2	0xfffb8000
+#define AT91SAM9RL_BASE_US3	0xfffbc000
+#define AT91SAM9RL_BASE_SSC0	0xfffc0000
+#define AT91SAM9RL_BASE_SSC1	0xfffc4000
+#define AT91SAM9RL_BASE_PWMC	0xfffc8000
+#define AT91SAM9RL_BASE_SPI	0xfffcc000
+#define AT91SAM9RL_BASE_TSC	0xfffd0000
+#define AT91SAM9RL_BASE_UDPHS	0xfffd4000
+#define AT91SAM9RL_BASE_AC97C	0xfffd8000
+#define AT91_BASE_SYS		0xffffc000
+
+
+/*
+ * System Peripherals (offset from AT91_BASE_SYS)
+ */
+#define AT91_DMA	(0xffffe600 - AT91_BASE_SYS)
+#define AT91_ECC	(0xffffe800 - AT91_BASE_SYS)
+#define AT91_SDRAMC	(0xffffea00 - AT91_BASE_SYS)
+#define AT91_SMC	(0xffffec00 - AT91_BASE_SYS)
+#define AT91_MATRIX	(0xffffee00 - AT91_BASE_SYS)
+#define AT91_CCFG	(0xffffef10 - AT91_BASE_SYS)
+#define AT91_AIC	(0xfffff000 - AT91_BASE_SYS)
+#define AT91_DBGU	(0xfffff200 - AT91_BASE_SYS)
+#define AT91_PIOA	(0xfffff400 - AT91_BASE_SYS)
+#define AT91_PIOB	(0xfffff600 - AT91_BASE_SYS)
+#define AT91_PIOC	(0xfffff800 - AT91_BASE_SYS)
+#define AT91_PIOD	(0xfffffa00 - AT91_BASE_SYS)
+#define AT91_PMC	(0xfffffc00 - AT91_BASE_SYS)
+#define AT91_RSTC	(0xfffffd00 - AT91_BASE_SYS)
+#define AT91_SHDWC	(0xfffffd10 - AT91_BASE_SYS)
+#define AT91_RTT	(0xfffffd20 - AT91_BASE_SYS)
+#define AT91_PIT	(0xfffffd30 - AT91_BASE_SYS)
+#define AT91_WDT	(0xfffffd40 - AT91_BASE_SYS)
+#define AT91_SCKCR	(0xfffffd50 - AT91_BASE_SYS)
+#define AT91_GPBR	(0xfffffd60 - AT91_BASE_SYS)
+#define AT91_RTC	(0xfffffe00 - AT91_BASE_SYS)
+
+
+/*
+ * Internal Memory.
+ */
+#define AT91SAM9RL_SRAM_BASE	0x00300000	/* Internal SRAM base address */
+#define AT91SAM9RL_SRAM_SIZE	SZ_16K		/* Internal SRAM size (16Kb) */
+
+#define AT91SAM9RL_ROM_BASE	0x00400000	/* Internal ROM base address */
+#define AT91SAM9RL_ROM_SIZE	(2 * SZ_16K)	/* Internal ROM size (32Kb) */
+
+#define AT91SAM9RL_LCDC_BASE	0x00500000	/* LCD Controller */
+#define AT91SAM9RL_UDPHS_BASE	0x00600000	/* USB Device HS controller */
+
+#endif
Index: linux-2.6.21.7/include/asm-arm/arch-at91/at91sam9rl_matrix.h
===================================================================
--- /dev/null
+++ linux-2.6.21.7/include/asm-arm/arch-at91/at91sam9rl_matrix.h
@@ -0,0 +1,96 @@
+/*
+ * include/asm-arm/arch-at91/at91sam9rl_matrix.h
+ *
+ *  Copyright (C) 2007 Atmel Corporation
+ *
+ * Memory Controllers (MATRIX, EBI) - System peripherals registers.
+ * Based on AT91SAM9RL datasheet revision A. (Preliminary)
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef AT91SAM9RL_MATRIX_H
+#define AT91SAM9RL_MATRIX_H
+
+#define AT91_MATRIX_MCFG0	(AT91_MATRIX + 0x00)	/* Master Configuration Register 0 */
+#define AT91_MATRIX_MCFG1	(AT91_MATRIX + 0x04)	/* Master Configuration Register 1 */
+#define AT91_MATRIX_MCFG2	(AT91_MATRIX + 0x08)	/* Master Configuration Register 2 */
+#define AT91_MATRIX_MCFG3	(AT91_MATRIX + 0x0C)	/* Master Configuration Register 3 */
+#define AT91_MATRIX_MCFG4	(AT91_MATRIX + 0x10)	/* Master Configuration Register 4 */
+#define AT91_MATRIX_MCFG5	(AT91_MATRIX + 0x14)	/* Master Configuration Register 5 */
+#define		AT91_MATRIX_ULBT	(7 << 0)	/* Undefined Length Burst Type */
+#define			AT91_MATRIX_ULBT_INFINITE	(0 << 0)
+#define			AT91_MATRIX_ULBT_SINGLE		(1 << 0)
+#define			AT91_MATRIX_ULBT_FOUR		(2 << 0)
+#define			AT91_MATRIX_ULBT_EIGHT		(3 << 0)
+#define			AT91_MATRIX_ULBT_SIXTEEN	(4 << 0)
+
+#define AT91_MATRIX_SCFG0	(AT91_MATRIX + 0x40)	/* Slave Configuration Register 0 */
+#define AT91_MATRIX_SCFG1	(AT91_MATRIX + 0x44)	/* Slave Configuration Register 1 */
+#define AT91_MATRIX_SCFG2	(AT91_MATRIX + 0x48)	/* Slave Configuration Register 2 */
+#define AT91_MATRIX_SCFG3	(AT91_MATRIX + 0x4C)	/* Slave Configuration Register 3 */
+#define AT91_MATRIX_SCFG4	(AT91_MATRIX + 0x50)	/* Slave Configuration Register 4 */
+#define AT91_MATRIX_SCFG5	(AT91_MATRIX + 0x54)	/* Slave Configuration Register 5 */
+#define		AT91_MATRIX_SLOT_CYCLE		(0xff << 0)	/* Maximum Number of Allowed Cycles for a Burst */
+#define		AT91_MATRIX_DEFMSTR_TYPE	(3    << 16)	/* Default Master Type */
+#define			AT91_MATRIX_DEFMSTR_TYPE_NONE	(0 << 16)
+#define			AT91_MATRIX_DEFMSTR_TYPE_LAST	(1 << 16)
+#define			AT91_MATRIX_DEFMSTR_TYPE_FIXED	(2 << 16)
+#define		AT91_MATRIX_FIXED_DEFMSTR	(7    << 18)	/* Fixed Index of Default Master */
+#define		AT91_MATRIX_ARBT		(3    << 24)	/* Arbitration Type */
+#define			AT91_MATRIX_ARBT_ROUND_ROBIN	(0 << 24)
+#define			AT91_MATRIX_ARBT_FIXED_PRIORITY	(1 << 24)
+
+#define AT91_MATRIX_PRAS0	(AT91_MATRIX + 0x80)	/* Priority Register A for Slave 0 */
+#define AT91_MATRIX_PRAS1	(AT91_MATRIX + 0x88)	/* Priority Register A for Slave 1 */
+#define AT91_MATRIX_PRAS2	(AT91_MATRIX + 0x90)	/* Priority Register A for Slave 2 */
+#define AT91_MATRIX_PRAS3	(AT91_MATRIX + 0x98)	/* Priority Register A for Slave 3 */
+#define AT91_MATRIX_PRAS4	(AT91_MATRIX + 0xA0)	/* Priority Register A for Slave 4 */
+#define AT91_MATRIX_PRAS5	(AT91_MATRIX + 0xA8)	/* Priority Register A for Slave 5 */
+#define		AT91_MATRIX_M0PR		(3 << 0)	/* Master 0 Priority */
+#define		AT91_MATRIX_M1PR		(3 << 4)	/* Master 1 Priority */
+#define		AT91_MATRIX_M2PR		(3 << 8)	/* Master 2 Priority */
+#define		AT91_MATRIX_M3PR		(3 << 12)	/* Master 3 Priority */
+#define		AT91_MATRIX_M4PR		(3 << 16)	/* Master 4 Priority */
+#define		AT91_MATRIX_M5PR		(3 << 20)	/* Master 5 Priority */
+
+#define AT91_MATRIX_MRCR	(AT91_MATRIX + 0x100)	/* Master Remap Control Register */
+#define		AT91_MATRIX_RCB0		(1 << 0)	/* Remap Command for AHB Master 0 (ARM926EJ-S Instruction Master) */
+#define		AT91_MATRIX_RCB1		(1 << 1)	/* Remap Command for AHB Master 1 (ARM926EJ-S Data Master) */
+#define		AT91_MATRIX_RCB2		(1 << 2)
+#define		AT91_MATRIX_RCB3		(1 << 3)
+#define		AT91_MATRIX_RCB4		(1 << 4)
+#define		AT91_MATRIX_RCB5		(1 << 5)
+
+#define AT91_MATRIX_TCMR	(AT91_MATRIX + 0x114)	/* TCM Configuration Register */
+#define		AT91_MATRIX_ITCM_SIZE		(0xf << 0)	/* Size of ITCM enabled memory block */
+#define			AT91_MATRIX_ITCM_0		(0 << 0)
+#define			AT91_MATRIX_ITCM_16		(5 << 0)
+#define			AT91_MATRIX_ITCM_32		(6 << 0)
+#define		AT91_MATRIX_DTCM_SIZE		(0xf << 4)	/* Size of DTCM enabled memory block */
+#define			AT91_MATRIX_DTCM_0		(0 << 4)
+#define			AT91_MATRIX_DTCM_16		(5 << 4)
+#define			AT91_MATRIX_DTCM_32		(6 << 4)
+
+#define AT91_MATRIX_EBICSA	(AT91_MATRIX + 0x120)	/* EBI0 Chip Select Assignment Register */
+#define		AT91_MATRIX_CS1A		(1 << 1)	/* Chip Select 1 Assignment */
+#define			AT91_MATRIX_CS1A_SMC		(0 << 1)
+#define			AT91_MATRIX_CS1A_SDRAMC		(1 << 1)
+#define		AT91_MATRIX_CS3A		(1 << 3)	/* Chip Select 3 Assignment */
+#define			AT91_MATRIX_CS3A_SMC		(0 << 3)
+#define			AT91_MATRIX_CS3A_SMC_SMARTMEDIA	(1 << 3)
+#define		AT91_MATRIX_CS4A		(1 << 4)	/* Chip Select 4 Assignment */
+#define			AT91_MATRIX_CS4A_SMC		(0 << 4)
+#define			AT91_MATRIX_CS4A_SMC_CF1	(1 << 4)
+#define		AT91_MATRIX_CS5A		(1 << 5)	/* Chip Select 5 Assignment */
+#define			AT91_MATRIX_CS5A_SMC		(0 << 5)
+#define			AT91_MATRIX_CS5A_SMC_CF2	(1 << 5)
+#define		AT91_MATRIX_DBPUC		(1 << 8)	/* Data Bus Pull-up Configuration */
+#define		AT91_MATRIX_VDDIOMSEL		(1 << 16)	/* Memory voltage selection */
+#define			AT91_MATRIX_VDDIOMSEL_1_8V	(0 << 16)
+#define			AT91_MATRIX_VDDIOMSEL_3_3V	(1 << 16)
+
+
+#endif
Index: linux-2.6.21.7/include/asm-arm/arch-at91/board.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/board.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/board.h
@@ -62,7 +62,7 @@ struct at91_mmc_data {
 };
 extern void __init at91_add_device_mmc(short mmc_id, struct at91_mmc_data *data);
 
- /* Ethernet */
+ /* Ethernet (EMAC & MACB) */
 struct at91_eth_data {
 	u8		phy_irq_pin;	/* PHY IRQ */
 	u8		is_rmii;	/* using RMII interface? */
@@ -114,9 +114,31 @@ struct atmel_uart_data {
 };
 extern void __init at91_add_device_serial(void);
 
+ /* LCD Controller */
+struct atmel_lcdfb_info;
+extern void __init at91_add_device_lcdc(struct atmel_lcdfb_info *data);
+
+ /* AC97 */
+struct atmel_ac97_data {
+	u8		reset_pin;	/* reset */
+};
+extern void __init at91_add_device_ac97(struct atmel_ac97_data *data);
+
+ /* ISI */
+extern void __init at91_add_device_isi(void);
+
  /* LEDs */
 extern u8 at91_leds_cpu;
 extern u8 at91_leds_timer;
 extern void __init at91_init_leds(u8 cpu_led, u8 timer_led);
 
+struct at91_gpio_led {
+	u8		index;		/* index of LED */
+	char*		name;		/* name of LED */
+	u8		gpio;		/* AT91_PIN_xx */
+	u8		flags;		/* 1=active-high */
+	char*		trigger;	/* default trigger */
+};
+extern void __init at91_gpio_leds(struct at91_gpio_led *leds, int nr);
+
 #endif
Index: linux-2.6.21.7/include/asm-arm/arch-at91/cpu.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/cpu.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/cpu.h
@@ -26,6 +26,8 @@
 #define ARCH_ID_AT91SAM9XE256	0x329a93a0
 #define ARCH_ID_AT91SAM9XE512	0x329aa3a0
 
+#define ARCH_ID_AT91SAM9RL64	0x019b03a0
+
 static inline unsigned long at91_cpu_identify(void)
 {
 	return (at91_sys_read(AT91_DBGU_CIDR) & ~AT91_CIDR_VERSION);
@@ -68,4 +70,10 @@ static inline unsigned long at91_arch_id
 #define cpu_is_at91sam9263()	(0)
 #endif
 
+#ifdef CONFIG_ARCH_AT91SAM9RL
+#define cpu_is_at91sam9rl()	(at91_cpu_identify() == ARCH_ID_AT91SAM9RL64)
+#else
+#define cpu_is_at91sam9rl()	(0)
+#endif
+
 #endif
Index: linux-2.6.21.7/include/asm-arm/arch-at91/hardware.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/hardware.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/hardware.h
@@ -24,6 +24,8 @@
 #include <asm/arch/at91sam9261.h>
 #elif defined(CONFIG_ARCH_AT91SAM9263)
 #include <asm/arch/at91sam9263.h>
+#elif defined(CONFIG_ARCH_AT91SAM9RL)
+#include <asm/arch/at91sam9rl.h>
 #else
 #error "Unsupported AT91 processor"
 #endif
@@ -69,22 +71,5 @@
 /* Clocks */
 #define AT91_SLOW_CLOCK		32768		/* slow clock */
 
-#ifndef __ASSEMBLY__
-#include <asm/io.h>
-
-static inline unsigned int at91_sys_read(unsigned int reg_offset)
-{
-	void __iomem *addr = (void __iomem *)AT91_VA_BASE_SYS;
-
-	return __raw_readl(addr + reg_offset);
-}
-
-static inline void at91_sys_write(unsigned int reg_offset, unsigned long value)
-{
-	void __iomem *addr = (void __iomem *)AT91_VA_BASE_SYS;
-
-	__raw_writel(value, addr + reg_offset);
-}
-#endif
 
 #endif
Index: linux-2.6.21.7/include/asm-arm/arch-at91/ics1523.h
===================================================================
--- /dev/null
+++ linux-2.6.21.7/include/asm-arm/arch-at91/ics1523.h
@@ -0,0 +1,154 @@
+//*----------------------------------------------------------------------------
+//*         ATMEL Microcontroller Software Support  -  ROUSSET  -
+//*----------------------------------------------------------------------------
+//* The software is delivered "AS IS" without warranty or condition of any
+//* kind, either express, implied or statutory. This includes without
+//* limitation any warranty or condition with respect to merchantability or
+//* fitness for any particular purpose, or against the infringements of
+//* intellectual property rights of others.
+//*----------------------------------------------------------------------------
+//* File Name           : ics1523.h
+//* Object              : Clock Generator Prototyping File.
+//*
+//* 1.0 08/28/02 ED     : Creation
+//* 1.2 13/01/03 FB		: Update on lib V3
+//*----------------------------------------------------------------------------
+
+#ifndef ics1523_h
+#define ics1523_h
+
+/*-------------------------------------------*/
+/* ICS1523 TWI Serial Clock Definition       */
+/*-------------------------------------------*/
+
+#define		ICS_MIN_CLOCK		100		/* Min Frequency Access Clock KHz */
+#define		ICS_MAX_CLOCK		400		/* Max Frequency Access Clock KHz */
+#define		ICS_TRANSFER_RATE	ICS_MAX_CLOCK	/* Transfer speed to apply */
+
+#define		ICS_WRITE_CLK_PNB	30		/* TWCK Clock Periods required to write */
+#define		ICS_READ_CLK_PNB	40		/* TWCK Clock Periods required to read */
+
+/*-------------------------------------------*/
+/* ICS1523 Write Operation Definition        */
+/*-------------------------------------------*/
+
+#define		ICS1523_ACCESS_OK	0		/* OK */
+#define		ICS1523_ACCESS_ERROR	-1		/* NOK */
+
+/*-------------------------------------------*/
+/* ICS1523 Device Addresses Definition       */
+/*-------------------------------------------*/
+
+#define		ICS_ADDR		0x26		/* Device Address */
+
+/*--------------------------------------------------*/
+/* ICS1523 Registers Internal Addresses Definition  */
+/*--------------------------------------------------*/
+
+#define		ICS_ICR			0x0		/* Input Control Register */
+#define		ICS_LCR			0x1		/* Loop Control Register */
+#define		ICS_FD0			0x2		/* PLL FeedBack Divider LSBs */
+#define		ICS_FD1			0x3		/* PLL FeedBack Divider MSBs */
+#define		ICS_DPAO		0x4		/* Dynamic Phase Aligner Offset */
+#define		ICS_DPAC		0x5		/* Dynamic Phase Aligner Resolution */
+#define		ICS_OE			0x6		/* Output Enables Register */
+#define		ICS_OD			0x7		/* Osc Divider Register */
+#define		ICS_SWRST		0x8		/* DPA & PLL Reset Register */
+#define		ICS_VID			0x10		/* Chip Version Register */
+#define		ICS_RID			0x11		/* Chip Revision Register */
+#define		ICS_SR			0x12		/* Status Register */
+
+/*------------------------------------------------------*/
+/* ICS1523 Input Control Register Bits Definition       */
+/*------------------------------------------------------*/
+
+#define		ICS_PDEN		0x1		/* Phase Detector Enable */
+#define		ICS_PDPOL		0x2		/* Phase Detector Enable Polarity */
+#define		ICS_REFPOL		0x4		/* External Reference Polarity */
+#define		ICS_FBKPOL		0x8		/* External Feedback Polarity */
+#define		ICS_FBKSEL		0x10		/* External Feedback Select */
+#define		ICS_FUNCSEL		0x20		/* Function Out Select */
+#define		ICS_ENPLS		0x40		/* Enable PLL Lock/Ref Status Output */
+#define		ICS_ENDLS		0x80		/* Enable DPA Lock/Ref Status Output */
+
+/*-----------------------------------------------------*/
+/* ICS1523 Loop Control Register Bits Definition       */
+/*-----------------------------------------------------*/
+
+#define		ICS_PFD			0x7		/* Phase Detector Gain */
+#define		ICS_PSD			0x30		/* Post-Scaler Divider */
+
+/*----------------------------------------------------*/
+/* ICS1523 PLL FeedBack Divider LSBs Definition       */
+/*----------------------------------------------------*/
+
+#define		ICS_FBDL		0xFF		/* PLL FeedBack Divider LSBs */
+
+/*----------------------------------------------------*/
+/* ICS1523 PLL FeedBack Divider MSBs Definition       */
+/*----------------------------------------------------*/
+
+#define		ICS_FBDM		0xF		/* PLL FeedBack Divider MSBs */
+
+/*------------------------------------------------------------*/
+/* ICS1523 Dynamic Phase Aligner Offset Bits Definition       */
+/*------------------------------------------------------------*/
+
+#define		ICS_DPAOS		0x2F		/* Dynamic Phase Aligner Offset */
+#define		ICS_FILSEL		0x80		/* Loop Filter Select */
+
+/*----------------------------------------------------------------*/
+/* ICS1523 Dynamic Phase Aligner Resolution Bits Definition       */
+/*----------------------------------------------------------------*/
+
+#define		ICS_DPARES		0x3		/* Dynamic Phase Aligner Resolution */
+#define		ICS_MMREV		0xFC		/* Metal Mask Revision Number */
+
+/*-------------------------------------------------------*/
+/* ICS1523 Output Enables Register Bits Definition       */
+/*-------------------------------------------------------*/
+
+#define		ICS_OEPCK		0x1		/* Output Enable for PECL PCLK Outputs */
+#define		ICS_OETCK		0x2		/* Output Enable for STTL CLK Output */
+#define		ICS_OEP2		0x4		/* Output Enable for PECL CLK/2 Outputs */
+#define		ICS_OET2		0x8		/* Output Enable for STTL CLK/2 Output */
+#define		ICS_OEF			0x10		/* Output Enable for STTL FUNC Output */
+#define		ICS_CLK2INV		0x20		/* CLK/2 Invert */
+#define		ICS_OSCL		0xC0		/* SSTL Clock Scaler */
+
+/*----------------------------------------------------*/
+/* ICS1523 Osc Divider Register Bits Definition       */
+/*----------------------------------------------------*/
+
+#define		ICS_OSCDIV		0x7F		/* Oscillator Divider Modulus */
+#define		ICS_INSEL		0x80		/* Input Select */
+
+/*---------------------------------------------------*/
+/* ICS1523 DPA & PLL Reset Register Definition       */
+/*---------------------------------------------------*/
+
+#define		ICS_DPAR		0x0A		/* DPA Reset Command */
+#define		ICS_PLLR		0x50		/* PLL Reset Command */
+
+/*------------------------------------------------*/
+/* ICS1523 Chip Version Register Definition       */
+/*------------------------------------------------*/
+
+#define		ICS_CHIPV		0xFF		/* Chip Version */
+
+/*-------------------------------------------------*/
+/* ICS1523 Chip Revision Register Definition       */
+/*-------------------------------------------------*/
+
+#define		ICS_CHIPR		0xFF		/* Chip Revision */
+
+/*------------------------------------------*/
+/* ICS1523 Status Register Definition       */
+/*------------------------------------------*/
+
+#define		ICS_DPALOCK		0x1		/* DPA Lock Status */
+#define		ICS_PLLLOCK		0x2		/* PLL Lock Status */
+
+int at91_ics1523_init(void);
+
+#endif /* ics1523_h */
Index: linux-2.6.21.7/include/asm-arm/arch-at91/io.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/io.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/io.h
@@ -29,4 +29,22 @@
 #define __mem_pci(a)		(a)
 
 
+#ifndef __ASSEMBLY__
+
+static inline unsigned int at91_sys_read(unsigned int reg_offset)
+{
+	void __iomem *addr = (void __iomem *)AT91_VA_BASE_SYS;
+
+	return __raw_readl(addr + reg_offset);
+}
+
+static inline void at91_sys_write(unsigned int reg_offset, unsigned long value)
+{
+	void __iomem *addr = (void __iomem *)AT91_VA_BASE_SYS;
+
+	__raw_writel(value, addr + reg_offset);
+}
+
+#endif
+
 #endif
Index: linux-2.6.21.7/include/asm-arm/arch-at91/irqs.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/irqs.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/irqs.h
@@ -21,6 +21,7 @@
 #ifndef __ASM_ARCH_IRQS_H
 #define __ASM_ARCH_IRQS_H
 
+#include <asm/io.h>
 #include <asm/arch/at91_aic.h>
 
 #define NR_AIC_IRQS 32
Index: linux-2.6.21.7/include/asm-arm/arch-at91/spi.h
===================================================================
--- /dev/null
+++ linux-2.6.21.7/include/asm-arm/arch-at91/spi.h
@@ -0,0 +1,54 @@
+/*
+ * Serial Peripheral Interface (SPI) driver for the Atmel AT91RM9200
+ *
+ * (c) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef AT91_LEGACY_SPI_H
+#define AT91_LEGACY_SPI_H
+
+#define SPI_MAJOR		153	/* registered device number */
+
+#define DEFAULT_SPI_CLK		6000000
+
+
+/* Maximum number of buffers in a single SPI transfer.
+ *  DataFlash uses maximum of 2
+ *  spidev interface supports up to 8.
+ */
+#define MAX_SPI_TRANSFERS	8
+#define NR_SPI_DEVICES		4	/* number of devices on SPI bus */
+
+/*
+ * Describes the buffers for a SPI transfer.
+ * A transmit & receive buffer must be specified for each transfer
+ */
+struct spi_transfer_list {
+	void* tx[MAX_SPI_TRANSFERS];	/* transmit */
+	int txlen[MAX_SPI_TRANSFERS];
+	void* rx[MAX_SPI_TRANSFERS];	/* receive */
+	int rxlen[MAX_SPI_TRANSFERS];
+	int nr_transfers;		/* number of transfers */
+	int curr;			/* current transfer */
+};
+
+struct spi_local {
+	unsigned int pcs;		/* Peripheral Chip Select value */
+
+	struct spi_transfer_list *xfers;	/* current transfer list */
+	dma_addr_t tx, rx;		/* DMA address for current transfer */
+	dma_addr_t txnext, rxnext;	/* DMA address for next transfer */
+};
+
+
+/* Exported functions */
+extern void spi_access_bus(short device);
+extern void spi_release_bus(short device);
+extern int spi_transfer(struct spi_transfer_list* list);
+
+#endif
Index: linux-2.6.21.7/include/asm-arm/arch-at91/timex.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/timex.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/timex.h
@@ -37,6 +37,11 @@
 #define AT91SAM9_MASTER_CLOCK	99959500
 #define CLOCK_TICK_RATE		(AT91SAM9_MASTER_CLOCK/16)
 
+#elif defined(CONFIG_ARCH_AT91SAM9RL)
+
+#define AT91SAM9_MASTER_CLOCK	100000000
+#define CLOCK_TICK_RATE		(AT91SAM9_MASTER_CLOCK/16)
+
 #endif
 
 #endif
Index: linux-2.6.21.7/include/asm-arm/arch-at91/uncompress.h
===================================================================
--- linux-2.6.21.7.orig/include/asm-arm/arch-at91/uncompress.h
+++ linux-2.6.21.7/include/asm-arm/arch-at91/uncompress.h
@@ -21,7 +21,7 @@
 #ifndef __ASM_ARCH_UNCOMPRESS_H
 #define __ASM_ARCH_UNCOMPRESS_H
 
-#include <asm/hardware.h>
+#include <asm/io.h>
 #include <asm/arch/at91_dbgu.h>
 
 /*
Index: linux-2.6.21.7/include/linux/clk.h
===================================================================
--- linux-2.6.21.7.orig/include/linux/clk.h
+++ linux-2.6.21.7/include/linux/clk.h
@@ -121,4 +121,24 @@ int clk_set_parent(struct clk *clk, stru
  */
 struct clk *clk_get_parent(struct clk *clk);
 
+/**
+ * clk_must_disable - report whether a clock's users must disable it
+ * @clk: one node in the clock tree
+ *
+ * This routine returns true only if the upcoming system state requires
+ * disabling the specified clock.
+ *
+ * It's common for platform power states to constrain certain clocks (and
+ * their descendants) to be unavailable, while other states allow that
+ * clock to be active.  A platform's power states often include an "all on"
+ * mode; system wide sleep states like "standby" or "suspend-to-RAM"; and
+ * operating states which sacrifice functionality for lower power usage.
+ *
+ * The constraint value is commonly tested in device driver suspend(), to
+ * leave clocks active if they are needed for features like wakeup events.
+ * On platforms that support reduced functionality operating states, the
+ * constraint may also need to be tested during resume() and probe() calls.
+ */
+int clk_must_disable(struct clk *clk);
+
 #endif
Index: linux-2.6.21.7/include/linux/i2c-id.h
===================================================================
--- linux-2.6.21.7.orig/include/linux/i2c-id.h
+++ linux-2.6.21.7/include/linux/i2c-id.h
@@ -202,6 +202,7 @@
 
 /* --- PCA 9564 based algorithms */
 #define I2C_HW_A_ISA		0x1a0000 /* generic ISA Bus interface card */
+#define I2C_HW_A_PLAT		0x1a0001 /* generic platform_bus interface */
 
 /* --- ACPI Embedded controller algorithms                              */
 #define I2C_HW_ACPI_EC          0x1f0000
Index: linux-2.6.21.7/include/video/atmel_lcdc.h
===================================================================
--- /dev/null
+++ linux-2.6.21.7/include/video/atmel_lcdc.h
@@ -0,0 +1,196 @@
+/*
+ *  Header file for AT91/AT32 LCD Controller
+ *
+ *  Data structure and register user interface
+ *
+ *  Copyright (C) 2007 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ATMEL_LCDC_H__
+#define __ATMEL_LCDC_H__
+
+ /* LCD Controller info data structure */
+struct atmel_lcdfb_info {
+	spinlock_t		lock;
+	struct fb_info		*info;
+	void __iomem		*mmio;
+	unsigned long		irq_base;
+
+	unsigned int		guard_time;
+	struct platform_device	*pdev;
+	struct clk		*bus_clk;
+	struct clk		*lcdc_clk;
+	unsigned int		default_bpp;
+	unsigned int		default_lcdcon2;
+	unsigned int		default_dmacon;
+	void (*atmel_lcdfb_power_control)(int on);
+	struct fb_monspecs	*default_monspecs;
+	u32			pseudo_palette[16];
+};
+
+#define ATMEL_LCDC_DMABADDR1	0x00
+#define ATMEL_LCDC_DMABADDR2	0x04
+#define ATMEL_LCDC_DMAFRMPT1	0x08
+#define ATMEL_LCDC_DMAFRMPT2	0x0c
+#define ATMEL_LCDC_DMAFRMADD1	0x10
+#define ATMEL_LCDC_DMAFRMADD2	0x14
+
+#define ATMEL_LCDC_DMAFRMCFG	0x18
+#define	ATMEL_LCDC_FRSIZE	(0x7fffff <<  0)
+#define	ATMEL_LCDC_BLENGTH_OFFSET	24
+#define	ATMEL_LCDC_BLENGTH	(0x7f     << ATMEL_LCDC_BLENGTH_OFFSET)
+
+#define ATMEL_LCDC_DMACON	0x1c
+#define	ATMEL_LCDC_DMAEN	(0x1 << 0)
+#define	ATMEL_LCDC_DMARST	(0x1 << 1)
+#define	ATMEL_LCDC_DMABUSY	(0x1 << 2)
+#define		ATMEL_LCDC_DMAUPDT	(0x1 << 3)
+#define		ATMEL_LCDC_DMA2DEN	(0x1 << 4)
+
+#define ATMEL_LCDC_DMA2DCFG	0x20
+#define		ATMEL_LCDC_ADDRINC_OFFSET	0
+#define		ATMEL_LCDC_ADDRINC		(0xffff)
+#define		ATMEL_LCDC_PIXELOFF_OFFSET	24
+#define		ATMEL_LCDC_PIXELOFF		(0x1f << 24)
+
+#define ATMEL_LCDC_LCDCON1	0x0800
+#define	ATMEL_LCDC_BYPASS	(1     <<  0)
+#define	ATMEL_LCDC_CLKVAL_OFFSET	12
+#define	ATMEL_LCDC_CLKVAL	(0x1ff << ATMEL_LCDC_CLKVAL_OFFSET)
+#define	ATMEL_LCDC_LINCNT	(0x7ff << 21)
+
+#define ATMEL_LCDC_LCDCON2	0x0804
+#define	ATMEL_LCDC_DISTYPE	(3 << 0)
+#define		ATMEL_LCDC_DISTYPE_STNMONO	(0 << 0)
+#define		ATMEL_LCDC_DISTYPE_STNCOLOR	(1 << 0)
+#define		ATMEL_LCDC_DISTYPE_TFT		(2 << 0)
+#define	ATMEL_LCDC_SCANMOD	(1 << 2)
+#define		ATMEL_LCDC_SCANMOD_SINGLE	(0 << 2)
+#define		ATMEL_LCDC_SCANMOD_DUAL		(1 << 2)
+#define	ATMEL_LCDC_IFWIDTH	(3 << 3)
+#define		ATMEL_LCDC_IFWIDTH_4		(0 << 3)
+#define		ATMEL_LCDC_IFWIDTH_8		(1 << 3)
+#define		ATMEL_LCDC_IFWIDTH_16		(2 << 3)
+#define	ATMEL_LCDC_PIXELSIZE	(7 << 5)
+#define		ATMEL_LCDC_PIXELSIZE_1		(0 << 5)
+#define		ATMEL_LCDC_PIXELSIZE_2		(1 << 5)
+#define		ATMEL_LCDC_PIXELSIZE_4		(2 << 5)
+#define		ATMEL_LCDC_PIXELSIZE_8		(3 << 5)
+#define		ATMEL_LCDC_PIXELSIZE_16		(4 << 5)
+#define		ATMEL_LCDC_PIXELSIZE_24		(5 << 5)
+#define		ATMEL_LCDC_PIXELSIZE_32		(6 << 5)
+#define	ATMEL_LCDC_INVVD	(1 << 8)
+#define		ATMEL_LCDC_INVVD_NORMAL		(0 << 8)
+#define		ATMEL_LCDC_INVVD_INVERTED	(1 << 8)
+#define	ATMEL_LCDC_INVFRAME	(1 << 9 )
+#define		ATMEL_LCDC_INVFRAME_NORMAL	(0 << 9)
+#define		ATMEL_LCDC_INVFRAME_INVERTED	(1 << 9)
+#define	ATMEL_LCDC_INVLINE	(1 << 10)
+#define		ATMEL_LCDC_INVLINE_NORMAL	(0 << 10)
+#define		ATMEL_LCDC_INVLINE_INVERTED	(1 << 10)
+#define	ATMEL_LCDC_INVCLK	(1 << 11)
+#define		ATMEL_LCDC_INVCLK_NORMAL	(0 << 11)
+#define		ATMEL_LCDC_INVCLK_INVERTED	(1 << 11)
+#define	ATMEL_LCDC_INVDVAL	(1 << 12)
+#define		ATMEL_LCDC_INVDVAL_NORMAL	(0 << 12)
+#define		ATMEL_LCDC_INVDVAL_INVERTED	(1 << 12)
+#define	ATMEL_LCDC_CLKMOD	(1 << 15)
+#define		ATMEL_LCDC_CLKMOD_ACTIVEDISPLAY	(0 << 15)
+#define		ATMEL_LCDC_CLKMOD_ALWAYSACTIVE	(1 << 15)
+#define	ATMEL_LCDC_MEMOR	(1 << 31)
+#define		ATMEL_LCDC_MEMOR_BIG		(0 << 31)
+#define		ATMEL_LCDC_MEMOR_LITTLE		(1 << 31)
+
+#define ATMEL_LCDC_TIM1		0x0808
+#define	ATMEL_LCDC_VFP		(0xff <<  0)
+#define	ATMEL_LCDC_VBP_OFFSET		8
+#define	ATMEL_LCDC_VBP		(0xff <<  ATMEL_LCDC_VBP_OFFSET)
+#define	ATMEL_LCDC_VPW_OFFSET		16
+#define	ATMEL_LCDC_VPW		(0x3f << ATMEL_LCDC_VPW_OFFSET)
+#define	ATMEL_LCDC_VHDLY_OFFSET		24
+#define	ATMEL_LCDC_VHDLY	(0xf  << ATMEL_LCDC_VHDLY_OFFSET)
+
+#define ATMEL_LCDC_TIM2		0x080c
+#define	ATMEL_LCDC_HBP		(0xff  <<  0)
+#define	ATMEL_LCDC_HPW_OFFSET		8
+#define	ATMEL_LCDC_HPW		(0x3f  <<  ATMEL_LCDC_HPW_OFFSET)
+#define	ATMEL_LCDC_HFP_OFFSET		21
+#define	ATMEL_LCDC_HFP		(0x7ff << ATMEL_LCDC_HFP_OFFSET)
+
+#define ATMEL_LCDC_LCDFRMCFG	0x0810
+#define	ATMEL_LCDC_LINEVAL	(0x7ff <<  0)
+#define	ATMEL_LCDC_HOZVAL_OFFSET	21
+#define	ATMEL_LCDC_HOZVAL	(0x7ff << ATMEL_LCDC_HOZVAL_OFFSET)
+
+#define ATMEL_LCDC_FIFO		0x0814
+#define	ATMEL_LCDC_FIFOTH	(0xffff)
+
+#define ATMEL_LCDC_MVAL		0x0818
+
+#define ATMEL_LCDC_DP1_2	0x081c
+#define ATMEL_LCDC_DP4_7	0x0820
+#define ATMEL_LCDC_DP3_5	0x0824
+#define ATMEL_LCDC_DP2_3	0x0828
+#define ATMEL_LCDC_DP5_7	0x082c
+#define ATMEL_LCDC_DP3_4	0x0830
+#define ATMEL_LCDC_DP4_5	0x0834
+#define ATMEL_LCDC_DP6_7	0x0838
+#define	ATMEL_LCDC_DP1_2_VAL	(0xff)
+#define	ATMEL_LCDC_DP4_7_VAL	(0xfffffff)
+#define	ATMEL_LCDC_DP3_5_VAL	(0xfffff)
+#define	ATMEL_LCDC_DP2_3_VAL	(0xfff)
+#define	ATMEL_LCDC_DP5_7_VAL	(0xfffffff)
+#define	ATMEL_LCDC_DP3_4_VAL	(0xffff)
+#define	ATMEL_LCDC_DP4_5_VAL	(0xfffff)
+#define	ATMEL_LCDC_DP6_7_VAL	(0xfffffff)
+
+#define ATMEL_LCDC_PWRCON	0x083c
+#define	ATMEL_LCDC_PWR		(1    <<  0)
+#define	ATMEL_LCDC_GUARDT_OFFSET	1
+#define	ATMEL_LCDC_GUARDT	(0x7f <<  ATMEL_LCDC_GUARDT_OFFSET)
+#define	ATMEL_LCDC_BUSY		(1    << 31)
+
+#define ATMEL_LCDC_CONTRAST_CTR	0x0840
+#define	ATMEL_LCDC_PS		(3 << 0)
+#define		ATMEL_LCDC_PS_DIV1		(0 << 0)
+#define		ATMEL_LCDC_PS_DIV2		(1 << 0)
+#define		ATMEL_LCDC_PS_DIV4		(2 << 0)
+#define		ATMEL_LCDC_PS_DIV8		(3 << 0)
+#define	ATMEL_LCDC_POL		(1 << 2)
+#define		ATMEL_LCDC_POL_NEGATIVE		(0 << 2)
+#define		ATMEL_LCDC_POL_POSITIVE		(1 << 2)
+#define	ATMEL_LCDC_ENA		(1 << 3)
+#define		ATMEL_LCDC_ENA_PWMDISABLE	(0 << 3)
+#define		ATMEL_LCDC_ENA_PWMENABLE	(1 << 3)
+
+#define ATMEL_LCDC_CONTRAST_VAL	0x0844
+#define	ATMEL_LCDC_CVAL	(0xff)
+
+#define ATMEL_LCDC_IER		0x0848
+#define ATMEL_LCDC_IDR		0x084c
+#define ATMEL_LCDC_IMR		0x0850
+#define ATMEL_LCDC_ISR		0x0854
+#define ATMEL_LCDC_ICR		0x0858
+#define	ATMEL_LCDC_LNI		(1 << 0)
+#define	ATMEL_LCDC_LSTLNI	(1 << 1)
+#define	ATMEL_LCDC_EOFI		(1 << 2)
+#define	ATMEL_LCDC_UFLWI	(1 << 4)
+#define	ATMEL_LCDC_OWRI		(1 << 5)
+#define	ATMEL_LCDC_MERI		(1 << 6)
+
+#define ATMEL_LCDC_LUT(n)	(0x0c00 + ((n)*4))
+
+#endif /* __ATMEL_LCDC_H__ */
Index: linux-2.6.21.7/sound/soc/at91/eti_b1_wm8731.c
===================================================================
--- linux-2.6.21.7.orig/sound/soc/at91/eti_b1_wm8731.c
+++ linux-2.6.21.7/sound/soc/at91/eti_b1_wm8731.c
@@ -34,8 +34,7 @@
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 
-#include <asm/arch/hardware.h>
-#include <asm/arch/at91_pio.h>
+#include <asm/hardware.h>
 #include <asm/arch/gpio.h>
 
 #include "../codecs/wm8731.h"
@@ -48,13 +47,6 @@
 #define	DBG(x...)
 #endif
 
-#define AT91_PIO_TF1	(1 << (AT91_PIN_PB6 - PIN_BASE) % 32)
-#define AT91_PIO_TK1	(1 << (AT91_PIN_PB7 - PIN_BASE) % 32)
-#define AT91_PIO_TD1	(1 << (AT91_PIN_PB8 - PIN_BASE) % 32)
-#define AT91_PIO_RD1	(1 << (AT91_PIN_PB9 - PIN_BASE) % 32)
-#define AT91_PIO_RK1	(1 << (AT91_PIN_PB10 - PIN_BASE) % 32)
-#define AT91_PIO_RF1	(1 << (AT91_PIN_PB11 - PIN_BASE) % 32)
-
 static struct clk *pck1_clk;
 static struct clk *pllb_clk;
 
@@ -277,7 +269,6 @@ static struct platform_device *eti_b1_sn
 static int __init eti_b1_init(void)
 {
 	int ret;
-	u32 ssc_pio_lines;
 	struct at91_ssc_periph *ssc = eti_b1_dai.cpu_dai->private_data;
 
 	if (!request_mem_region(AT91RM9200_BASE_SSC1, SZ_16K, "soc-audio")) {
@@ -311,19 +302,12 @@ static int __init eti_b1_init(void)
 		goto fail_io_unmap;
 	}
 
- 	ssc_pio_lines = AT91_PIO_TF1 | AT91_PIO_TK1 | AT91_PIO_TD1
-			| AT91_PIO_RD1 /* | AT91_PIO_RK1 */ | AT91_PIO_RF1;
-
-	/* Reset all PIO registers and assign lines to peripheral A */
- 	at91_sys_write(AT91_PIOB + PIO_PDR,  ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_ODR,  ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_IFDR, ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_CODR, ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_IDR,  ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_MDDR, ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_PUDR, ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_ASR,  ssc_pio_lines);
- 	at91_sys_write(AT91_PIOB + PIO_OWDR, ssc_pio_lines);
+ 	at91_set_A_periph(AT91_PIN_PB6, 0);	/* TF1 */
+ 	at91_set_A_periph(AT91_PIN_PB7, 0);	/* TK1 */
+ 	at91_set_A_periph(AT91_PIN_PB8, 0);	/* TD1 */
+ 	at91_set_A_periph(AT91_PIN_PB9, 0);	/* RD1 */
+/* 	at91_set_A_periph(AT91_PIN_PB10, 0);*/	/* RK1 */ 	
+ 	at91_set_A_periph(AT91_PIN_PB11, 0);	/* RF1 */
 
 	/*
 	 * Set PCK1 parent to PLLB and its rate to 12 Mhz.
