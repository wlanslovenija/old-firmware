--- a/net80211/ieee80211_output.c	2009-03-20 23:17:10.000000000 +0100
+++ b/net80211/ieee80211_output.c	2009-03-20 23:46:35.000000000 +0100
@@ -740,6 +740,10 @@
 	int pdusize = 0;
 	int ismulticast = 0;
 	int use4addr = 0;
+	int ciphdrsize = 0;
+	int tailsize = 0;
+	int pktlen = 0;
+	struct ieee80211_cipher *cip;
 #ifdef ATH_SUPERG_FF
 	struct sk_buff *skb2 = NULL;
 	struct ether_header eh2;
@@ -1021,13 +1024,6 @@
 		ni->ni_txseqs[0]++;
 	}
 
-	/* Is transmit fragmentation needed? */
-	if (skb->len > vap->iv_fragthreshold &&
-	    !IEEE80211_IS_MULTICAST(wh->i_addr1)) {
-		int pktlen, skbcnt, tailsize, ciphdrsize;
-		struct ieee80211_cipher *cip;
-
-		pktlen = skb->len;
 		ciphdrsize = 0;
 		tailsize = IEEE80211_CRC_LEN;
 
@@ -1040,11 +1036,14 @@
 			if (cip->ic_cipher == IEEE80211_CIPHER_TKIP)
 				pktlen += IEEE80211_WEP_MICLEN;
 		}
+	/* Is transmit fragmentation needed? */
+	if (skb->len > vap->iv_fragthreshold &&
+	    !IEEE80211_IS_MULTICAST(wh->i_addr1)) {
+		int skbcnt;
 
-		pdusize = vap->iv_fragthreshold - (hdrsize_nopad + ciphdrsize);
-		fragcnt = *framecnt =
-			((pktlen - hdrsize_nopad) / pdusize) +
-			(((pktlen - hdrsize_nopad) % pdusize == 0) ? 0 : 1);
+		pktlen += skb->len - hdrsize;
+		pdusize = vap->iv_fragthreshold - (hdrsize + ciphdrsize + tailsize);
+		fragcnt = *framecnt = pktlen / pdusize + ((pktlen % pdusize == 0) ? 0 : 1);
 
 		/*
 		 * Allocate sk_buff for each subsequent fragment; First fragment
--- a/ath/if_ath.c	2009-03-21 23:04:57.000000000 +0100
+++ b/ath/if_ath.c	2009-03-22 16:44:25.000000000 +0100
@@ -3674,6 +3674,7 @@
 		 *  already alloc'd
 		 */
 		ATH_TXBUF_LOCK_IRQ(sc);
+		STAILQ_INSERT_TAIL(&bf_head, bf, bf_list);
 		for (bfcnt = 1; bfcnt < framecnt; ++bfcnt) {
 			tbf = ath_take_txbuf_locked(sc);
 			if (tbf == NULL)
